<!DOCTYPE HTML>
<html>
  
<!-- Mirrored from java.scjp.jobs4times.com/inner.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:21:20 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title> Java Inner Classes concepts | Java Inner Classes Tutorial | Java Inner Classes Class Room study material | Java Inner Classes Practical Demonstration | Java Inner Classes Real Time Examples | Java Inner Classes  Interview Questions and Answers</title>
	
    <meta http-equiv="keywords" content="Java Inner Classes Introduction, Normal or Regular inner classes, Accessing inner class code from static area of outer class,
	Accessing inner class code from instance area of outer class , Accessing inner class code from outside of outer class, The applicable modifiers for outer & inner classes,
	Nesting of Inner classes, Method Local inner classes, Anonymous inner classes, Anonymous inner class that extends a class, Anonymous Inner Class that implements an interface,
	Anonymous Inner Class that define inside method arguments, Difference between general class and anonymous inner classes, Explain the application areas of anonymous inner classes ? ,
	Static nested classes, Compression between normal or regular class and static nested class ? , Various possible combinations of nested class & interfaces, class inside a class ,
	interface inside a class, interface inside a interface, class inside a interface, Conclusions ">

    <meta http-equiv="description" content="Sometimes we can declare a class inside another class such type of classes are called inner classes">
    
    
    <link rel="stylesheet" type="text/css" href="styles.css">
    

    
  </head>
  
  <body>

<div align="center">
<table  border="4"  width="75%"><tr><td> 

 <table width="100%" cellpadding="0" cellspacing="0" border="0" bgcolor="">
     <tr>
<td width="50%" align="left"><a href="https://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="700" height="200">   </a> </td> 
   	<td  align="right"><a href="index-2.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td>
    </tr>
    </table>  	
  

<h1 align="center" style="background-color: rgb(0, 128, 0);"><font color="#ffff00"> Inner Classes</font></h1>




<u><em><strong>Agenda  
</strong></em></u><ol>
<li><a href="#intro" > Introduction.</a></li>
<li><a href="#normal" >Normal or Regular inner classes</a>
<ul><li><a href="#static"> Accessing inner class code from static area of outer class</a></li>
<li><a href="#instance" >Accessing inner class code from instance area of outer class</a> </li>
<li><a href="#outside">Accessing inner class code from outside of outer class </li>
<li><a href="#modifier">The applicable modifiers for outer &amp; inner classes</a></li>
<li><a href="#nesting">Nesting of Inner classes</a></li></ul></li>
<li><a href="#methodlocal" >Method Local inner classes</a></li>
<li><a href="#anonymous" >Anonymous inner classes</a>
<ul>
<li><a href="#extend">Anonymous inner class that extends a class</a></li>
<li><a href="#implement">Anonymous Inner Class that implements an interface</a></li>
<li><a href="#argument">Anonymous Inner Class that define inside method arguments</a></li>
<li><a href="#diffanony">Difference between general class and anonymous inner classes</a></li>
<li><a href="#area">Explain the application areas of anonymous inner classes ?</a></li>
</ul>
</li>
<li><a href="#nested" >Static nested classes</a>
<ul><li><a href="#compression">Compression between normal or regular class and static nested class ? </a></li></ul>
</li>
<li><a href="#combination">Various possible combinations of nested class &amp; interfaces </a><ul>
<li><a href="#clacla">class inside a class </a></li>
<li><a href="#intcla">interface inside a class</a></li>
<li><a href="#intint">interface inside a interface</a></li>
<li><a href="#claint">class inside a interface</a></li>
</ul>
</li>
<li><a href="#conclu">Conclusions</a></li>
</ol>







<h2  id="intro" style="background-color: rgb(0, 64, 128);"><font color="#ffff00">Introduction</font></h2>









<ul>
<li>Sometimes we can declare a class inside another class such type of classes are called inner classes.</li>
</ul> 
 
<u>Diagram:</u><br><br><img alt="" src="inner/image001.png"><br><br>
<ul>
<li>Sun people introduced inner classes in 1.1 version as part of "EventHandling" to resolve GUI bugs.</li>
<li>But because of powerful features and benefits of inner classes slowly the programmers starts using in regular coding also.</li>
<li>Without existing one type of object if there is no chance of existing another type of object then we should go for inner classes.</li>
</ul> 
 
<u>Example:</u><br><br> Without existing University object there is no chance of existing Department object hence we have to define Department class inside University class.<br><br> 
<u>Example1:</u><br><br><img alt="" src="inner/image002.png"><br><br>
 <br> 
<u>Example 2:</u><br><br> Without existing Bank object there is no chance of existing Account object hence we have to define Account class inside Bank class.<br><br> 
<u>Example:</u><br><br><br><img alt="" src="inner/image003.png"><br><br> 
  
<u>Example 3:</u><br><br> Without existing Map object there is no chance of existing Entry object hence Entry interface is define inside Map interface.<br>Map is a collection of key-value pairs, each key-value pair is called an Entry.<br>

<br> 
<u>Example:</u><br><br>
 <br><img alt="" src="inner/image004.png"><br><br> 
  
<u>Diagram:</u><br><br><br><img alt="" src="inner/image005.png"><br><br>
<p><b>Note : </b>Without existing Outer class Object there is no chance of existing  Inner class Object.  </p>
<p><em><u><strong>Note:</strong></u></em> <strong>The relationship between outer class and inner class is not IS-A relationship and it is Has-A relationship.</strong></p>

Based on the purpose and position of declaration all inner classes are divided into 4 types.<br> They are:
<ol>
<li>	Normal or Regular inner classes</li>
<li>	Method Local inner classes</li>
<li>	Anonymous inner classes</li>
<li>	Static nested classes.</li>
</ol>

<h3  id="normal"  style="background-color: rgb(0, 128, 0);"><font color="#ffffff">1. Normal (or) Regular inner class:</font></h3>

 If we are declaring any named class inside another class directly without static modifier such type of inner classes are called normal or regular inner classes.<br><br> 
  
<u>Example: 
 
</u><pre>
class Outer
{
	class Inner
	{
	}
}
Output:
</pre>
 <br><br><img alt="" src="inner/image006.png"><br><br> 
<u>Example: 
 
</u><pre>
class Outer
{
	class Inner
	{
	}
	public static void main(String[] args)
	{
		System.out.println("outer class main method");
	}
}
Output:
</pre>
<br><br><img alt="" src="inner/image007.png"><br><br>
<ul>
<li>Inside inner class we can't declare static members. Hence it is not possible to declare main() method and we can't invoke inner class directly from the command prompt.</li></ul> 
 
 
<u>Example: 
</u><pre>
class Outer
{
	class Inner
	{
		public static void main(String[] args)
		{
			System.out.println("inner class main method");
		}
	}
}
Output:
E:\scjp&gt;javac Outer.java
Outer.java:5: inner classes cannot have static declarations
                public static void main(String[] args)
</pre>
<br> 
<font color="#0080ff"  id="static" ><u><strong>Accessing inner class code from static area of outer class: 
 
</strong></u></font><br><br> 
<u>Example: 
</u><pre>
class Outer
{
	class Inner
	{
		public void methodOne(){
			System.out.println("inner class method");
		}
	}
	public static void main(String[] args)
	{
	           <img align="middle" alt="" src="inner/image008.png">	 
	}
}
</pre>
<br> 
<font color="#8000ff"   id="instance" ><u><strong>Accessing inner class code from instance area of outer class: 
</strong></u></font><br><br> 
<u>Example: 
 
</u><pre>
class Outer
{
	class Inner
	{
		public void methodOne()
		{
			System.out.println("inner class method");
		}
	}
	public void methodTwo()
	{
		Inner i=new Inner();
		i.methodOne();
	}
	public static void main(String[] args)
	{
		Outer o=new Outer();
		o.methodTwo();
	}
}
Output:
E:\scjp&gt;javac Outer.java
E:\scjp&gt;java Outer
Inner class method
</pre>
<br> 
<font color="#800040"  id="outside" ><u><strong>Accessing inner class code from outside of outer class:</strong></u></font><br><br> 
<u>Example: 
 
</u><pre>
class Outer
{
	class Inner
	{
		public void methodOne()
		{
			System.out.println("inner class method");
		}
	}
}
class Test
{
	public static void main(String[] args)
	{
		new Outer().new Inner().methodOne();
	}
}
Output:
Inner class method
</pre>
<br><br><img alt="" src="inner/image009.png"><br><br>
<ul>
<li>	From inner class we can access all members of outer class (both static and non-static, private and non private methods and variables) directly.</li></ul> 
 
<u>Example: 
 
</u><pre>
class Outer
{
	int x=10;
	static int y=20;
	class Inner{
		public void methodOne()
		{
			System.out.println(x);//10
			System.out.println(y);//20
		}
	}
	public static void main(String[] args)
	{
		new Outer().new Inner().methodOne();
	}
}
</pre>

<ul>
<li>	Within the inner class &quot;<strong>this</strong>&quot; always refers current inner class object. To refer current outer class object we have to use &quot;<strong>outer class name.this</strong>&quot;.</li></ul> 
 
 
<u>Example: 
 
</u><pre>
class Outer
{
	int x=10;
	class Inner
	{
		int x=100;
		public void methodOne()
		{
			int x=1000;
			System.out.println(x);//1000
			System.out.println(this.x);//100
			System.out.println(Outer.this.x);//10
		}
	}
	public static void main(String[] args)
	{
		new Outer().new Inner().methodOne();
	}
}
</pre>


<br><h3   id="modifier">  
 
 <u><strong>The applicable modifiers for outer classes are: 
  
</strong></u></h3><ol>
<li>	public</li>
<li>	default</li>
<li>	final</li>
<li>	abstract</li>
<li>	strictfp</li>
</ol>

But for the inner classes in addition to this the following modifiers also allowed.

<br><br> 
<u>Diagram:</u><br><br><img alt="" src="inner/image010.png"><br><br>
 <br>
 


<h3  id="nesting" ><em><u> Nesting of Inner classes :</em></u></h3><br>
We can declare an  inner class inside  another inner class

<br>

<br> 
<u>Diagram:</u><br><br><img alt="" src="inner/inner.png"><br><br>
 <br>

<h3   id="methodlocal"  style="background-color: rgb(128, 0, 64);"><font color="#ffffff">Method local inner classes:</font></h3>
 

<ul>
<li>Sometimes we can declare a class inside a method such type of inner classes are called method local inner classes.</li>
<li>The main objective of method local inner class is to define method specific repeatedly required functionality.</li>
<li>Method Local inner classes are best suitable to meet nested method requirement.</li>
<li>We can access method local inner class only within the method where we declared it. That is from outside of the method we can't access. As the scope of method local inner classes is very less, this type of inner classes are most rarely used type of inner classes.</li>
</ul> 
 
 
<u>Example: 
</u><pre>
class Test
{
	public void methodOne()
	{
		class Inner
		{
			public void sum(int i,int j)
			{
				System.out.println("The sum:"+(i+j));
			}
		}
		Inner i=new Inner();
		i.sum(10,20);
		;;;;;;;;;;;;;
		i.sum(100,200);
		;;;;;;;;;;;;;;;
		i.sum(1000,2000);
		;;;;;;;;;;;;;;;;;
	}
	public static void main(String[] args)
	{
		new Test().methodOne();
	}
}
Output:
The sum: 30
The sum: 300
The sum: 3000
</pre>


<ul>
<li>If we are declaring inner class inside instance method then we can access both static and non static members of outer class directly.</li>
<li>But if we are declaring inner class inside static method then we can access only static members of outer class directly and we can't access instance members directly.</li>
</ul> 
 
 
<u>Example: 
</u><pre>
class Test
{
	int x=10;
	static int y=20;
	public void methodOne()
	{
		class Inner
		{
			public void methodTwo()
			{
				System.out.println(x);//10
				System.out.println(y);//20
			}
		}
		Inner i=new Inner();
		i.methodTwo();
	}
	public static void main(String[] args)
	{
		new Test().methodOne();
	}
}
</pre>

<ul>
<li>If we declare methodOne() method as static then we will get compile time error saying &quot;<strong>non-static variable x cannot be referenced from a static context</strong>&quot;.</li>
<li>From method local inner class we can't access local variables of the method in which we declared it. But if that local variable is declared as final then we won't get any compile time error.</li>
</ul> 
 
<u>Example: 
</u><pre>
class Test
{
	int x=10;
	public void methodOne()
	{
		int y=20;
		class Inner
		{
			public void methodTwo()
			{
				System.out.println(x);//10
				System.out.println(y); //C.E: local variable y
				             is accessed from within inner class; 
				             needs to be declared final.
			}
		}
		Inner i=new Inner();
		i.methodTwo();
	}
	public static void main(String[] args)
	{
		new Test().methodOne();
	}
}
</pre>

<ul>
<li>If we declared y as final then we won't get any compile time error.</li>
<li>Consider the following declaration.</li>
</ul>


<pre>
class Test
{
	int i=10;
	static int j=20;
	public void methodOne()
	{
		int k=30;
		final int l=40;
		class Inner
		{
			public void methodTwo()
			{
				System.out.println(i);
				System.out.println(j); //--&gt;line 1
				System.out.println(k);
				System.out.println(l);
			}
		}
		Inner i=new Inner();
		i.methodTwo();
	}
	public static void main(String[] args)
	{
		new Test().methodOne();
	}
}
</pre>

<p>	<font color="#ff0000"><u><strong>At line 1 which of the following variables we can access ? </strong></u></font><br>
<br><br><img alt="" src="inner/image011.png"><br><br> 
<font color="#ff0000"><u><strong>If we declare methodOne() method as static then which variables we can access at line 1 ? 
</strong></u></font><br><br><img alt="" src="inner/image012.png"><br><br>
</p>


<ul>
<li>If we declare methodTwo() as static then we will get compile time error because we can't declare static members inside inner classes.</li>
<li>The only applicable modifiers for method local inner classes are:
   <ol>
   <li>	final</li>
   <li>	abstract</li>
   <li>	strictfp</li>
   </ol>
   </li>
<li>By mistake if we are declaring any other modifier we will get compile time error.</li>
</ul>

<h3   id="anonymous"  style="background-color: rgb(255, 128, 64);"><font color="#ffffff">Anonymous inner classes:</font></h3>

<ul>
<li>Sometimes we can declare inner class without name such type of inner classes are called anonymous inner classes.</li>
<li>The main objective of anonymous inner classes is &quot;<strong>just for instant use</strong>&quot;.</li>
<li>There are 3 types of anonymous inner classes
	<ol>
	<li>Anonymous inner class that extends a class.</li>
	<li>Anonymous inner class that implements an interface.</li>
	<li>Anonymous inner class that defined inside method arguments.</li>
	</ol>
</li>
</ul>

<br> 
<font color="#0000ff"  id="extend" ><u><strong>Anonymous inner class that extends a class: 
</strong></u></font><br>
<pre>
class PopCorn
{
	public void taste()
	{
		System.out.println("spicy");
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		PopCorn p=new PopCorn()
		{
			public void taste()
			{
				System.out.println("salty");
			}
		};
		p.taste();//salty
		PopCorn p1=new PopCorn()
		p1.taste();//spicy
	}
}
</pre> 
 
<font color="#8000ff"><u><strong>Analysis: 
 
</strong></u></font><ol>

<li>
<p>	PopCorn p=new PopCorn();	<br>
	We are just creating a PopCorn object.  </p>
</li>

<li>
<pre>
PopCorn p=new PopCorn()
{
};
</pre>

We are creating child class without name for the PopCorn class and for that child class we are creating an object with Parent PopCorn reference.
</li>

<li>
<pre>
	PopCorn p=new PopCorn()
	{
		public void taste()
		{
		System.out.println("salty");
		}
	};
</pre>
</li>
</ol>

<ol>
<li>	We are creating child class for PopCorn without name.</li>
<li>	We are overriding taste() method.</li>
<li>	We are creating object for that child class with parent reference.</li>
</ol>

<p><u><strong>Note:</strong></u> Inside Anonymous inner classes we can take or  declare new methods but outside of anonymous inner classes we can't call these methods directly because we are depending on parent reference.[parent reference can be used to hold child class object but by using that reference we can't call child specific methods]. These methods just for internal purpose only.</p> 
 
 
<u>Example 1: 
</u><pre>
class PopCorn
{
	public void taste()
	{
		System.out.println("spicy");
	}
}
class Test 
{
	public static void main(String[] args) 
	{
		PopCorn p=new PopCorn()
		{
			public void taste()
			{
				methodOne();//valid call(internal purpose)
				System.out.println("salty");
			}
			public void methodOne()
			{
				System.out.println("child specific method");
			}
		};
		//p.methodOne();//here we can not call(outside inner class)
		p.taste();//salty
		PopCorn p1=new PopCorn();
		p1.taste();//spicy
	}
}
Output:
Child specific method
Salty
Spicy
</pre> 
 
 
<u>Example 2: 
 
</u><pre>
class Test 
{
	public static void main(String[] args) 
	{
		Thread t=new Thread()
		{
			public void run()
			{
				for(int i=0;i&lt;10;i++)
				{
					System.out.println("child thread");
				}
			}
		};
		t.start();
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("main thread");
		}
	}
}
</pre>
<br> 
<font color="#000080"  id="implement" ><u><strong>Anonymous Inner Class that implements an interface: 
</strong></u></font><br><br> 
<u>Example: 
 
</u><pre>
class InnerClassesDemo 
{
	public static void main(String[] args) 
	{
		Runnable r=new Runnable()  //here we are not creating for
					Runnable interface, we are creating 
					implements class object.
		{
			public void run()
			{
				for(int i=0;i&lt;10;i++)
				{
					System.out.println("Child thread");
				}
			}
		};
		Thread t=new Thread(r);
		t.start();
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("Main thread");
		}
	}
}
</pre>

<br> 
<font color="#800040"  id="argument" ><u><strong>Anonymous Inner Class that define inside method arguments: 
</strong></u></font><br><br> 
<u>Example: 
</u><pre>
class Test 
{
	public static void main(String[] args) 
	{
		new Thread(
			new Runnable()
		{
			public void run()
			{
				for(int i=0;i&lt;10;i++)
				{
					System.out.println("child thread");
				}
			}
		}).start();
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("main thread");
		}
	}
}
Output:
</pre>

<ul>
<li>This output belongs to example 2, anonymous inner class that implements an interface example and anonymous inner class that define inside method arguments example.</li></ul>

<pre>
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Main thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
Child thread
</pre>

<h4 style="background-color: rgb(0, 128, 0);"  id="diffanony" ><font color="#ffffff">Difference between general class and anonymous inner classes:</font></h4>

<table border="1">
<tr><th>General Class</th><th>	Anonymous Inner Class</th></tr>
<tr><td>1)	A general class can extends only one class at a time.</td><td>	1)	Ofcource anonymous inner class also can extends only one class at a time.</td></tr>
<tr><td>2)	A general class can implement any no. Of interfaces at a time.</td><td>	2)	But anonymous inner class can implement only one interface at a time.</td></tr>
<tr><td>3)	A general class can extends a class and can implement an interface simultaneously.</td><td>	3)	But anonymous inner class can extends a class or can implements an interface but not both simultaneously.</td></tr>
<tr><td>4)	In normal Java class we can write constructor because we know name of the class.</td><td>	4)	But in anonymous inner class we can't  write constructor  because anonymous inner class not having any name.</td></tr>
</table>



<h4  id="area" ><u>Explain the application areas of anonymous  inner classes ?</u> </h4>
anonymous inner classes are best suitable to define <b> call back functions</b> in GUI components 


<pre>
import java.awt.*;
import java.awt.event.*;

public class AnonymousInnerClassDemo {
 public static void main(String args[]) {
 Frame f=new Frame();

 f.addWindowListener(new WindowAdaptor(){
	public void windowClosing(WindowEvent e) {
	  System.exit(0);
	}
 });

  f.add(new Label("Anonymous Inner class Demo !!!"));
  f.setSize(500,500);
  f.setVisible(true);
 }
}


<b><u>Without Anonumous Inner class :</u></b>

class GUI extends JFrame implements ActionListener {
 JButton b1,b2,b3,b4;
  -----------------
 public void actionPerformed(ActionEvent e) {
  if(e.getSource()==b1) {
	//perform b1 specific functionality
  }
  else if(e.getSource==b2){
    //perform b2 specific  functionality
   }

   ---------------------

 }
 ----------------

}



<b><u>With Anonumous Inner class :</b></u>

class GUI extends  JFrame {
 JButton b1,b2,b3,b4 ;
  --------------------

 b1.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
   //perform b1 specific functionality
  }
 });


 b2.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
   //perform b2 specific functionality
  }
 });

 ---------
}

</pre>

<br>

<h3 style="background-color: rgb(128, 128, 0);"  id="nested" ><font color="#ffffff">Static nested classes:</font></h3>
<ul>
<li>Sometimes we can declare inner classes with static modifier such type of inner classes are called static nested classes.</li>
<li>In the case of normal or regular inner classes without existing outer class object there is no chance of existing inner class object.<br> i.e., inner class object is always strongly  associated  with outer class object.</li>
<li>But in the case of static nested class without existing outer class object there may be a chance of existing static nested class object.<br> i.e., static nested class object is not strongly associated with outer class object.</li>
</ul> 
 
<u>Example: 
</u><pre>
class Test 
{
	static class Nested
	{
		public void methodOne()
		{
			System.out.println("nested class method");
		}
	}
	public static void main(String[] args)
	{
		Test.Nested t=new Test.Nested();
		t.methodOne();
	}
}
</pre>


<ul>
<li>	Inside static nested classes we can declare static members including main() method also. Hence it is possible to invoke static nested class directly from the command prompt.</li></ul> 
 
<u>Example: 
</u><pre>
class Test 
{
	static class Nested
	{
		public static void main(String[] args)
		{
			System.out.println("nested class main method");
		}
	}
	public static void main(String[] args)
	{
		System.out.println("outer class main method");
	}
}
Output:
E:\SCJP&gt;javac Test.java
E:\SCJP&gt;java Test
Outer class main method
E:\SCJP&gt;java Test$Nested
Nested class main method
</pre>

<ul>
<li>From the normal inner class we can access both static and non static members of outer class but from static nested class we can access only static members of outer class.</li></ul> 
 
<u>Example: 
</u><pre>
class Test 
{
	int x=10;
	static int y=20;
	static class Nested
	{
		public void methodOne()
		{
			System.out.println(x);//C.E:non-static variable x 
						cannot be referenced from a static context
			System.out.println(y);
		}
	}
}
</pre>

<h3 style="background-color: rgb(128, 0, 0);"  id="compression" ><font color="#ffffff">Compression between normal or regular class and static nested class ? </font></h3>

<table border="1">
<tr><th>Normal /regular inner class</th><th>	Static nested class</th></tr>
<tr><td>1)	Without existing outer class object there is no chance of existing inner class object. That is inner class object is always associated with outer class object.</td><td>	1)	Without existing outer class object there may be a chance of existing static nested class object. That is static nested class object is not associated with outer class object.</td></tr>
<tr><td>2)	Inside normal or regular inner class we can't declare static members.</td><td>	2)	Inside static nested class we can declare static members.</td></tr>
<tr><td>3)	Inside normal inner class we can't declare main() method and hence we can't invoke regular inner class directly from the command prompt.</td><td>	3)	Inside static nested class we can declare main() method and hence we can invoke static nested class directly from the command prompt.</td></tr>
<tr><td>4)	From the normal or regular inner class we can access both static and non static members of outer class directly.</td><td>	4)	From static nested class we can access only static members of outer class directly.</td></tr>
</table>
<br>


<h3  id="combination" ><b><u><em>Various possible combinations of  nested class &amp; interfaces :</em></u></b></h3> 

<h4  id="clacla" ><u>1. class inside a class :</u> </h4>
<ul><li>We can declare a class inside another class</li><li>Without existing one type of object, if there is no chance of existing another  type of object, then we should go for  clas  inside a class</li></ul>

<pre>
class University {
  class Department {
   }
}
</pre>

Without existing  University object, there is no chance  of existing Department object. i.e., Department object is always  associated with  University

<h4  id="intcla" ><u>2. interface inside a class :</u> </h4>

We can declare interface inside a class

<pre>
class X {
 interface Y {
  }
}
</pre>

Inside class if we required multiple implements of an interface  and  these  implementations of relevant  to a  perticular  class, then we should declare  interface inside a class.


<pre>
class VehicleType {
  interface Vehicle {
	public int getNoOfWheels();
  }

  class Bus implements Vehicle {
	public int getNoOfWheels() {
         return 6;
        }
  }

  class Auto implements Vehicle {
	public int getNoOfWheels() {
         return 3;
        }
  }

}
</pre>

<br>

<h4  id="intint" ><u>3. interface inside a interface :</U> </h4>
We can declare an interface  inside another interface.
<pre>
interface Map {
 interface Entry {
  public Object getKey();
  public Object getValue();
  public Object getValue(Object  new );
  }
}
</pre>

Nested interfaces are always  public,static  whether we are  declaring or not. Hence we can  implements  inner inteface directly  with out  implementing outer interface.

<pre>
interface Outer {
 public void methodOne();
 interface Inner {
  public void methodTwo();
 }
}

class Test implements  Outer.Inner {
 public void methodTwo() {
  System.out.println("Inner interface method");
 }
 public static void main(String args[]) {
  Test t=new Test();
  t.methodTwo();
 }
}
</pre>



Whenever we are implementing  Outer interface , it is not required  to implement  Inner interfaces.

<pre>
class Test implements Outer {
 public void methodOne() {
  System.out.println("Outer interface  method ");
 }
 public static void main(String args[]) {
  Test t=new Test();
  t.methodOne();
 }

}
</pre>

i.e., Both Outer and Inner interfaces  we can implement independently.


<h4  id="claint" ><u>4. class inside a interface :</u> </h4>

We can declare a class inside  interface.

If a class functionality is closely  associated with the use interface then it is highly recommended to declare  class inside  interface 

<pre>
Example:

interface EmailServer {
 public void sendEmail(EmailDetails e);

 class EmailDetails {
  String from;
  String to;
  String subject;
 }
}
</pre>

In the above example  Emaildetails functionality  is required for  EmailService  and  we are not using anyware  else . Hence we can declare EmailDetails  class inside EmailService  interface .

<br>
<br>
We can also declare a class inside interface to provide default  implementation for that interface.

<pre>
Example :

interface Vehicle {
 public int getNoOfWheels();

 class DefaultVehicle implements  Vehicle {
  public int getNoOfWheels() {
   return 3;
  }
 }
}

class Bus implements Vehicle {
 public int getNoOfWheels() {
  return 6;
 }
}

class Test {
 public static void main(String args[]) {
  Bus b=new Bus();
  System.out.println(b.getNoOfWheels());

  Vehicle.DefaultVehicle d=new Vehicle.DefaultVehicle();
  System.out.println(d.getNoOfWheels());
 }
}
</pre>

In the above example  DefaultVehicle in the default  implementation of Vehicle  interface where as Bus  customized implementation of Vehicle interface.
<br>
The  class which is declared  inside  interface  is always  static ,hence we can  create  object directly  without having outer interface type  object.

   
<h4  id="conclu" ><u> Conclusions :</u> </h4>

<ol>
<li>We can declare anything  inside  any thing  with respect to classes  and  interfaces.

<br>
<br><img alt="" src="inner/inner1.png"><br>

</li>
<li>Nesting interfaces are always  public, static  whether we are  declaring  or  not.</li>
<li>class  which is  declared  inside interface is always public,static  whether we are declaring or not.</li>
</ol>

      <br> 
   
</td></tr></table><a href="index-2.html">BACK</a></div>




     
 <!-- infolinks  -->   
<script type="text/javascript">
 var infolinks_pid = 1921552;
 var infolinks_wsid = 0;
</script>
<script type="text/javascript" src="../resources.infolinks.com/js/infolinks_main.js"></script>
   



  </body>

<!-- Mirrored from java.scjp.jobs4times.com/inner.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:21:22 GMT -->
</html>