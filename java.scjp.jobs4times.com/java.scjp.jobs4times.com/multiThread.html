<!DOCTYPE HTML >
<html>
  
<!-- Mirrored from java.scjp.jobs4times.com/multiThread.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:20:40 GMT -->
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>Java MultiThreading concepts | Java MultiThreading Tutorial | Java MultiThreading Class Room study material | Java MultiThreading  Practical Demonstration | Java MultiThreading  Real Time Examples | Java MultiThreading Interview Questions and Answers</title>
	
    <meta http-equiv="keywords" content="The ways to define, instantiate and start a new Thread, By extending Thread class,
	By implementing Runnable interface, Thread class constructors, Thread priority, Getting and setting name of a Thread, The methods to prevent(stop) Thread execution, 
	yield(), join(), sleep(), Synchronization, Inter Thread communication, Deadlock, Daemon Threads, Various Conclusions, To stop a Thread, Suspend & resume of a thread,
	Thread group, Green Thread, Thread Local,Life cycle of a Thread ">
    <meta http-equiv="description" content="Executing several tasks simultaneously where each task is a separate independent part of the same program, is called Thread based multitasking.
 	And each independent part is called a Thread. ">
    
    
    <link rel="stylesheet" type="text/css" href="styles.css">
    
  

  </head>
  
  <body>
  <div align="center">
  
  <table  border="2" width="70%" ><tr><td>
  
   <table width="100%" cellpadding="0" cellspacing="0" border="0">
     <tr>
     <td width="50%" align="left"><a href="https://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="700" height="200">   </a> </td> 
   	<td  align="right"><a href="index-2.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td>
    </tr>
    </table>  	
  
  
  
  
  <h1 style="background-color: rgb(0, 192, 192);"> <font color="#ffff00" >Multi Threading</font></h1> 
<u><em><strong>Agenda  
</strong></em></u><ol>
<li><a href="#intro" > Introduction.</a></li>
<li><a href="#define" >The ways to define, instantiate and start a new Thread.</a>  <ol><li><a href="#extend" >By extending Thread  class</a></li><li><a href="#implement" >By implementing  Runnable  interface</a></li>	</ol>	</li>
<li><a href="#constructor" >Thread class constructors</a></li>
<li><a href="#priority" >Thread priority</a></li>
<li><a href="#nameThread" >Getting and setting name of a Thread.</a></li>
<li><a href="#execution" >The methods to prevent(stop) Thread execution.</a><ol><li><a href="#yield">yield()</a></li><li><a href="#join" >join()</a></li><li><a href="#sleep" >sleep()</a></li></ol></li>
<li><a href="#syncronization" >Synchronization.</a></li>
<li><a href="#threadCommunication" >Inter Thread communication.</a></li>
<li><a href="#deadLock" >Deadlock</a></li>
<li><a href="#daemon" >Daemon Threads.</a></li>
<li>Various Conclusion 
<ol>
<li><a href="#stop"> To stop a Thread</a></li>
<li><a href="#suspend" >Suspend &amp; resume of a thread</a> </li>
<li><a href="#group">Thread group </li>
<li><a href="#green">Green Thread</a></li>
<li><a href="#local">Thread Local</a></li></ol></li>
<li><a href="#life">Life cycle of a Thread</a></li>
</ol>

<h2  id="intro" style="background-color: rgb(0, 64, 128);"><font color="#ffff00">Introduction</font></h2>

<strong>Multitasking:</strong>
 Executing several tasks simultaneously is the concept of multitasking. There are two types of multitasking's.
<ol><li><font color="#0080ff"><strong>Process based multitasking.</strong></font></li>
<li><font color="#0080ff"><strong>Thread based multitasking.</strong></font></li></ol> 
<font color="#008000"><u><strong>Diagram: 
</strong></u></font><br><br><img alt="" src="multiThread/image001.png" width="678" height="152"><br><br>

<h3><em><u><font color="#0000ff">Process based multitasking:</font></u></em></h3>
 Executing several tasks simultaneously where each task is a separate independent process such type of multitasking is called process based multitasking.
 <br>
Example:
<ul>
<li>While typing a java program in the editor we can able to listen mp3 audio songs at the same time we can download a file from the net all these tasks are independent of each other and executing simultaneously and hence it is Process based multitasking.</li>
<li>This type of multitasking is best suitable at "os level".</li></ul>

<h3><font color="#0000ff"><em><u>Thread based multitasking:</u></em></font></h3>
 Executing several tasks simultaneously where each task is a separate independent part of the same program, is called Thread based multitasking.<br> And each independent part is called a "Thread".
 <ol>
 <li>This type of multitasking is best suitable for "programatic level".</li>
 <li>When compared with "C++", developing multithreading examples is very easy in java because java provides in built support for multithreading through a rich API (Thread, Runnable, ThreadGroup, ThreadLocal...etc).</li>
 <li>In multithreading on 10% of the work the programmer is required to do and 90% of the work will be down by java API.</li>
 <li><em><strong>The main important application areas of multithreading are: </strong></em>
 	<ol><li>To implement multimedia graphics.</li>
 	<li>To develop animations.</li>
 	<li>To develop video games etc.</li>
	<li>To develop web and application servers</li></ol>
 </li>
 <li>Whether it is process based or Thread based the main objective of multitasking is to improve performance of the system by reducing response time.</li>
 </ol>
 
 <h2  id="define" style="background-color: rgb(128, 0, 64);"><font color="#ffff00">The ways to define instantiate and start a new Thread:</font></h2>
What is singleton? Give example? <br>
We can define a Thread in the following 2 ways.
<ol><li>By extending Thread class.</li>
<li>By implementing Runnable interface.</li>
</ol>

<h3 id="extend"><u>Defining a Thread by extending &quot;Thread class&quot;:</u></h3>


Example:
 
<br><br><img alt="" src="multiThread/image003.png" width="666" height="382"><br><br>
<pre>

class ThreadDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();//Instantiation of a Thread
		t.start();//starting of a Thread
		
		for(int i=0;i&lt;5;i++)
		{
			System.out.println("main thread");
		}
	}
}
</pre>

<h3><u><em><font color="#800040">Case 1:  Thread Scheduler:</font></em></u></h3>

<ul>
<li>If multiple Threads are waiting to execute then which Thread will execute 1st is decided by "Thread Scheduler" which is part of JVM.</li>
<li>Which algorithm or behavior followed by Thread Scheduler we can't expect exactly it is the JVM vendor dependent hence in multithreading examples we can't expect exact execution order and exact output.</li>
<li>The following are various possible outputs for the above program.
<br><br><img alt="" src="multiThread/image006.png" width="671" height="539"><br><br>
</li>
</ul>
 
 <h3><u><em><font color="#800080">Case 2: Difference between t.start() and t.run() methods.</font></em></u></h3>
 <ul>
<li> In the case of t.start() a new Thread will be created which is responsible for the execution of run() method.</li>
<li> But in the case of t.run() no new Thread will be created and run() method will be executed just like a normal method by the main Thread.</li>
<li> In the above program if we are replacing t.start() with t.run() the following is the output.</li></ul>
<pre>
Output:
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
main thread
main thread
main thread
main thread
main thread
</pre>
Entire output produced by only main Thread.

<h3><font color="#0080c0"><em><u>Case 3:  importance of Thread class start() method.</u></em></font></h3>
For every Thread the required mandatory activities like registering the Thread with Thread Scheduler will takes care by Thread class start() method and programmer is responsible just to define the job of the Thread inside run() method. <br> 
That is start() method acts as best assistant to the programmer.

<pre>
Example:
start()
{
	1. Register Thread with Thread Scheduler
	2. All other mandatory low level activities.
	3. Invoke or calling run() method.
}
</pre>
We can conclude that without executing Thread class start() method there is no chance of starting a new Thread in java. Due to this start() is  considered as<strong> heart of multithreading</strong>.

<h3><font color="#008080"><u><em>Case 4:  If we are not overriding run() method:</em></u></font></h3>
If we are not overriding run() method then Thread class run() method will be executed which has empty implementation and hence we won't get any output.
<pre>
Example:
class MyThread extends Thread 
{}
class ThreadDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
	}
}
</pre>
It is highly recommended to override run() method. Otherwise don't go for multithreading concept.

<h3><font color="#0080c0"><u><em>Case 5: Overloding of run() method.</em></u></font></h3>
We can overload run() method but Thread class start() method always  invokes no argument run() method the other overload run() methods we have to call explicitly then only it will be executed just like normal method.

<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		System.out.println("no arg method");
	}
	public void run(int i)
	{
		System.out.println("int arg method");
	}
}
class ThreadDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
	}
}
Output:
No arg method
</pre>

<h3><font color="#0080ff"><u><em>Case 6:  overriding of start() method:</em></u></font></h3>
If we override start() method then our start() method will be executed just like a normal method call and no new Thread will be started.
<pre>
Example:
class MyThread extends Thread
{
	public void start()
	{
		System.out.println("start method");
	}
	public void run()
	{
		System.out.println("run method");
	}
}
class ThreadDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		System.out.println("main method");
	}
}
Output:
start method
main method
</pre>
Entire output produced by only main Thread.

<br>
Note : It  is never recommended to override start() method. 

<h3><font color="#8000ff"><u><em>Case 7:</em></u></font></h3> 
<u><em>Example 1:</em></u><br><br><img alt="" src="multiThread/image008.png" width="1028" height="454"><br><br> 
  
<u><em>Example 2:</em></u><br><br><img alt="" src="multiThread/image010.png" width="1019" height="402"><br><br> 
  
<em><u>Output:</u></em><br><br><img alt="" src="multiThread/image012.png" width="431" height="251"><br><br>
 
 
<h3><u><em><font color="#8080ff">Case 8: life cycle of the Thread:</font></em></u></h3> 
<em><u>Diagram:</u></em><br><br><img alt="" src="multiThread/image014.png" width="949" height="161"><br><br>
 
<ul>
<li>Once we created a Thread object then the Thread is said to be in new state or born state.</li>
<li>Once we call start() method then the Thread will be entered into Ready or Runnable state.</li>
<li>If Thread Scheduler allocates CPU then the Thread will be entered into running state.</li>
<li>Once run() method completes then  the Thread will entered into dead state.</li>
</ul>

<h3><font color="#0080ff"><u><em>Case 9:</em></u></font></h3>
 After starting a Thread we are not allowed to restart the same Thread once again otherwise we will get runtime exception saying "IllegalThreadStateException".
 
 <pre>
Example:
MyThread t=new MyThread();
t.start();//valid
;;;;;;;;
t.start();//we will get R.E saying: IllegalThreadStateException
</pre>

<h2 id="implement"><u>Defining a Thread by implementing Runnable interface:</u></h2>
We can define a Thread even by implementing Runnable interface also.<br>
 Runnable interface present in java.lang.pkg and contains only one method run().
 
 <br> 
<em><u>Diagram:</u></em><br><br><img alt="" src="multiThread/image016.png"><br><br> 
  
 
<u><em>Example:</em></u><br><br><img alt="" src="multiThread/image018.png"><br><br>
 <pre>
class ThreadDemo
{
	public static void main(String[] args)
	{
		MyRunnable r=new MyRunnable();
		Thread t=new Thread(r);//here r is a Target Runnable
		t.start();
	
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("main thread");
		}
	}
}
Output:
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
child Thread
child Thread
child Thread
child Thread
child Thread
child Thread
child Thread
child Thread
child Thread
child Thread
</pre>

 We can't expect exact output but there are several possible outputs.
 
<h2><u><font color="#0000ff">Case study:</font></u></h2>
<pre>
MyRunnable r=new MyRunnable();
Thread t1=new Thread();
Thread t2=new Thread(r);
</pre>

<h3><font color="#8080ff"><u><em>Case 1:     t1.start():</em></u></font></h3>
A new Thread will be created which is responsible for the execution of Thread class run()method.
<pre>
Output:
main thread
main thread
main thread
main thread
main thread
</pre>
<h3><font color="#8080c0"><u><em>Case 2:  t1.run():</em></u></font></h3>
No new Thread will be created but Thread class run()  method will be executed just like a normal method call.
<pre>
Output:
main thread
main thread
main thread
main thread
main thread
</pre>

<h3><font color="#0080c0"><u><em>Case 3:  t2.start():</em></u></font></h3>
New Thread will be created which is responsible for the execution of MyRunnable run() method.
<pre>
Output:
main thread
main thread
main thread
main thread
main thread
child Thread
child Thread
child Thread
child Thread
child Thread
</pre>

<h3><font color="#008080"><u><em>Case 4:    t2.run():</em></u></font></h3>
No new Thread will be created and MyRunnable run()  method will be executed just like a normal method call.
<pre>
Output:
child Thread
child Thread
child Thread
child Thread
child Thread
main thread
main thread
main thread
main thread
main thread
</pre>

<h3><font color="#8080ff"><u><em>Case 5:     r.start():</em></u></font></h3>
We will get compile time error saying start()method is not available in MyRunnable class. 
<pre>
Output:
Compile time error
E:\SCJP&gt;javac ThreadDemo.java
ThreadDemo.java:18: cannot find symbol
Symbol: method start()
Location: class MyRunnable
</pre>

<h3><font color="#8000ff"><u><em>Case 6:    r.run():</em></u></font></h3>
No new Thread will be created and MyRunnable class run() method will be executed just like a normal method call.
<pre>
Output:
child Thread
child Thread
child Thread
child Thread
child Thread
main thread
main thread
main thread
main thread
main thread
</pre>
<br>



<p>

In which of the above cases a new Thread will be created which is responsible  for the execution of MyRunnable run() method ?
<br><strong>t2.start();</strong>

</p>

<p>
In which of the above cases a new Thread  will be created ?


<br><strong>t1.start(); <br>	t2.start();</strong>
</p>

<p>

In which of the above cases  MyRunnable class run() will be executed ?

<br><strong>t2.start();	<br> t2.run();  <br>r.run();		</strong>


</p>











<h3><em><u>Best approach to define a Thread:</u></em></h3>
<ul>
<li>Among the 2 ways of defining a Thread, implements Runnable approach is always recommended.</li>
<li>In the 1st approach our class should always extends Thread class there is no chance of extending any other class hence we are missing the benefits of inheritance.</li>
<li> But in the 2nd approach while implementing Runnable interface we can extend some other class also. Hence implements Runnable mechanism is recommended to define a Thread.</li></ul>


<h2 id="constructor" style="background-color: rgb(128, 128, 192);"><font color="#ffff00">Thread class constructors:</font></h2>
<ol>
<li>Thread t=new Thread();</li>
<li>Thread t=new Thread(Runnable r);</li>
<li>Thread t=new Thread(String name);</li>
<li>Thread t=new Thread(Runnable r,String name);</li>
<li>Thread t=new Thread(ThreadGroup g,String name);</li>
<li>Thread t=new Thread(ThreadGroup g,Runnable r);</li>
<li>Thread t=new Thread(ThreadGroup g,Runnable r,String name);</li>
<li>Thread t=new Thread(ThreadGroup g,Runnable r,String name,long stackSize);</li></ol> 
<strong><em><u>Ashok's approach to define a Thread(not recommended to use): 
</u></em></strong><br><br><img alt="" src="multiThread/image021.png" width="1012" height="330"><br><br> 
  
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image023.png"><br><br>
 
<pre>
Output:
main method
run method
</pre>

<h2 id="nameThread" style="background-color: rgb(0, 128, 128);"><font color="#ffff00">Getting and setting name of a Thread:</font></h2>
<ul><li>Every Thread in java has some name it may be provided explicitly by the programmer or automatically generated by JVM.</li>
<li> Thread class defines the following methods to get and set name of a Thread.</li></ul> 
 
<u><em>Methods: 
</em></u><ol><li>public final String getName()</li>
<li>public final void setName(String name)</li></ol>

<pre>
Example:
class MyThread extends Thread
{}
class ThreadDemo
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName());//main
		MyThread t=new MyThread();
		System.out.println(t.getName());//Thread-0
		Thread.currentThread().setName("Bhaskar Thread");
		System.out.println(Thread.currentThread().getName());//Bhaskar Thread
	}
}
</pre>
Note: We can get current executing Thread object reference by using Thread.currentThread() method.


<h2 id="priority" style="background-color: rgb(0, 128, 192);"><font color="#ffff00">Thread Priorities</font></h2>
<ul><li>Every Thread in java has some priority it may be default priority generated by JVM (or) explicitly provided by the programmer.</li>
<li>The valid range of Thread priorities is 1 to 10[but not 0 to 10] where 1 is the least priority and 10 is highest priority.</li>
<li>Thread class defines the following constants to represent some standard priorities.
    <ol><li>Thread. MIN_PRIORITY----------1</li>
    <li>Thread. MAX_PRIORITY----------10</li>
    <li>Thread. NORM_PRIORITY--------5</li></ol></li>
<li>There are no constants like Thread.LOW_PRIORITY, Thread.HIGH_PRIORITY</li>
<li>Thread scheduler uses these priorities while allocating CPU.</li>
<li>The Thread which is having highest priority will get chance for 1st execution.</li>
<li>If 2 Threads having the same priority then we can't expect exact execution order it depends on Thread scheduler whose behavior is vendor dependent.</li>
<li>We can get and set the priority of a Thread by using the following methods.
     <ol><li>public final int getPriority()</li>
     <li>public final void setPriority(int newPriority);//the allowed values are 1 to 10</li></ol></li>

<li>The allowed values are 1 to 10 otherwise we will get runtime exception saying "IllegalArgumentException".</li>
</ul>

<h2><font color="#800080"><u><em>Default priority:</em></u></font></h2>
The default priority only for the main Thread is 5. But for all the remaining Threads the default priority will be inheriting from parent to child. That is whatever the priority parent has by default the same priority will be for the child also.
<pre>
Example 1:
class MyThread extends Thread
{}
class ThreadPriorityDemo
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority());//5
		Thread.currentThread().setPriority(9);
		MyThread t=new MyThread();
		System.out.println(t.getPriority());//9
	}
}
</pre>

<pre>
Example 2:
class MyThread extends Thread
{
	public void run()
	{
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("child thread");
		}
	}
}
class ThreadPriorityDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		//t.setPriority(10);	    //----&gt; 1
		t.start();
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("main thread");
		}
	}
}
</pre>
<ul>
<li>If we are commenting line 1 then both main and child Threads will have the same priority and hence we can't expect exact execution order.</li>
<li>If we are not commenting line 1 then child Thread has the priority 10 and main Thread has the priority 5 hence child Thread will get chance for execution and after completing child Thread main Thread will get the chance in this the output is:</li></ul>

<pre>
Output:
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
</pre>
	Some operating systems(like windowsXP) may not provide proper support for Thread priorities. We have to install separate bats provided by vendor to provide support for priorities.
	
<h2  id="execution" style="background-color: rgb(0, 128, 0);"><font color="#ffff00">The Methods to Prevent a Thread from Execution:</font></h2>
We can prevent(stop) a Thread execution by using the following methods.
<ol>
<li>yield();</li><li>join();</li><li>sleep();</li></ol>

<h3  id="yield"><u><em><font color="#808040">yield():</font></em></u></h3>
<ol>
<li>yield() method causes "to pause current executing Thread for giving the chance of remaining waiting Threads of same priority".</li>
<li>If all waiting Threads have the low priority or if there is no waiting Threads then the same Thread will be continued its execution.</li>
<li>If several waiting Threads with same priority available then we can't expect exact which Thread will get chance for execution.</li>
<li>The Thread which is yielded when it get chance once again for execution is depends on mercy of the Thread scheduler.</li>
<li>public static native void yield();</li>
</ol> 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image026.png" width="1050" height="213"><br><br>
 
<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		for(int i=0;i&lt;5;i++)
		{
			Thread.yield();
			System.out.println("child thread");
		}
	}
}
class ThreadYieldDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		for(int i=0;i&lt;5;i++)
		{
			System.out.println("main thread");
		}
	}
}
Output:
main thread
main thread
main thread
main thread
main thread
child thread
child thread
child thread
child thread
child thread
</pre>



	In the above program child Thread always calling yield() method and hence  main Thread will get the chance more number of times for execution.<br> Hence the chance of completing the main Thread first is high.
<br><br>
Note : Some operating systems may not provide proper support for yield()  method.

<br>



	
<h3 id="join"><u><em><font color="#804040">Join():</font></em></u></h3>
If a Thread wants to wait until completing some other Thread then we should go for join() method.

<br>
<strong>Example:</strong>
	If a Thread t1 executes t2.join() then t1 should go for waiting state until completing t2.
<br>
<br>
Diagram:<br><br><img alt="" src="multiThread/image028.png" width="894" height="345"><br><br>
 
 
<ol>
<li>public final void join()throws InterruptedException</li>
<li>public final void join(long ms) throws InterruptedException</li>
<li>public final void join(long ms,int ns) throws InterruptedException</li>
</ol> 
 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image030.png" width="1016" height="447"><br><br>


 
 Every join() method throws InterruptedException, which is checked exception hence compulsory we should handle either by<b> try catch</b> or by<b> throws</b> keyword.<br> Otherwise we will get compiletime error.

<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		for(int i=0;i&lt;5;i++)
		{
			System.out.println("Sita Thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException e){}
		}
	}
}
class ThreadJoinDemo
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t=new MyThread();
		t.start();
		//t.join();	//---&gt;1
		for(int i=0;i&lt;5;i++)
		{
			System.out.println("Rama Thread");
		}
	}
}
</pre>
<ul>
<li>If we are commenting line 1 then both Threads will be executed simultaneously and we can't expect exact execution order.</li>
<li>If we are not commenting line 1 then main Thread will wait until completing child Thread in this the output is sita Thread 5 times followed by Rama Thread 5 times.</li>
</ul>





<h2>Waiting of child Thread untill completing main Thread :</h2>

<pre>
Example:
class MyThread extends Thread
{
 static Thread mt;
	public void run()
	{
        	try
        	{
			mt.join(); 
		}
		catch (InterruptedException e){}
	

		for(int i=0;i&lt;5;i++)
		{
			System.out.println("Child Thread");
		}
	}
}
class ThreadJoinDemo
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread mt=Thread.currentThread();
		MyThread t=new MyThread();
		t.start();

		for(int i=0;i&lt;5;i++)
		{
			Thread.sleep(2000);
			System.out.println("Main Thread");
		}
	}
}

Output :

Main Thread
Main Thread
Main Thread
Main Thread
Main Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread

</pre>

Note :<br> If main thread calls  join() on child thread object and child thread called join() on main thread object then both threads will wait for each other forever and the program will be hanged(like deadlock  if a Thread class join() method on the same thread itself then the program  will be hanged ).

<pre>
Example :

class ThreadDemo {
public static void main() throws InterruptedException {
Thread.currentThread().join();
      ---------------   --------
        main              main
}

}

</pre>






<h2  id="sleep"><font color="#8080ff"><u><em>Sleep() method:</em></u></font></h2>
If a Thread don't want to perform any operation for a particular amount of time then we should go for sleep() method.
<ol>
<li><strong>public static native void sleep(long ms) throws InterruptedException</strong></li>
<li><strong>public static void sleep(long ms,int ns)throws InterruptedException</strong></li>
</ol> 
 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image033.png" width="1014" height="436"><br><br>
 
<pre> 
Example:
class ThreadJoinDemo
{
	public static void main(String[] args)throws InterruptedException
	{
		System.out.println("M");
		Thread.sleep(3000);
		System.out.println("E");
		Thread.sleep(3000);
		System.out.println("G");
		Thread.sleep(3000);
		System.out.println("A");
	}
}
Output:
M
E
G
A
</pre>

<h2><font color="#800080"><u><em>Interrupting a Thread:</em></u></font></h2>


<br><b>How a Thread can interrupt  another thread ?</b>
<br>
If a Thread can interrupt a sleeping or waiting Thread by using interrupt()(break off) method of Thread class.

<br><b>public void interrupt();</b>


<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		try
		{
			for(int i=0;i&lt;5;i++)
			{
				System.out.println("i am lazy Thread :"+i);
				Thread.sleep(2000);
			}
		}
		catch (InterruptedException e)
		{
			System.out.println("i got interrupted");
		}
	}
}
class ThreadInterruptDemo
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		//t.interrupt();	//---&gt;1
		System.out.println("end of main thread");
	}
}
</pre>

<ul>
<li>If we are commenting line 1 then main Thread won't interrupt child Thread and hence child Thread will be continued until its completion.</li>
<li>If we are not commenting line 1 then main Thread interrupts child Thread and hence child Thread won't continued until its completion in this case the output is:</li></ul>
<pre>
End of main thread
I am lazy Thread: 0
I got interrupted
</pre> 
<u><em>Note: 
</em></u><ul>
<li>Whenever we are calling interrupt() method we may not see the effect immediately, if the target Thread is in sleeping or waiting state it will be interrupted immediately.</li>
<li>If the target Thread is not in sleeping or waiting state then interrupt call will wait until target Thread will enter into sleeping or waiting state. Once target Thread entered into sleeping or waiting state it will effect immediately.</li>
<li>In its lifetime if the target Thread never entered into sleeping or waiting state then there is no impact of interrupt call simply interrupt call will be wasted.</li>
</ul>

<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		for(int i=0;i&lt;5;i++)
		{
			System.out.println("iam lazy thread");
		}
                System.out.println("I'm entered into sleeping stage");
		try
		{
			Thread.sleep(3000);
		}
		catch (InterruptedException e)
		{
			System.out.println("i got interrupted");
		}
	}
}
class ThreadInterruptDemo1
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		t.interrupt();
		System.out.println("end of main thread");
	}
}
</pre>

<ul>
<li>In the above program interrupt() method call invoked by main Thread will wait until child Thread entered into sleeping state.</li>
<li>Once child Thread entered into sleeping state then it will be interrupted immediately.</li>
</ul>


<h3><u><font color="#008080">Compression of yield, join and sleep() method?</font></u></h3>
<table border="1" >
<tr><th>property</th><th>Yield()</th><th>Join()</th><th>Sleep()</th></tr>
<tr><td>1)	Purpose?</td><td>To pause current executing Thread for giving the chance of remaining waiting Threads of same priority.</td><td>	If a Thread wants to wait until completing some other Thread then we should go for join.
	</td><td>If a Thread don't want to perform any operation for a particular amount of time then we should go for sleep() method.</td></tr>
<tr><td>2)	Is it static?</td><td>	yes</td><td>	no</td><td>	yes</td></tr>
<tr><td>3)	Is it final?</td><td>	no</td><td>	yes</td><td>	no</td></tr>
<tr><td>4)	Is it overloaded?</td><td>	No</td><td>	yes</td><td>	yes</td></tr>
<tr><td>5)	Is it throws
	InterruptedException?</td><td>	no</td><td>	yes</td><td>	yes</td></tr>
<tr><td>6)	Is it native method?</td><td>	yes	</td><td>no	</td><td>sleep(long ms) --&gt;native <br>sleep(long ms,int ns) --&gt;non-native</td></tr>
</table>


<h2 id="syncronization" style="background-color: rgb(0, 0, 160);"><font color="#ffff00">Synchronization</font></h2>
<ol>
<li>Synchronized is the keyword applicable for methods and blocks but not for classes and variables.</li>
<li>If a method or block declared as the synchronized then at a time only one Thread is allow to execute that method or block on the given object.</li>
<li>The main advantage of synchronized keyword is we can resolve date inconsistency problems.</li>
<li>But the main disadvantage of synchronized keyword is it increases waiting time of the Thread and effects performance of the system.</li>
<li>Hence if there is no specific requirement then never recommended to use synchronized keyword.</li>
<li>Internally synchronization concept is implemented by using lock concept.</li>
<li>Every object in java has a unique lock. Whenever we are using synchronized keyword then only lock concept will come into the picture.</li>
<li>If a Thread wants to execute any synchronized method on the given object 1st it has to get the lock of that object. Once a Thread got the lock of that object then it's allow to execute any synchronized method on that object. If the synchronized method execution completes then automatically Thread releases lock.</li>
<li>While a Thread executing any synchronized method the remaining Threads are not allowed execute any synchronized method on that object simultaneously. But remaining Threads are allowed to execute any non-synchronized method simultaneously. [lock concept is implemented based on object but not based on method].</li>
</ol>

<pre>
Example:
class Display
{
	public synchronized void wish(String name)
	{
		for(int i=0;i&lt;5;i++)
		{
			System.out.print("good morning:");
			try
			{
				Thread.sleep(1000);	
			}
			catch (InterruptedException e)
			{}
			System.out.println(name);
		}
	}
}
class MyThread extends Thread
{
	Display d;
	String name;
	MyThread(Display d,String name)
	{
		this.d=d;
		this.name=name;
	}
	public void run()
	{
		d.wish(name);
	}
}
class SynchronizedDemo
{
	public static void main(String[] args)
	{
		Display d1=new Display();
		MyThread t1=new MyThread(d1,"dhoni");
		MyThread t2=new MyThread(d1,"yuvaraj");
		t1.start();
		t2.start();
	}
}
</pre>


If we are not declaring wish() method as synchronized then both Threads will be executed simultaneously and we will get irregular output.

<pre>
Output:
good morning:good morning:yuvaraj
good morning:dhoni
good morning:yuvaraj
good morning:dhoni
good morning:yuvaraj
good morning:dhoni
good morning:yuvaraj
good morning:dhoni
good morning:yuvaraj
dhoni
</pre>

If we declare wish()method as synchronized then the Threads will be executed one by one  that is until completing the 1st Thread the 2nd Thread will wait in this case we will get regular output which is nothing but

<pre>
Output:
good morning:dhoni
good morning:dhoni
good morning:dhoni
good morning:dhoni
good morning:dhoni
good morning:yuvaraj
good morning:yuvaraj
good morning:yuvaraj
good morning:yuvaraj
good morning:yuvaraj
</pre>


<h2><u><font color="#0000ff">Case study:</font></u></h2>

<h3><font color="#008040"><u><em>Case 1:</em></u></font></h3>
<pre>
Display d1=new Display();
Display d2=new Display();
MyThread t1=new MyThread(d1,"dhoni");
MyThread t2=new MyThread(d2,"yuvaraj");
t1.start();
t2.start();
</pre> 
 
 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image036.png"><br><br>
 
	Even though we declared wish() method as synchronized but we will get irregular output in this case, because both Threads are operating on different objects.

<p><b>Conclusion :</b> If  multiple threads are operating  on multiple objects then there is no impact of Syncronization.<br> If multiple threads are operating on same java objects then syncronized concept is required(applicable). 
</p>
<h3><em><u><font color="#0080c0">Class level lock:</font></u></em></h3>
<ol>
<li>Every class in java has a unique lock. If a Thread wants to execute a static synchronized method then it required class level lock.</li>
<li>Once a Thread got class level lock then it is allow to execute any static synchronized method of that class.</li>
<li>While a Thread executing any static synchronized method the remaining Threads are not allow to execute any static synchronized method of that class simultaneously.</li>
<li>But remaining Threads are allowed to execute<b> normal synchronized methods, normal static methods, and normal instance methods</b> simultaneously.</li>
<li>Class level lock and object lock both are different and there is no relationship between these two.</li></ol>


<h3><font color="#800000"><u><em>Synchronized block:</em></u></font></h3>
<ol>
<li>If very few lines of the code required synchronization then it's never recommended to declare entire method as synchronized we have to enclose those few lines of the code with in synchronized block.</li>
<li>The main advantage of synchronized block over synchronized method is it reduces waiting time of Thread and improves performance of the system.</li></ol>

<p> 
<strong><u><em>Example 1:</em></u></strong> To get lock of current object we can declare synchronized block as follows.<br> If Thread got lock of current object then only it is allowed to execute this block.<br>
<font color="#0080ff"><strong>Synchronized(this){}  </strong></font></p>

<p> 
<strong><u><em>Example 2:</em></u></strong> To get the lock of a particular object 'b' we have to declare a synchronized block as follows.<br> If thread got lock of 'b' object then only it is allowed to execute this block.<br>
<font color="#800000"><strong>Synchronized(b){}	</strong></font></p>

<p> 
<u><em><strong>Example 3:</strong></em></u> To get class level lock we have to declare synchronized block as follows.<br> 
<font color="#008000"><strong>Synchronized(Display.class){}  </strong></font>
<br>If thread got class level lock of Display then only it allowed to execute this block.
</p>
<p><b>Note:</b>As the argument to the synchronized block we can pass either object reference or ".class file" and we can't pass primitive values as argument [because lock concept is dependent only for objects and classes but not for primitives].</p>

<pre>
Example:
Int x=b;
Synchronized(x){}
Output:
Compile time error.
Unexpected type.
Found: int
Required: reference
</pre>


<h3><u><font color="#0000ff">Questions:</font></u></h3>
<ol>
<li>Explain about synchronized keyword and its advantages and disadvantages?</li>
<li>What is object lock and when a Thread required?</li>
<li>What is class level lock and when a Thread required?</li>
<li>What is the difference between object lock and class level lock?</li>
<li>While a Thread executing a synchronized method on the given object is the remaining Threads are allowed to execute other synchronized methods simultaneously on the same object? <br>
Ans: No. </li>
<li>What is synchronized block and explain its declaration?</li>
<li>What is the advantage of synchronized block over synchronized method?</li>
<li>Is a Thread can hold more than one lock at a time? <br>
Ans: Yes, up course from different objects.


Example:<br><br><img alt="" src="multiThread/image038.png" width="840" height="274"><br><br> 
  
<em><u>Diagram:</u></em><br><br><img alt="" src="multiThread/image040.png" width="311" height="222"><br><br>
 </li>
 <li>What is synchronized statement?  <br>
Ans: The statements which present inside synchronized method and synchronized block are called synchronized statements. [Interview people created terminology].</li>
</ol>



<h3 id="threadCommunication" style="background-color: rgb(128, 0, 0);"><font color="#ffff00">Inter Thread communication (wait(),notify(), notifyAll()):</font></h3>
<ul>
<li>Two Threads can communicate with each other by using wait(), notify() and notifyAll() methods.</li>
<li>The Thread which is required updation it has to call wait() method on the required object then immediately the Thread  will entered into waiting state.<br>The Thread which is performing updation of object, it is responsible to give notification by calling notify() method.<br> After getting notification the waiting Thread will get those updations.<br>
<br>Diagram:<br><br><img alt="" src="multiThread/image042.png" width="997" height="850"><br><br>
</li>
<li>wait(), notify() and notifyAll() methods are available in Object class but not in Thread class because Thread can call these methods on any common object.</li>
<li>To call wait(), notify() and notifyAll() methods compulsory the current Thread should be owner of that object <br> i.e., current Thread should has lock of that object<br>i.e., current Thread should be in synchronized area. Hence we can call wait(), notify() and notifyAll() methods only from synchronized area otherwise we will get runtime exception saying<b> IllegalMonitorStateException</b>.</li>
<li>Once a Thread calls wait() method on the given object 1st  it releases the lock of that object immediately and entered into waiting state.</li>
<li>Once a Thread calls notify() (or) notifyAll() methods it releases the lock of that object but may not immediately.</li>
<li>Except these (wait(),notify(),notifyAll()) methods there is no other place(method) where the lock release will be happen.
	<table border="1"  >
	 <tr><th>Method </th><th>	Is Thread Releases Lock?</th></tr>
	 <tr><td>yield()</td><td>	No</td></tr>
	 <tr><td>join()</td><td>	No</td>
	 <tr><td>sleep()</td><td>	No</td></tr>
	 <tr><td>wait()</td><td>	Yes</td></tr>
	 <tr><td>notify()</td><td>	Yes</td></tr>
	 <tr><td>   notifyAll()</td><td>	Yes</td></tr>
	</table>

</li>
<li>Once a Thread calls wait(), notify(), notifyAll() methods on any object then it releases the lock of that particular object but not all locks it has.
  <ol>
   <li>	public final void wait()throws InterruptedException</li>
   <li>	public final native void wait(long ms)throws InterruptedException</li>
   <li>	public final void wait(long ms,int ns)throws InterruptedException</li>
   <li>	public final native void notify()</li>
   <li>	public final void notifyAll()</li>
  </ol> 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image044.png" width="1009" height="483"><br><br>

</li>
</ul>



<pre> 
Example 1:
class ThreadA
{
	public static void main(String[] args)throws InterruptedException
	{
	ThreadB b=new ThreadB();
	b.start();
	synchronized(b)
	{
	System.out.println("main Thread calling wait() method");//step-1
	b.wait();
	System.out.println("main Thread got notification call");//step-4
	System.out.println(b.total);
	}
	}
}
class ThreadB extends Thread
{
	int total=0;
	public void run()
	{
	synchronized(this)
	{
	System.out.println("child thread starts calcuation");//step-2
		for(int i=0;i&lt;=100;i++)
		{
			total=total+i;
		}
	System.out.println("child thread giving notification call");//step-3
	this.notify();
	}
	}
}
Output:
main Thread calling wait() method
child thread starts calculation
child thread giving notification call
main Thread got notification call
5050
</pre>


Example 2:
<h3><font color="#0080c0"><u><em>Producer consumer problem:</em></u></font></h3>
<ul><li>Producer(producer Thread) will produce the items to the queue and consumer(consumer thread) will consume the items from the queue. If the queue is empty then consumer has to call wait() method on the queue object then it will entered into waiting state.</li>
<li>After producing the items producer Thread call notify() method on the queue to give notification so that consumer Thread will get that notification and consume items.</li>
</ul> 
<u><em>Diagram:</em></u><br><br><img alt="" src="multiThread/image046.png"><br><br> 
  
<u>Example:</u><br><br><img alt="" src="multiThread/image048.png"><br><br>


<h3><u><font color="#0000ff">Notify vs notifyAll():</font></u></h3>
<ul><li>We can use notify() method to give notification for only one Thread. If multiple Threads are waiting then only one Thread will get the chance and remaining Threads has to wait for further notification. But which Thread will be notify(inform) we can't expect exactly it depends on JVM.</li>
<li>We can use notifyAll() method to give the notification for all waiting Threads. All waiting Threads will be notified and will be executed one by one,  because they are required lock</li>
</ul>

<b>Note:</b> On which object we are calling wait(), notify() and notifyAll() methods that corresponding object lock we have to get but not other object locks.
<br> 
<u>Example:</u><br><br><img alt="" src="multiThread/image050.png"><br><br>
 
<h3><u> Which of the folowing  statements are True ?</u></h3>

<ol>
<li>Once a Thread calls wait() on any Object  immediately it will entered into waiting  state  without releasing the lock ? <br><b> NO</b></li>
<li>Once a  Thread calls wait() on any Object  it reduces the  lock of that Object but may not  immediately ?  <br><b>NO</b> </li>
<li>Once a Thread calls wait() on any Object  it immediately releases all locks whatever it has and  entered into waiting state ? <br><b>NO</b></li>
<li>Once a Thread calls wait() on any Object  it immediately releases the lock of that perticular Object and entered into waiting state ? <br><b>YES</b></li>
<li>Once a Thread calls notify() on any Object  it immediately releases the lock of that Object ?<br><b>NO</b> </li>
<li>Once a Thread calls notify() on any Object  it  releases the lock of that Object but may not immediately ?<br><b>YES</b> </li>
</ol>



<h2 id="deadLock" style="background-color: rgb(0, 0, 64);"><font color="#ffff80">Dead lock:</font></h2>
<ul>
<li>If 2 Threads are waiting for each other forever(without end) such type of situation(infinite waiting) is called dead lock.</li>
<li>There are no resolution techniques for dead lock but several prevention(avoidance) techniques are possible.</li>
<li>Synchronized keyword is the cause for deadlock hence whenever we are using synchronized keyword we have to take special care.</li>
</ul>


<pre>
Example:
class A
{
	public synchronized void foo(B b)
	{
		System.out.println("Thread1 starts execution of foo() method");
		try
		{
			Thread.sleep(2000);
		}
		catch (InterruptedException e)
		{}
		System.out.println("Thread1 trying to call b.last()");
		b.last();
	}
	public synchronized void last()
	{
		System.out.println("inside A, this is last()method");
	}
}
class B
{
	public synchronized void bar(A a)
	{
	System.out.println("Thread2 starts execution of bar() method");
	try
	{
		Thread.sleep(2000);
	}
	catch (InterruptedException e)
	{}
	System.out.println("Thread2 trying to call a.last()");
	a.last();
	}
	public synchronized void last()
	{
	System.out.println("inside B, this is last() method");
	}
}
class DeadLock implements Runnable
{
	A a=new A();
	B b=new B();
	DeadLock()
	{
		Thread t=new Thread(this);
		t.start();
		a.foo(b);//main thread
	}
	public void run()
	{
		b.bar(a);//child thread
	}
	public static void main(String[] args)
	{
		new DeadLock();//main thread
	}
}
Output:
Thread1 starts execution of foo() method
Thread2 starts execution of bar() method
Thread2 trying to call a.last()
Thread1 trying to call b.last()
//here cursor always waiting.
</pre>

<br>
<b>Note : </b>
If we remove atleast one syncronized keywoed then we won't get DeadLOck.Hence syncronized keyword in the only reason  for DeadLock due to this while using  syncronized keyword  we have to  handling carefully.


<br><br>




<h3 id="daemon" style="background-color: rgb(0, 0, 255);"><font color="#ffff00">Daemon Threads:</font></h3>
<p>	The Threads which are executing in the background are called daemon Threads.<br> The main objective of daemon Threads is to provide support for non-daemon Threads like main Thread.</p> 
 
<u><strong>Example: 
</strong></u><br><font color="#0080c0"><u><em>Garbage collector</em></u></font>

<p> When ever the program runs with low memory the JVM will  execute Garbage Collector to provide free memory. So that the main Thread can continue it's execution.  </P>

<ul>
<li>We can check whether the Thread is daemon or not by using isDaemon() method of Thread class.  <br> 
<strong>public final boolean isDaemon(); </strong></li>
<li>We can change daemon nature of a Thread by using setDaemon () method. <br> 
<strong>public final void setDaemon(boolean b); </strong></li>
<li>But we can change daemon nature before starting Thread only. That is after starting the Thread if we are trying to change the daemon nature we will get R.E saying <strong><em>IllegalThreadStateException</em></strong>.</li>
<li><b>Default Nature : </b>Main Thread is always non daemon and we can't change its daemon nature because it's already started at the beginning only.</li>
<li>Main Thread is always non daemon and for the remaining Threads daemon nature will be inheriting from parent to child that is if the parent is daemon child is also daemon and if the parent is non daemon then child is also non daemon.</li>
<li>Whenever the last non daemon Thread terminates automatically all daemon Threads will be terminated.</li>
</ul>



<pre>
Example:
class MyThread extends Thread
{

}

class DaemonThreadDemo
{
	public static void main(String[] args)
	{
	System.out.println(Thread.currentThread().isDaemon());
	MyThread t=new MyThread();
	System.out.println(t.isDaemon());	           1
	t.start();
	t.setDaemon(true);
	System.out.println(t.isDaemon());
	}
}
Output:
false
false
RE:IllegalThreadStateException
</pre>




<pre>
Example:
class MyThread extends Thread
{
	public void run()
	{
		for(int i=0;i&lt;10;i++)
		{
			System.out.println("lazy thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException e)
			{}
		}
	}
}
class DaemonThreadDemo
{
	public static void main(String[] args)
	{
	MyThread t=new MyThread();
	t.setDaemon(true);	//--&gt;1
	t.start();
	System.out.println("end of main Thread");
	}
}
Output:
End of main Thread
</pre>


<ul>
<li>If we comment line 1 then both main &amp; child Threads are non-Daemon , and hence both  threads  will be executed  untill there completion.</li>
<li>If we are not comment line 1  then main thread is  non-Daemon and child thread is Daemon. Hence when ever main Thread terminates automatically  child thread will be terminated.</li>
</ul>






<h3><font color="#008080"><u><em>Lazy thread</em></u></font></h3>

<ul><li>If we are commenting line 1 then both main and child Threads are non daemon and hence both will be executed until they completion.</li>
<li>If we are not commenting line 1 then main Thread is non daemon and child Thread is daemon and hence whenever main Thread terminates automatically child Thread will be terminated.</li>
</ul>


<h2><font color="#ff8000"><u><em>Deadlock vs Starvation:</em></u></font></h2>
<ul>
<li>A long waiting of a Thread which never ends is called deadlock.</li>
<li>A long waiting of a Thread which ends at certain point is called starvation.</li>
<li>A low priority Thread has to wait until completing all high priority Threads.</li>
<li>This long waiting of Thread which ends at certain point is called starvation.</li>
</ul>

<h3 id="stop"><font color="#ff0000"><u>How to kill a Thread in the middle of the line?</u></font></h3>
<ul>
<li>We can call stop() method to stop a Thread in the middle then it will be entered into dead state immediately.<br> 
<strong>public final void stop(); </strong></li>
<li>stop() method has been deprecated and hence not recommended to use.</li>
</ul>

<h3 id="suspend" ><font color="#008000"><em><u>suspend and resume methods:</u></em></font></h3>
<ul>
 <li>A Thread can suspend another Thread by using suspend() method then that Thread will be paused temporarily.</li>
 <li>A Thread can resume a suspended Thread by using resume() method then suspended Thread will continue its execution.
 	<ol>
 	<li><strong>public final void suspend();</strong></li>
 	<li><strong>public final void resume();</strong></li>
 </ol>
 </li>
 <li>Both methods are deprecated and not recommended to use.</li>
 </ul>

<h3><font color="#0080ff"><u>RACE condition:</u></font></h3>
	Executing multiple Threads simultaneously and causing data inconsistency problems is nothing but<b> Race condition</b><br> we can resolve race condition by using synchronized keyword.


<h3 id="group" ><font color="#008000"><em><u>ThreadGroup:</u></em></font></h3>

Based on functionality we can group threads as a single unit which is nothing but ThreadGroup.<br>
<br>ThreadGroup provides a convenient  way to perform  common operations  for all threads  belongs to a perticular  group.


<p>
We can create a ThreadGroup by using the following constructors
<br>
<b>ThreadGroup g=new ThreadGroup(String gName);</b>
</p><p>
We  can attach a Thread to the ThreadGroup by using the following constructor  of Thread class<br>

<b>Thread t=new Thread(ThreadGroup g, String name);</b>
</p>

<pre>
ThreadGroup g=new ThreadGroup("Printing Threads");
MyThread t1=new MyThread(g,"Header Printing");
MyThread t2=new MyThread(g,"Footer Printing");
MyThread t3=new MyThread(g,"Body Printing");
-----------
g.stop();
</pre>

<h3 id="local" ><font color="#008000"><em><u>ThreadLocal(1.2 v):</u></em></font></h3>
We can use ThreadLocal to define local resources  which are required for a perticular Thread like DBConnections, counterVariables etc.,
<br><br>



We can use ThreadLocal  to define Thread scope like Servlet Scopes(page,request,session,application).


<h3 id="green" ><font color="#008000"><em><u>GreenThread:</u></em></font></h3>
Java multiThreading concept is implementing by using the following 2 methods :
<ol><li>GreenThread Model</li><li>Native OS Model</li></ol>
<h3>GreenThread Model</h3>
The threads which are managed completely by JVM without taking support for  underlying OS,  such type of  threads are called Green Threads. 


<h3>Native OS Model</h3>
<ul><li>
The Threads which are managed  with the help of underlying  OS are called Native Threads.
</li><li>
Windows based OS provide support for Native OS Model
</li><li>
Very few OS like SunSolaries  provide support for GreenThread Model
</li><li>
Anyway  GreenThread model is deprecated and not recommended to use.
</li></ul>





<h2 id="life" style="background-color: rgb(0, 0, 160);"><font color="#ffff00">Life cycle of a Thread:</font></h2>
 <br><br><img alt="" src="multiThread/image052.png" width="990" height="753"><br><br> 
<font color="#ff0000"><strong>What is the difference between extends Thread and implements Runnable? 
</strong></font><ol>
<li>Extends Thread is useful to override the public void run() method of Thread class.</li>
<li>Implements Runnable is useful to implement public void run() method of Runnable interface.</li>
</ol> 
 
<font color="#ff0000"><strong>Extends Thread, implements Runnable which one is advantage? 
</strong></font><br> If we extend Thread class, there is no scope to extend another class.


<p> 
 
<strong><u>Example:    </u></strong><br>
Class MyClass extends Frame,Thread//invalid	<br>
If we write implements Runnable still there is a scope to extend one more class.
</p> 
 
 
 
<u><strong>Example: 
</strong></u><ol>
<li>class MyClass extends Thread implements Runnable</li>
<li>class MyClass extends Frame implements Runnable</li>
</ol>

<h3><font color="#ff0000">How can you stop a Thread which is running?</font></h3>
<p> 
<u><strong>Step 1:</strong></u> 
	Declare a boolean type variable and store false in that variable.<br> 
<font color="#0000ff">boolean stop=false; 
</font></p>

<p> 
<u><strong>Step 2:</strong></u> 
	If the variable becomes true return from the run() method.<br> 
<font color="#8000ff">If(stop) return; 
</font></p>

<p> 
<u><strong>Step 3: </strong></u>
	Whenever to stop the Thread store true into the variable.<br> 
<font color="#0080ff">System.in.read();//press enter <br>
Obj.stop=true; 
 
</font></p>

<h3 style="background-color: rgb(128, 0, 64);"><font color="#ffff00">Questions:</font></h3>
<ol>
<li>What is a Thread?</li>
<li>Which Thread by default runs in every java program?  <br>
  	Ans: By default main Thread runs in every java program.</li>
<li>What is the default priority of the Thread?</li>
<li>How can you change the priority number of the Thread?</li>
<li>Which method is executed by any Thread?  <br>
   Ans: A Thread executes only public void run() method.</li>
<li>How can you stop a Thread which is running?</li>
<li>Explain the two types of multitasking?</li>
<li>What is the difference between a process and a Thread?</li>
<li>What is Thread scheduler?</li>
<li>Explain the synchronization of Threads?</li>
<li>What is the difference between synchronized block and synchronized keyword?</li>
<li>What is Thread deadlock? How can you resolve deadlock situation?</li>
<li>Which methods are used in Thread communication?</li>
<li>What is the difference between notify() and notifyAll() methods?</li>
<li>What is the difference between sleep() and wait() methods?</li>
<li>Explain the life cycle of a Thread?</li>
<li>What is daemon Thread?</li>
</ol>

  
  
  
  
  
  
  </td></tr></table>
  <a href="index-2.html">BACK</a>
  </div>
 
      
 <!-- infolinks  -->   
<script type="text/javascript">
 var infolinks_pid = 1921552;
 var infolinks_wsid = 0;
</script>
<script type="text/javascript" src="../resources.infolinks.com/js/infolinks_main.js"></script>
   

    
  </body>

<!-- Mirrored from java.scjp.jobs4times.com/multiThread.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:20:51 GMT -->
</html>