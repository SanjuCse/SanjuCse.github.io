<!DOCTYPE html>
<html>

<!-- Mirrored from www.java.designpatterns.jobs4times.com/template-method-design-pattern.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:36:40 GMT -->
<head>
<meta charset="ISO-8859-1">
<title>Java design patterns - Template Method Design Pattern</title>
<link style="text/css" rel="stylesheet" href="styles.css">
<link rel="shortcut icon" href="small.html">
</head>


<body>

<div align="center" >
<table border="1" style="width: 887px"><tr><td>
 
<table>
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500" height="200">   </a> </td> 
<td  align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 
</tr>
</table>  

 
 
<h1 style="border-bottom-color: blue; background-color: yellow;font: monospace;color: red;text-align: center;" >Template Method Design Pattern </h1> 
 
 
 <ul>
 <li>Template method design pattern is a behavioral pattern of the Gang Of Four(GOF) design patterns catalog.</li>
 <li>In this pattern we have a base template method; it defines an algorithm with some abstract steps.</li>
 <li>These steps have to be implemented by sub-classes. <br><br> </li>
 </ul>
 
 <ul>
 <li>For example I have a class called DataRenderer this class is responsible to rendering the data to output console.</li>
 <li>But to render the data first we need to read and process it.</li>
 <li>So we have a methods like readData() and processData().</li>
 <li>But these methods will be declared as abstract as there are multiple sources from which you can read the data and multiple ways we can process it.</li>
 <li>But to render the data you need to read and process it, so the algorithm for render() is fixed  which is read and process but how to read, from where to read and how to process is left to the sub-classes to handle.</li>
 </ul>
 
 
<pre>
package design;

public abstract class DataRenderer{
 
 //algorithm is fixed
 public void render(){
	 String data=null;
	 String pData=null;
	 
	 data=readData();
	 pData=processData(data);
	 
	 System.out.println(pData);
 }

 public abstract String readData();
 public abstract String processData(String data);
}
</pre>
 
<pre>
package design;

public class XMLDataRenderer extends DataRenderer {

 @Override
 public String readData() {
  return "xml data";
 }

 @Override
 public String processData(String data) {
  return "processed "+data;
 }

}
</pre>
 
 
<pre>
package design;

public class TextDataRenderer extends DataRenderer {

 @Override
 public String readData() {
  return "text data";
 }

 @Override
 public String processData(String data) {
  return "processed "+data;
 }

}
</pre>
 
<ul>
<li>In the above example the responsibilities of reading and processing has been left to sub-classes.</li>
<li>render() method remains same calling the methods of your sub-classes.</li>
</ul>



Now if a client wants to reader the data, he/she has to create the object of XMLDataRender or TextDataRender  and has to call the render() method which delegates the call to readData() and processData() as per the algorithm to render it.

<pre>
package design;

public class TemplateMethodTest {

public static void main(String[] args){
 DataRenderer renderer=new XMLDataRenderer();
 renderer.render();
}

}
</pre>  

The Template method we declare in the base class cannot be overridden as the algorithm is fixed,  and the sub-classes should not change the behavior of it we need to declare it as final.

<br><br> 
<strong>public final void render()</strong>    
 
 
 
<h5>The UML representation of the pattern :</h5> 
 
 <img alt="template-method-design-pattern" src="template-method-design-pattern-2.html">
 
 
 <h6>Key points :</h6>
 
 
 <ul>
 <li>The template method in the super class calls the methods of the sub-classes, instead the sub-classes calls the template method of the super class.<br><br></li>
 <li>Template methods are techniques for code reuse because with this you can standardize the algorithm and defer the specific implementations to the sub-classes. Again the sub-classes do need to re-write the same algorithm.</li>
 </ul>
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
<br><br>
</td></tr></table>
<a href="index-2.html"><strong>BACK</strong></a>
</div>
  

</body>

<!-- Mirrored from www.java.designpatterns.jobs4times.com/template-method-design-pattern.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:36:41 GMT -->
</html>