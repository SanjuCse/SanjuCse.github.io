<!DOCTYPE html>
<html>

<!-- Mirrored from www.java.designpatterns.jobs4times.com/singleton-design-patterns.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:36:39 GMT -->
<head>
<meta charset="ISO-8859-1">
<title>Java design patterns</title>
<link style="text/css" rel="stylesheet" href="styles.css">

</head>


<body>

<div align="center" >
<table border="1" style="width: 888px"><tr><td>
 
<table>
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500px" height="200">   </a> </td>
<td align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180px" height="200" >  </a>  </td>
</tr>  
</table> 

 
 
<h1>Singleton Design Pattern </h1> 
If we create a class as singleton, an application allows only one instance of that class. Generally 
we create a class as singleton when we want global point of access to that instance.
<br><br>
<ol spellcheck="true" style="richness: inherit;" start="A">
<li><strong>Declare the constructor of the class as private : </strong> <br>
Other classes in the application cannot create the object of the class directly(stops allowing more instances). <br><br></li>
<li><strong>Declare a static method : </strong> <br>
The methods of the same class can call the constructor to create objects, so in this method I can write the code to check and return only one object of the class.
<br>
But if this method is a member method, to call it we need an object of the class(). So to call this method without the object, declare this object as static method.
<br><br></li>
<li><strong>Declare a static member of the same class-type in the class : </strong><br>
In the above static method, we need to write the code for returning only one instance of the class. <br><br>
<b> How do you track whether an object for that class already exists ?</b><br>
When you will create a first object you will assign it to a member variable. So in the next call to the method, you just return the same object which you stored in the member variable.
<br>
<p>But member variables cannot be used in a static method, so you need to declare that variable as static variable to hold the reference of the same class. </p>
 </li>
</ol>

<h5>The UML representation of the singleton :</h5>
<img alt="singleton" src="singleton.png">
<br>
<br>

<strong>Points to remember :</strong>

<ul>
<li>DateUtil() is a private constructor </li>
<li>instance is a static variable declared with in the class</li>
<li>getInstance() is a static method, acts as a factory method to create the object of the class.</li> 
</ul>



<pre>
package com.sinleton;

public class DateUtil {
	
 //declare static member of the same class-type in the class
 private static DateUtil instance;

 //constructor is declared as private
 private DateUtil(){ }
 
 //declare a static method to create only one instance
 //(static factory method)
 public static DateUtil getInstance(){
  if(instance==null){
	  instance=new DateUtil();
  }	 
 return instance;
 }//getInstance

}
</pre> 


we can write the above piece of code in various other ways and there are many ways to implement it.

<h2>1. Eager Initialization :</h2>

<pre>
package com.sinleton;

public class DateUtil {
	
 //declare static member of the same class-type in the class
 <strong>
 private static DateUtil instance=new DateUtil();</strong>
 //instantiating the instance attribute when the class is loaded

 //constructor is declared as private
 private DateUtil(){ }
 
 //declare a static method to create only one instance
 //(static factory method)
 public static DateUtil getInstance(){
   return instance;
 }

}
</pre>
<h3>2. Static block Initialization :</h3>

<pre>
package com.sinleton;

public class DateUtil {
	
 //declare static member of the same as class-type
 private static DateUtil instance;
 
 <strong>
//static block execute once when the class is loaded
 static{
	instance=new DateUtil(); 
 } 
 </strong>

 //constructor is declared as private
 private DateUtil(){ }
 
 //declare a static method to create only one instance
 //(static factory method)
 public static DateUtil getInstance(){
   return instance;
 }

}
</pre>
But the problem with above code is even you don't need the object also it will be instantiated.

<h4>3. Lazy Initialization :</h4>

<ul>
<li>In most of the cases it is recommended to delay the instantiation process until the object is needed.</li>
<li>To achieve this we can delay the creational process till the first call the getInstance() method. </li>
<li>But the problem with this is in a multi-threaded environment when more than one thread are executing at the same time, it might end-up in creating more than instances of the class.</li>
<li>To avoid this we can even declare that method as synchronized.</li>
</ul>


<pre>
private static DateUtil instance;

public static synchronized DateUtil getInstance(){
 if(instance==null){
	 instance=new DateUtil();
 }
 return instance;
}
</pre> 

Instead of making the whole method as synchronized, it is enough to enclose only the condition check in synchronized block.

<pre>
public static DateUtil getInstance(){
 synchronized(DateUtil.class){
 if(instance==null){
	 instance=new DateUtil();
 }
 }
 return instance;
}
</pre>  

<ul>
<li>Again we have a problem with the above piece of code, after the first call to the getInstance(), in the next calls to the method will check for instance==null check.</li>
<li>While doing this check, it acquires the lock to verify the condition which is not required.</li>
<li>Acquiring and releasing locks are quiet costly and we should avoid as much we can. To fix this we can have double level check for the condition as shown below.</li> 
</ul>

<pre>
public class DateUtil {
private static DateUtil instance;

private DateUtil(){ }
		
public static DateUtil getInstance(){
if(instance==null){
 synchronized(DateUtil.class){
	 //double check
 if(instance==null){
  instance=new DateUtil();
 }
}
}
return instance;
}
	
}
</pre>

It is recommended to declare the static member instance as volatile to avoid problems in a multi-threaded environment.

<pre>
public class DateUtil {
private static volatile DateUtil instance;

private DateUtil(){ }

public static DateUtil getInstance(){
if(instance==null){
 synchronized(DateUtil.class){
	 //double check
 if(instance==null){
  instance=new DateUtil();
 }
}
}
return instance;
}
	
}
</pre>


It seems like with the  above way we understand the best possible way of creating a singleton class.

<h6>Do you still see any drawbacks in the above piece of code ?</h6>

Yes, when we serialize and de-serialize a singleton class, the de-serialize process will creates as many number of objects for singleton class which avoids the rules of singleton.

<pre>
import java.io.Serializable;

public class DateUtil implements Serializable{
private static DateUtil instance;

private DateUtil(){ }

public static DateUtil getInstance(){
if(instance==null){
 synchronized(DateUtil.class){
	 //double check
 if(instance==null){
  instance=new DateUtil();
 }
}
}
return instance;
}
	
}
</pre>


<pre>
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class SingletonTest{
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
	
DateUtil d1=DateUtil.getInstance();

ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File("e:\\dateUtil.ser")));
oos.writeObject(d1);

ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File("e:\\dateUtil.ser")));
DateUtil d2=(DateUtil)ois.readObject();
	
System.out.println("d1==d2 : ? "+(d1==d2));
 //the above statement returns false

}
}
</pre>




So, how to avoid creating more than one objects of the singleton class even we serialize and de-serialize also.

<p>That's where we need to write  <strong>readResolve()</strong> method as part of singleton class.<br>
The de-serialization process will call readResolve() on a class to read the byte stream to build the object.<br>
If we write this method and can return the same instance of the class, we can avoid creating more than one object even in case of serialization as well.
</p>



<pre>
package design;

import java.io.Serializable;

public class DateUtil implements Serializable{

 //declare static member of the same class-type in the class
 private static volatile DateUtil instance;

 //constructor is declared as private
 private DateUtil(){ }
	 
 //declare a static method to create only one instance (static factory method)
 public static DateUtil getInstance(){

 if(instance==null){
  synchronized (DateUtil.class) {
   if(instance==null){    //double-check
    instance=new DateUtil();
   }	 
  }
 }
 return instance;
 }//getInstance

protected Object readResolve(){
 return instance;
}

}
</pre>


<pre>
package design;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class SingletonTest{
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
	
DateUtil d1=DateUtil.getInstance();

ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File("e:\\dateUtil.ser")));
oos.writeObject(d1);

ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File("e:\\dateUtil.ser")));
DateUtil d2=(DateUtil)ois.readObject();
	
System.out.println("d1==d2 : ? "+(d1==d2));
 //the above statement returns true

}
}
</pre>


<h5>Override clone() method and throw CloneNotSupportedExcepton :</h5>
<ul>
<li>In order not to allow singleton  class to be cloneable from created objects, it is even recommended to implement your class from Cloneable interface and override clone() method.<br>
 Inside this method we should throw CloneNotSupportedException to avoid cloning of the object.<br><br></li>


<li>If you observe carefully clone() method is protected method in object class which cannot be visible outside the class unless we override.</li>
<li>The why do i need to implement from Cloneable and should throw exception in clone() method.<br><br></li>

<li>For e.g. if someone might write a class implementing Cloneable interface and calling super.clone() method in it.</li>
<li>If your singleton class extends from the other class, as the clone() method has been overridden in the base class you can use that method in cloning your object.<br><br></li>
<li>So to avoid such kind of instances, it is always said to be recommended to override the clone() method and throws exceptions.</li>
</ul>



<pre>
package design;

import java.io.Serializable;

public class DateUtil implements Serializable,Cloneable{

 //declare static member of the same class-type in the class
 private static volatile DateUtil instance;

 //constructor is declared as private
 private DateUtil(){ }
	 
 //declare a static method to create only one instance (static factory method)
 public static DateUtil getInstance(){

 if(instance==null){
  synchronized (DateUtil.class) {
   if(instance==null){    //double-check
    instance=new DateUtil();
   }	 
  }
 }
 return instance;
 }//getInstance

protected Object readResolve(){
 return instance;
}

@Override
protected Object clone() throws CloneNotSupportedException{
	throw new CloneNotSupportedException();
	//super.clone();
	//return instance;
}

}
</pre>



<pre>
package design;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class SingletonTest{
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException, CloneNotSupportedException {
	
DateUtil d1=DateUtil.getInstance();

ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File("e:\\dateUtil.ser")));
oos.writeObject(d1);

ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File("e:\\dateUtil.ser")));
DateUtil d2=(DateUtil)ois.readObject();
	
System.out.println("d1==d2 : ? "+(d1==d2));
 //the above statement returns true


DateUtil d3=(DateUtil) d1.clone();
System.out.println("d1==d3 : ? "+(d1==d3));
 //the above statement returns true
}
}
</pre>



<br><br>
</td></tr></table>
<a href="index-2.html"><strong>BACK</strong></a>
</div>
  

</body>

<!-- Mirrored from www.java.designpatterns.jobs4times.com/singleton-design-patterns.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:36:39 GMT -->
</html>