<!DOCTYPE HTML>
<html>
  
<!-- Mirrored from java.scwcd.jobs4times.com/Servlet-Technology-Model.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:07 GMT -->
<head>
    <title>Servlet Technology Model , Servlet API and life cycle;javax.servlet Package :Interfaces,Classes,Exceptions;
    javax.servlet.Servlet interface : load-on-startup, Life Cycle of the Servlet  implements Servlet interface,
    GenericServlet(AC):javax.servlet.http package :Structure of HttpRequest,HttpResponse,Http methods,
    GET,POST,HEAD,OPTIONS,PUT,DELETE,TRACE;HttpServlet :Life Cycle of HttpRequst,HttpServletRequest,
    To retrive request parameters,request headers,request cookies,client &amp; Server information from request,
    HttpServletResponse, To set response headers,ContentType of response, get Text Stream for response,
    Binary stream, perform redirecting, add Cookies to the response,Differences  send-Redirection , forward mechanism </title>
	
    <meta name="keywords" content=" Servlet API,life cycle,javax.servlet Package,Interfaces,Classes,
    Exceptions,javax.servlet.Servlet interface,load-on-startup,Servlet interface,GenericServlet (AC),
    javax.servlet.http package,Structure,HttpRequest,HttpResponse,Http methods,GET,POST,HEAD,OPTIONS,PUT,
    DELETE,TRACE,HttpServlet,HttpServletRequest,request parameters,headers,cookies,client,Server,
    HttpServletResponse, response, Text Stream,Binary stream,redirecting,send-Redirection, forward mechanism ">
    
    <meta name="description" content="   Servlet Technology Model :servlet API and life cycle,Http methods,
    HttpServletRequest,HttpServletResponse,
    Servlet deffination : Servlet is a single instance multiple thread based server side Technology to develop Dynamic web resources of web application. ">
    
    <meta name="content-type" content="text/html; charset=ISO-8859-1">
    
  <link rel="stylesheet" type="text/css" href="styles.css">
  
 

  </head>
  
 
  <body>
  <div align="center">
  <table width="75%" border="1"> <tr><td>
  
  
  
  <table width="100%" cellpadding="0" cellspacing="0" border="0" bgcolor="">
     <tr>
     <td width="50%" align="left"><a href="https://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="700" height="200">   </a> </td> 
   	<td  align="right"><a href="index-2.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 
   	</tr>
</table>
  
  
  
  <h1 align="center" style="background-color: rgb(0, 55, 0);"><font color="#ffff00">Servlet Technology Model</font></h1>
<h2><font color="#fffff"><u>Agenda:</u></font></h2>
<ol >
<li><a href="#api">Servlet API and life cycle</a><ul type="square">

<li><a href="#servpack">javax.servlet Package : </a><ul>
<li><a href="#spinterface">Interfaces  :(14) </a></li>
<li><a href="#spclass">Classes  : (9) </a></li>
<li><a href="#spexcep">Exceptions  : (2) </a></li></ul></li>

<li><a href="#servint">javax.servlet.Servlet interface : </a></li>
<li><a href="#loadon">load-on-startup </a></li>
<li><a href="#lifecycle">Life Cycle of the Servlet that implements Servlet interface : </a></li>
<li><a href="#gserv">GenericServlet(AC): </a></li>



<li><a href="#httppack">javax.servlet.http package : </a><ul>
<li><a href="#hinterface">Interfaces  :(8) </a></li>
<li><a href="#hclass">Classes  :(7) </a></li></ul></li>

 <li><a href="#sthrequest">Structure of HttpRequest : </a></li>
 <li><a href="#sthresponse">Structure of HttpResponse : </a></li>
</ul>
</li>

<li><a href="#hmethod">Http methods</a><ol>
 <li><a href="#get">GET </a></li>
 <li><a href="#post">POST </a></li>
 <li><a href="#head">HEAD </a></li>
 <li><a href="#option">OPTIONS </a></li>
 <li><a href="#put">PUT </a></li>
 <li><a href="#delete">DELETE </a></li>
 <li><a href="#trace">TRACE </a></li></ol>

<ul>
<li><a href="#httpserv">HttpServlet : </a></li>
<li><a href="#lifehrequest">Life Cycle of HttpRequst : </a></li></ul>

</li>

<li><a href="#hrequest">HttpServletRequest</a>
 <ol  type="a">
 <li><a href="#rpara">To retrive request parameters</a></li>
 <li><a href="#rheader">To retrive request headers</a> </li>
 <li><a href="#rcookie">To retrive request cookies</a></li>
 </ol>
 <ul><li><a href="#client">Retrieving client &amp; Server information from the request : </a></li></ul>
</li>
			  	
<li><a href="#hresponse">HttpServletResponse</a>
<ol type="1">
<li><a href="#reheader">To set response headers</a></li>
<li><a href="#recontent">To set ContentType of response</a></li>
<li><a href="#restream">To get Text Stream for response </a></li>
<li><a href="#rebinary">To get Binary stream for response </a></li>
<li><a href="#reredirect">To perform redirecting</a> </li>
<li><a href="#recookie">To add Cookies to the response</a> </li>
</ol>
<ul>
<li><a href="#diffredfor">Differences between send-Redirection and forward mechanism : </a></li></ul>	  </li>	 
 
</ol>

			  

<br>
<hr color="green" size="3"> 


<h3  style="background-color: rgb(0, 0, 123);"><font color="#FFFFFF">Introduction :</font></h3>
 
  <h3 style="background-color: rgb(0, 128, 0);">2-tier:</h3>
  
  known and fixed number of  clients we can access 2-tier.<br> 
  <strong>Web Application :</strong> collection of web resources.<br> 
  <strong>web resource :</strong> each web resource is capable of generate one web page.(Ex: html , servlets, Jsp's , java script  )<br><br> 
  <h6>Web resources :</h6>2 types <ol><li>
  static</li><li>Dynamic </li></ol>
  A web page whose content is fixed  i.e., static web page <br>
  Ex: html , js , images <br><br>
  A web page whose content will be changed dynamically based on time of request generate input values of the request.<br> 
   <u><strong>Ex:</strong></u>Servlets, JSP's , Server side java script(ssjs) , PHP <br>
   Based on the place client side web resources program executed.(in browser) <br>
   Based on the place server side web resources program executed  but not resides .(in server side) <br>
   <hr> 
   <h5>WEB APPLICATION REQUIREMENTS :</h5>
   <ol>
   <li>Browser software.</li>
   <li>Technology to develop client side.</li> 
   <li>Technology to develop server side.</li>
   <li>User  software.</li>
   <li>DataBase software.</li>
   </ol>
   <hr>
   <br> 
   <h6>WEB Server Software : </h6>
   Web server software is special piece of s/w  (or) special s/w which can  manages the web applications and web resources we executes this  web resources  automatically or dynamically when ever your requesting .<br>
   	
  <img alt="" src="mode/mode1.png"><br>
   	<hr> 
   	<h5>Responsibilities of web server :</h5>
   	<ol>
   	<li> It collects all client http requests.</li>
   	<li> It passes to appropriate  web resources of  web application. </li>
   	<li> Web server proceed built middle ware software.</li>
   	<li> container built in controller software. </li>
   <li>Gives resultant out put.</li>
   	</ol>
   	<hr>
   	<br> 
   	<h6>Responsibilities of Servlet Container : </h6><br>
   	<ol>
   	<li>To provide the environment to manage web resource of  Web Application. </li>
   	<li>It Perform total life cycle operations.</li>
   	<li>In case of JSP to generate corresponding Generated Servlet.</li>
   	</ol>
   	
   	<br>
   	J2SDK software is instalable.<br>(through cmd prompt )<br>
   	J2EE is not a instalable software , It is a specification,(not through cmd prompt )<br><br>
   	Specification is a document ,   it contain set of RULES(interfaces) and GUIDELINES(classes).<br>
   	SERVLET ia not a technology , It is a specification.<br><br>
   	Specification related package consists of more number of INTERFACES  and less number of CLASSES.<br> 
   	 
   	RULES ---&gt;interfaces(method declarations)<br> 
   	GUIDELINES----&gt; classes(concrete methods )<br><br>  
   	
   	In servlets we use the instance variables are not Thread Safe.<br>
   	
   	
   <br> 
    
   <h3><font color="#FFFFFF">Web Programming for Static information : </font></h3><br>
   
   <br><img alt="" src="mode/mode3.png"><br>
   Client sends a request for a static file. <br>
   Web server searches whether the requested static file  is available or not at Server side.<br>
   If the requested resource is available then it will return that static file as response.<br>
   If it is not available ,then web server sends 404  status code saying RequestResource is not available.<br>
   To serve static file, no processing is required at server side .Hence webserver always loves to serve static information.<br>
   <br> 
   <h2>Web Programming for Dynamic information : </h2>
   
   <br><img alt="" src="mode/mode2.png"><br>
   
   Client sends  a request to the Web server. <br>
   Web server checks whether the request is for  static or Dynamic information.<br>
   If the request is for static information , web server searches for the required Static  file.<br>
   If it is available it returns that file , other wise it returns 404 status code.<br>
   If the request is for Dynamic information web server forwards the request to some Helper Application.<br>
   Helper Application analyzes and process the request and generate required dynamic information.<br>
   Helper Application forwards that response to the web server and web server forwards that response to the client.<br>
  <h5>
   The following are  various possible Helper Applications at Server side.</h5>
   1.Servlet<br>
   2.Jsp<br>
   3.Asp.net<br>
   4.PHP <br> 
   5.cold fusion<br>
   6.CGI<br>
   7.server side Java Script.<br>
   
   <br>
   A servlet is a Server side web component managed by web container for generation of dynamic information.<br>
   Web container is the best assistent  to the programmer . It maintains entire life cycle of the servlet.<br>
    So that programmer has to concentrate only on Business logic.The remaining  operations  Instantiation of Servlet , Executing life cycle, Destroying the Servlet object  and etc, taken care by Web container. <br>
    <br> 
     
   <h4>TYPES   OF   WEB   CONTAINER:</h4>
    There are  3  types of web containers are possible.<br>
    <ol>
    <li><u><font color="#990000"><strong>Stand alone :</strong></font></u><br>
    Both web server  and web container are available in a single integrated component , such type of web container are called  Stand-alone web container.<br> 
    <u>Ex :</u> Tomcat <br>
    This type of web containers are best-suitable  for small scale applications and rarely used.<br>
    </li>
    
    <li><u><font color="#800040"><strong>In-Process Web container :</strong></font></u><br>
    If the web container runs in same address space(same machine) of web server and it is available as plug-in such type of web containers are called In-Process  web container. <br>
    In this case both web server and web container  need  not be from the same vendor.<br>
    </li>
    
    <li><font color="#800000"><u><strong>Out-Process Web container:</strong></u></font><br>
    Web server and web container both are running on different machines , Web container is attached to the web server externally.Such type of web containers are called  Out-process web containers. <br>
    we can configure front-end apache has to forward the request  to the back-end  weglogic  server. These type of web containers  are industry using.<br>
    This type of web Containers are most commonly used web containers.<br><br><img alt="" src="mode/mod4.png">
    </li>
    </ol> 
     
   <br><br> 
    
     
    <h3>Differences  between  CGI and Servlets :</h3>
    
     <table border="1" >
     
     <tr>
     <th><u>CGI</u></th><th><u>SERVLETS</u></th>
     </tr>
     <tr><td>It is Process based  i.e, for every request a separate process will be created and it is responsible to generate required  response.  </td>
     <td>It is thread-based i.e, for every request a new thread will be created and it is responsible to process the request.  </td>
     </tr> 
     <tr><td>Creation and Destruction  of process for every request is costly. If the number of requests increase it will effects performance of the system.Hence CGI technology fail to the destroy of scalable.<br></td>
     <td>Creation and Destruction of new thread for every request is not costly . Hence there is no effect on performance  even though number of requests increases due to this it succeeds to delevary scalable.<br></td>
     </tr>
     <tr><td>Two process never share same address space(memory).Hence there is no chance of concurrency, inconsistency problems and syncronization is not required. <br></td>
     <td>All threads share common address space hence there may be a chance of concurrency,  inconsistency  problems.<br></td>
     </tr>
     <tr><td> CGI programs can be written in multiple languages.But most commonly used language is PERL.<br></td>
     <td>Servlets can be written only in  Java.<br></td>
     </tr>
     <tr><td>Most of the CGI languages are not object oriented.Hence we are missing benefits of OOPs.<br></td>
     <td>Java language itself is Object-Oriented . Hence we can get all benefits of OOPs.<br></td>
     </tr>
     <tr><td>CGI technology is platform dependent.<br></td>
     <td>Servlet technology is platform  independent.<br></td>
     </tr>      
     </table>
   
   
 <h6>FAST  CGI : </h6> 
   
  It improves performance when compared with traditional CGI. In this case web container maintains a pool of process so that a single process can serve multiple requests one by one.<br><br>     
   
  
<br>
<br>


<hr> 
   	<h1 style="background-color: rgb(128, 0, 0);"><font color="#00ff00">Servlet Technology Model : </font></h1>
   	<ol>
   	<li> servlet API and life cycle</li>
   	<li> Http methods </li>
   	<li> HttpServletRequest</li>
   	<li>HttpServletResponse</li>
   	</ol>




 
   <font color="#0000ff"><u><strong>Servlet deffination :</strong></u></font> Servlet is a single instance  multiple thread based  server side Technology to develop Dynamic web resources  of web application. 
    
  <h2 id="api" style="background-color: rgb(128, 0, 0);"><font color="#ffffff"><strong><u>Servlet API </u></strong>:</font></h2>
  We can develop Servlets by using the following 2 packages. <br> 
  <ol>
  <li>  <u><strong>javax.servlet:</strong></u> This package defines several classes and interfaces to develop servlets from scratch irrespective of any protocol.</li>
  <li>  <u><strong>javax.servlet.http : </strong></u> It is the sub package of javax.servlet and contains  several convenient  classes and  interfaces to develop  http based  servlets.</li>
  </ol> <h2 id="servpack">  javax.servlet  Package :  </h2>
  <h3 id="spinterface">Interfaces  of  javax.servlet  Package :(14) 
   
  </h3><ol>
  
  <li><strong><font color="#0000ff">Servlet :</font> </strong><br>
  Every servlet in java should implement  servlet interface either directly or indirectly. ie, Servlet interface acts as a root interface for all java Servlets.<br>
  This interface defines the most common methods (including life cycle methods) which are applicable for any servlet object.<br>
  </li>
  
   <li> <strong><font color="#0000ff">ServletRequest :</font></strong><br>
  ServletRequest object can be used to hold client data.<br>
  ServletRequest interface defines several methods to acts as end  users provided data from the request object.<br> 
  <u><strong>Ex:</strong></u> getParameter() 
  <br>
  </li> 
  
   <li><strong><font color="#0000ff">ServletResponse :</font></strong><br>
  ServletResponse object can be  used to prepare and send responds  to the  client.<br>
  ServletResponse interface defines several methods which are required for preparation of response.<br> 
  <u><strong>Ex:</strong></u>  getWriter(),  setContentType() 
  </li>
  
  <li><strong><font color="#0000ff">ServletConfig :</font></strong><br>
  For every servlet , web container creates one  ServletConfig    object to  hold its configuration information like logical  name of the Servlet , instantiation parameters etc.<br>
  ServletConfig interface defines several methods to access servlets configuration information.<br> 
  <u><strong>Ex:</strong></u> getServletName()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  		getInitParameter()<br>
  </li>
  
  <li><strong><font color="#0000ff">ServletContext :</font></strong><br>
 For every web application, web container will create one ServletContext object to hold application level configuration information like name of the app'n and  ServletContext parameter etc. 
<br> 
 <em><strong>Note : <font color="#0080ff">ServletConfig is per Servlet , where as ServletContext is per web application.</font></strong></em><br>
 </li>
 
 <li><strong><font color="#0000ff">RequestDispatcher :</font></strong><br>
 By using RequestDispatcher  object  we can dispatch the request  from one  component to another  component.<br>
 This interface defines two methods.<br>
 1. forward()<br>
 2.include()<br>
 <br>
 
 </li>
 
 <li><strong><font color="#0000ff">SingleThreadModel :</font></strong><p>
 Servlet technology is single instance multi threaded model. i.e, multi  threads can operate simultaneously on the servlet object . Hence there may be a  chance of data inconsistency problems.</p><p>
 we can resolve these problems by  using SingleThreadModel interface. If a servlet implements SingleThreadModel  interface, then a single thread  can access servlet object at a time i.e, Servlet can process only one request at a time.  i.e, the main objective of SingleThreadModel  interface  is to provide  thread-safety.</p><p>
 But the problem with  SingleThreadModel  is  Servlet can process only one  request at a time which impacts  performance  of  the  system. Because  of this problem SingleThreadModel  interface is not  recommended to use  and it is deprecated in Servlet 1.3  version without  introducing  any  replacement.</p> <p>
 we can provide thread-safety  to the Servlet by using syncronized  keyword.</p><p>
 SingleThreadModel interface  doesn't  contain any methods . It is a marker interface.</p>
 <b>
 Note:</b> In addition to  above  interfaces  javax.servlet package defines the following interfaces also .<br>
<br> </li>
 
 <li><font color="#0000ff"> Filter</font></li>
 <li><font color="#0000ff">FilterConfig </font></li>
 <li><font color="#0000ff">FilterChain </font><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----- to implements Filter Concept.<br></li>
 <li><font color="#0000ff">ServletRequestListener</font></li>
 <li> <font color="#0000ff">ServletRequestAttributeListener</font></li>
 <li> <font color="#0000ff">ServletContextListener</font></li>
 <li> <font color="#0000ff">ServletContextAttributeListener</font><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ----- to implements Listener Concept.</li>
 
 </ol>
 
 <br> 
  
 <h3  id="spclass">Classes of javax.servlet  package : (9)</h3>
 
 <ol>
 <li><font color="#0000ff">GenericServlet :</font> <br>
 This class implement Servlet interface and provides dafault implementation for every method except service( ). Hence it is an abstract  class.<br>
 we can use this class as  a base class to develope protocol independent servlets.<br>
 </li>
 
 <li><font color="#0000ff">ServletOutputStream :</font><br>
 we can use this  class object to send binary  data( pdf files , image files ,  video/audio  files etc ) as response to the  client.<br>
 <br>
 </li>
 
 <li><font color="#0000ff">ServletInputStream:</font> <br>
 we can use ServletInputStream objects to read binary data send  by the client. <br>
 Note:<br>
 In addition to above classes  javax.servlet package defines the following classes also <br>
</li> 
 
 <li><font color="#0000ff"> ServletRequestWrapper</font> <br></li>
  <li><font color="#0000ff"> ServletResponseWrapper</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  -----------to implement wrapper concept. <br></li>
 <li><font color="#0000ff"> ServletRequestEvent </font><br></li>
 <li><font color="#0000ff">ServletRequestAttributeEvent</font><br></li>
 <li><font color="#0000ff"> ServletContextEvent</font><br></li>
 <li><font color="#0000ff"> ServletContextAttributeEvent</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  -----------to define Events for Listeners. <br></li>
 </ol>
 
 <br>All Events are classes and Listeners are interfaces<br><br> 
  
<h3 id="spexcep"> <strong><u>Exceptions of javax.servlet package  :  </u></strong></h3>
 javax.servlet package defines the  following 2 exceptions.
 <ol> <li>
 <strong> ServletException.</strong><br>
 Servlet can throw  this exception  whenever  it faces any difficulty while processing client request.<br> 
 </li><li><strong> UnavailableException : </strong><br>
 It is the child class of ServletException  and  it  is depricated .</li></ol>
<img src="mode/mod5.png" >
 		<br> 
 		 
<u><em><strong>Note : </strong></em></u><br> 
In total <strong> javax.servlet</strong>  package defines <br>
         14 - Interfaces <br>
         9--Classes<br>
         2--Exceptions<br>
         
 <br> 
  
  
 <h3 id="servint">javax.servlet.Servlet  interface : </h3>
Every servlet in java should compulsary implement  Servlet interface  either directly or indirectly  i.e, Servlet interface  acts as a root interface for all servlets. <br>
This interface defines the most common methods which can be applicable for any Servlet object. <br>
The following are the  methods  defined in Servlet interface.<br>
<br> 
1. init( ) <br> 
2. service( ) <br> 
3. destroy( ) <br> 
4. getServletConfig( ) <br> 
5. getServletInfo( ) <br>


<br> 
<h3>1. init():</h3>
<table border="2" bordercolor="red" style="font-size: 25">
<tr><td>public void init(ServletConfig  config ) throws ServletException  </td> </tr>
</table>
<br>
This method will be executed only  once by the web container  immediately after Servlet instantiation to perform initialization activities .<br/><br>
Web container won't place Servlet object  into service( ) method   in the following cases : <br>
1. If init() throws  ServletException. <br>
2. If init() doesn't return  with in the time period specified by web container.<br>
<br>
In the above cases web contaioner makes that  servlet object eligible for Garbage Collection without calling any other life cycle method .<br>
In this case web container  creates a new Servlet  object to provide service.<br>

<br> 
<h3>2. service( ) : </h3>

<table border="2" bordercolor="red" style="font-size: 25">
<tr><td>public void service(ServletRequest request , ServletResponse response ) throws ServletException,IOExceptuion  </td> </tr>
</table>
 
<br>
web container calls this method for  every request to provide response.<br>
Entire servicing logic/business logic , we have to define in this  method  only. <br>

<br> 
 
<h3>3. destroy() : </h3>

<table border="2" bordercolor="red" style="font-size: 25">
<tr><td>public void destroy( );  </td> </tr>
</table>

<br>

This method will be  executed  only  once by the web container to perform  claen up activities , when ever  web container takes servlet object from  out of service. This is usually happens at the time of application undeployed (or)  at the time of server  shut down  (or) Web Container requires  some free memory . <br>
<br>
<br>
when ever web container calls  destroy( ) method , it may not be executed immediately. It will wait untill completing  all currently executing  threads. <br>
<br>
<br> 
NOTE : init( ) , service( ) , destroy( )  are called life cycle methods of Servlet. <br> 
  we can call destroy() explicitly  from the init( )  and service( ) , in this case  destroy( ) will be  executed  just like a normal method  call and servlet object won't  be destroyed . <br>
  <br> 
   
  <h3>4. getServletConfig : </h3>
  
  <table border="2" bordercolor="red" style="font-size: 25">
<tr><td>public ServletConfig  getServletConfig( ); </td> </tr>
</table>
  <br>
  This method can be used to get ServletConfig object . <br>
  By using this config object Servlet can get its configuration information.<br> 
  <br>
  <br> 
   
 <h3>5. getServletInfo ( ) :</h3>
 
 <table border="2" bordercolor="red" style="font-size: 25">
<tr><td>public void getServletInfo()  </td> </tr>
</table><br>
This method returns information about  Servlet like Author, version , copy right information etc. <br>

<hr>
 

Demo program the develope a servlet by implementing Servlet interface <br>
<br>
FirstServlet.java
<pre>
package com.jobs4times;
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class FirstServlet  implements Servlet {

	static {
		System.out.println("Servlet class loading");
	}
	public FirstServlet () {
	System.out.println("servlet instantiation");
	}
	
	ServletConfig config;
	public void init(ServletConfig  config ) throws ServletException {
		this.config=config;
		System.out.println(" we are in  init( ) method ");		
	}
	public void service(ServletRequest request, ServletResponse response)
	                               throws ServletException, IOException {      
		System.out.println("We are in service( ) method ");
		PrintWriter out=response.getWriter();
		out.println("welcome to SCWCD");
	}
	public void destroy() {
		System.out.println("We are in destroy() method ");		
	}
	public ServletConfig getServletConfig( ) {
		return null ;
	}
	public String getServletInfo() {
    	return "Written by Jobs4Times " ;
	}	
}
</pre>

web.xml
<pre>
&lt;web-app&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.jobs4times.FirstServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;
 &lt;/servlet&gt;
 
 &lt;servlet-mapping&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/fs&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>
   


<br><br><u><strong>http://localhost:8080/SCWCD1A/fs 
 
</strong></u><br>
<ol>
<li>When ever we are sending the request ,webserver checks whether  this request is for static or dynamic  information by using  URL pattern.</li>
<li>If the request is for static information , Webserver  searches for the required static file and provides required  response.</li>
<li>If the request is for dynamic information , Webserver forwards that request to webcontainer .<br>The webcontainer identifies the corresponding  servlet class by using  web.xml</li>
<li>Webcontainer  loads that .class file , perform instantiation , and execute init( ) and service( ) methods and provide required response to the webserver </li>
<li>webserver inturn forwards that response to end-user.</li>
</ol>


 
<h4  id="loadon">WithOut &lt;load-on-startup&gt; : </h4> <strong>
First Request: 
</strong><ol>
<li>loading .class file   (/  servlet  loading) </li>
<li>Instantiation</li>
<li>init( ) </li>
<li>service( ) </li>
</ol> 
 
<strong>Second Request:</strong>  service( ) 
 

<h4>With &lt;load-on-startup&gt; :</h4>  
At server startup/Application deployment  
<ol>
<li>loading .class file   (/  servlet  loading) </li>
<li>Instantiation</li>
<li>init( ) </li>
</ol> 
<strong>First Request :</strong>  service( )<br>
<strong>
Second Request :</strong> service( ) 
 
<h5>Note:</h5>The allowed values for &lt;load-on-startup&gt; tag  is  an integer  i.e.,  +ve , zero , -ve <br>
In the case of &lt;load-on-startup&gt; in deployment descriptor  <ul><li>
Highest value to give the least priority</li><li> 
Lowest value give high Priority</li><li>
Zero will give last priority</li><li>-ve&nbsp; value means ignore the &lt;load-on-startup&gt; concept.</li></ul>

If we give the two servlets having the same &lt;load-on-startup&gt; value we can't expect execution order&nbsp; or&nbsp; behaviour .


<h6>What is the  advantage of &lt;load-on-startup&gt; :</h6>
We can equalize the response time  of  first request  and remaining requests.
<br><br>
The main disadvantage of &lt;load-on-startup&gt; is it increases  server start up  time  without any specific requirement   don't configure this  &lt;load-on-startup&gt; on servlet.



<h6>Note:</h6> From servlet 2.5v onwards a single servlet can be mapped with multiple &lt;url-pattern&gt;tags&nbsp; i.e., we can take&nbsp; multiple &lt;url-pattern&gt; tags&nbsp; with in single &lt;servlet-mapping&gt; tag. <br><br>Ex:
<pre>
&lt;servlet-mapping&gt;
        &lt;url-pattern&gt;/test &lt;/url-pattern&gt;
        &lt;url-pattern&gt;/test &lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>
<b>Note : </b><br>Whenever  we are  writing  2 servlets  having  same url-pattern , if we  are sending a request to particular  url-pattern
<br><br> 
The  order of  evaluation  of web.xml  is decided by the underling  webserver , there is no specification rules
<ul><li>In the case of  Tomcat the order of evaluation  of web.xml is  Bottom to Top.</li><li>In the case of  Weblogic the order of evaluation  of web.xml is  Top to Bottom.</li></ul>
<h2 id="lifecycle" style="background-color: rgb(128, 0, 123);"><font color="#CCCCCC"><u><strong>Life Cycle of the Servlet that implements Servlet interface :</strong></u></font></h2>
<ol>
<li>Servlet class loading by class loader.(It is part of Jvm) </li>
<li>Servlet Instantiation by webcontainer , For this web container always calls public-no-argument constructor . Hence  Every servlet should compulsary contain public-no-argument constructor.Otherwise we will get RuntimeException saying java.lang.Instantiation exception . </li>
  <li>Execution of init(-) by webcontainer <br><em><u><strong>Note:</strong></u></em> The above 3 steps will be performed Generally at the time of first request.If<b>&lt;load-on-startup&gt; </b>is configured these will be executed at the time of either server startup or at the time of application  deployment. </li> 
<li>Execution of service( ) by web-container.</li>
<li>Execution of destroy( )</li>
</ol> 
<em><u><strong>Note:</strong></u></em>If we are invoking destroy( ) explicitly inside service( ) that time any exception will be raised the exception will show to the end-user, when we won't handle this situation .<br>
If web-container calls destroy( ) then that time the exception will be raised the exception that surpressed  by the web-container.<br><br><br>
<h5>
constructor  Vs  init( ) :</h5>
<ul type="square">
<li>In general , we can use constructor to perform initialization activities but in old versions of java, 
constructor cannot accept dynamically generated class name as argument.</li>
<li>To perform initialization of servlet  compulsary we  should provide ServletConfig object as argument.
			whose class name is dynamically generated by web-container</li>
<li>As constructor cannot accept these dynamically generated names, Sun people ignores constructor concept and introduced a specific method init( ) to perform initialization activities , which can take dynamically generated class names as the arguments.</li>

<li>          In the older versions , constructor cannot take any arguments but to perform initialization of a servlet compulsary we should provide ServletConfig as argument.</li>
<li>Hence we can't use constructor to perform initialization activities , Sun people introduced a specific methods init( ) . for this , which can take ServletConfig as  argument. </li> 
</ul>
<h5>
destroy( )  Vs finalise( ) :</h5>
<ul>
<li>Before destroying  any object Garbage collector always calls finalise( ) to perform  cleanup activities. But we can't expect exact behaviour of Garbage collector. which is vendor dependent. </li>
<li> Hence instead of depending on finalise( ) ,  Sun people introduced a specific method destroy( ) to perform cleanup activities , which should be executed always. </li> 
</ul>



<h2 id="gserv">GenericServlet(AC):</h2>
<ul>
<li>We can develope  servlet by implementing Servlet interface directly.
		In this apprach compulsary we should provide implementing  for all methods of servlet interface whether it is required or not .
		This approach increase length  of the code and reduces readability. We can resolve this problem  by using GenericServlet. 
</li>
<li>GenericServlet implements Servlet interface and provide default implementation  for every method except service( ).
		Hence  it is an abstract class.
</li>
<li>We can develope servlets very easily by extending GenericServlet, instead of   implementing Servlet interface directly.
		In this appraoch we have to provide implementation only for required methods  instead of  implementing all.  
		It reduces  length of the code and  improves  readability. 
</li><li>GenericServlet  is protocol independent servlet.</li>
<li>GenericServlet  implements  ServletConfig  and Serializable interfaces also.</li> 
</ul>
<br><img src="mode/mod6.png"><br>



Demo program to develope Servlet by extending  GenericServlet : 
<pre>
public class FirstServlet extends GenericServlet {
 public void service(ServletRequest request,ServletResponse response)
                               throws ServletException, IOException {
 PrintWriter pw=response.getWriter();
 pw.println("Developing Servlet by GenericServlet");
 System.out.println("This is Service() in First Servlet ");
 }
 }
</pre>

  
 
 Internal implementation of  GenericServlet :
 
 <pre>
public abstract class GenericServlet implements 
                   Servlet , ServletConfig , Serializable {
 
 private transient ServletConfig config ; 
 
 public void init(ServletConfig config) throws ServletException { 
 this.config=config ;       //webcontainer purpose
 init( );
 }
 
 public void init( ) throws ServletException { //programmer purpose
 }
 
 public abstract service(ServletRequest request,ServletResponse response)
                               throws ServletException, IOException ;

 public void destroy() {
 }
 							   
 public ServletConfig getServletConfig( ) {
 return config; 
 }
 
 public String getServletInfo( ) {
 return "this is GenericServlet" ;
 } 
 
 <!--public String getServletName( ) {
 return config.getServletName() ;
 } 
 -->
 ----- ------ ---- ------
 -------- ------ ------ 
}
 </pre>
 
 
 
   
  

 
 
 
GenericServlet contains 2 init( ) , we can override  init( )  in our Servlet as follows .<br><br>
<b>1<sup>st</sup> way :</b>
<pre>
public void init(ServletConfig config )  throws ServletException {
	 // my own initialization
 }
</pre>
 
 This approach is not recommented , because we are not saving config object for the future purpose . Hence in our servlet any one calls  getServletConfig( ), this method  returns null . <p>If we are calling getServletName()  then we will get Runtime Exception  saying  java.lang.NullPointerExceprion </p><br>
 <b>
 2 <sup>nd</sup> way : </b>
 <pre>
 public void init(ServletConfig config )  throws ServletException {
	 super.init(config);
	 ............................
}
 </pre>
 
 This approach is valid , but not recommended to override in Servlet ,  because  internally 3 init( ) are executed  , which impacts performence of the system . <br><br>
 
 <b>
 3<sup>rd</sup> way : </b>
 
 <pre>
 public void init( )  throws ServletException {
		 // my own initialization activities
 }
 </pre>
 
  This way is highly recommented to  define init( ) in our  servlet. <br>
 
 <br>
 
 
 <h2>How many init( ) present in GenericServlet and  explain the need of it ? </h2>
      2 init( ) methods are available in GenericServlet.<br>
     One is for web-containers purpose  and the Second one is programmers purpose. <br>
 <h3> In how many ways we can override init( ) in our Servlet and which is the best way ? </h3>
 	3 ways 3<sup>rd</sup> one is the best way. <br> 
<h4>In GenericServlet why config variable declared as transient ? </h4> 
<ol>
<li>Every Servlet in java is Serializable. 
		At the time of Serialization of servlet object the corresponding  config object is serialized automatically . 
		Because it is part of  object-graph of Servlet object.
</li>
<li> If we are serializing  config object , from that config object hacker may get corresponding context object reference. Once hacker got context object  he can able to perform any operation on our application , which is never be recommended security wise. Hence at the time of serialization of servlet object , we can't Serialize config object. Due to this reason config variable declared as transient. <br>
</ol>
<br><br>
<h2 id="httppack"> 2.javax.servlet.http  package  : </h2>
		This package defines more convenient classes and interfaces  to define  http based  Servlets . <br> //protocol dependent
		
		<h3 id="hinterface">Interfaces of  javax.servlet.http :  (8)  </h3>
		<ol>
		<li ><strong> HttpServletRequest</strong> : <br>
					It is the child interface of  ServletRequest .<br>
					HttpServletRequest object  can be used to  hold client information.
		</li>
		<li><strong>HttpServletResponse</strong> :<br>
				It is the child interface of  ServletResponse. <br>
				This object can be used to prepare and  send  response to the client.
		</li>
		<li><strong>HttpSession</strong> : <br>
				We can use HttpSession object to  remember the client information across  multiple requests. i.e., we can use session object  for session management purpose. <br>
		</li>
		<li><strong>HttpSessionListener</strong> : <br> To implement http based Listener
		</li>
		<li><strong>HttpSessionAttributeListener</strong> :  <br> To implement http based Listener
		</li>
		<li><strong>HttpSessionBindingListener</strong> : <br> To implement http based Listener
		</li>
		<li><strong>HttpSessionActivationListener</strong> :  <br> To implement http based Listener
		</li>
		<li><strong>HttpSessionContext</strong> : <br> deprecated and hence not recommended to use 
		</li>
		</ol>
		
		<h2 id="hclass"> Classes of javax.servlet.http  package  :  (7) </h2>
       <ol>
       <li><strong>HttpServlet</strong>  :  <br> It is the child class of GenericServlet . It can be used for  developing  http  based Servlets . </li>
       <li><strong>Cookie</strong> :  <br>  We can  use Cookie objects  to implement Session management.<br><!--  In addition to the above classes  javax.servler.http  package defines the following  classes also.--> </li>
       <li><strong>HttpSessionEvent</strong>   :   <br> To  define Events for http based Listeners.  </li>
       <li><strong>HttpSessionBindingEvent</strong>  :<br> To  define Events for http based Listeners. </li>
       <li><strong>HttpServletRequestWrapper</strong>  : <br> To  define http based Wrappers. </li>
       <li><strong>HttpServletResponseWrapper</strong>   : <br> To  define http based Wrappers.  </li>
       <li><strong>HttpUtils</strong>    :    <br>   Deprecated , not recommended  to use .   </li>
       </ol> 
   	  
   	<strong> Note:<br></strong>   
   	 In total javax.servlet.http  package   defines <br> 
   	 8 -------&gt;interfaces <br>
   	 7-------&gt;classes 
   	  
   	 <br><br>
   	 
   	 Webserver and webclient  communicate by using some common language ,which is nothing but   HTTP . <br>
   	 Http defines  a standard  structures  for    HttpRequst  and  HttpResponse . <br>	
   	 
   	 <h2 id="sthrequest">Structure    of  HttpRequest   : </h2>		
   	 Browser always sends  the  request  in the following format : <br>
   	 
   	 
   	 <table border="3" bordercolor="black" width="30%" height="120" bgcolor="#asffka" >
   	 <tr align="center"><td>Request Line</td>  </tr>
   	 <tr align="center"><td>Request Headers</td> </tr>
   	 <tr align="center"><td>Request Body</td> </tr>
   	 </table>	   	 
   	<br>
   	
  <h3>	Request Line : </h3>
   <table border="3" bordercolor="black" width="80%" height="120" bgcolor="#asffka" >
   	 <tr><td><strong>GET</strong><br><br>(Request method)</td>  <td><strong>/login.jsp</strong><br><br>(Request  URI)</td> <td><strong>HTTP/1.0</strong><br><br>(protocol version used by browser)</td> </tr>
    </table>	   	 
   	<br>
   	<h4> Request Headers :</h4>
   				The request headers describes  configuration information  of the browser like <ol><li>
   				 media types accepted by browser , language accepted by browser , encoding types supported  by browser etc.</li> <li>
   				 Web server use this information to send  custimized responses to the client . </li></ol>
   <h3>	Request Body : </h3>
   <ol>
   <li>It contains end-user provides  information for the GET request it is optional where as for the POST request it is mandatory.</li>
   <li>This is the structure of HttpRequest ,  If the browser sends request in this format , then only webserver understands  the request . i.e, webserver  understandable form.</li>
   </ol>
      
    <br>
    <h2 id="sthresponse">Structure    of  HttpResponse   : </h2>	
    
     <table border="3" bordercolor="black" width="30%" height="120" bgcolor="#asffka" >
   	 <tr align="center"><td>Status  Line</td>  </tr>
   	 <tr align="center"><td>Response  Headers</td> </tr>
   	 <tr align="center"><td>Response Body</td> </tr>
   	 </table>  	 
   	<br>
	<h4>
   	Status  Line :</h4>
   	<table border="3" bordercolor="black" width="80%" height="120" bgcolor="#asffka" >
   	 <tr><td><strong>200</strong><br><br>(Status code)</td>  <td><strong>OK</strong><br><br>(Description)</td> <td><strong>HTTP/1.1</strong><br><br>(protocol version used by server)</td> </tr>
    </table>	
   	 <h5>
   	 Status Codes :</h5>
   	 1xx --------&gt; Informational
   	 <br>2xx---------&gt;Successful<br>
   	 3xx---------&gt;Redirectionaal<br>
   	 4xx---------&gt;client error<br>
   	 5xx---------&gt;Server error<br>   	 
   	 
	 <h3>
   	 Response  Headers :</h3>
   	 These will provide configuration information of the server  and information about the response [meta data] like content type of response , content length , last modified  data etc.,  <br>
   	 Browser will use these response headers to represent  properly the response  to the end-user.<br>
   	 <h4>
   	 Response Body :</h4>
   	 It contains the original response provided by webserver. <br>
   	 If the server sends the response  in the  above  form , then only browser understands the response 
   	  i.e., it is browser understandable form. <br><br><br>
   	 <h3  id="hmethod" >
   	 Types  of  HttpRequest  methods :</h3>
   	 Based on type of information requested by the browser HttpRequest  methods are divided  as  follows
   	 <ol>
   	 <li>GET</li>
   	 <li> POST</li>
   	 <li> HEAD</li>
   	 <li> OPTIONS</li>
   	 <li> PUT</li>
   	 <li> DELETE</li>
   	 <li> TRACE</li>
   	 <li> CONNECT</li>
   	 <li> MOVE</li>
   	 <li>LOCK</li>
   	 <li>PROFIND</li>
   	 </ol> 
   	 <pre>
	  1 - 3  methods  introduced in http 1.0
	  4 - 11 methods introduced in http 1.1
	  1 - 7  are Big Http methods 	  
	 </pre>
	 
	 
   	<h2 id="get"> GET :</h2>
   	 <ol>
   	 <li>We can use get request  if we are expecting information from  the server .</li>
   	 <li>Usually for the get request read operation will be performed at  server side . Hence status  of application won't  be changed in get request. </li>
   	 <li>In GET request end-users  provided information will be appended to the url as the part of Query string. </li>
   	 <li>As the end-users  information is visible in url. there may be a chance of security  problems will raise. Hence sensitive data we can't send by using get request. </li>
   	 <li>The length of the url is fixed . Hence we can send  only limited amount of information  by get request . </li>
   	 <li>Only character data is allowed in url . Hence  we can't send binary data by using get request. </li>
   	 <li>As extra client provided  information is available in the url , Bookmarking of url is possible . </li> 
   	 </ol>
   	<h5> Idempotent  request  :</h5>
   	 By  repeating the request  multiple times , if there is no change in response such type of requests  are Idempotent requests. <br>
   	 Ex: GET requests are Idempotent and  POST requests are not Idempotent. <br>
   	 
   	 <h6>Safe request :</h6>
   	 By repeating  the same request multiple  times , if there is no side-effect at  server side ,
   	  such type of requests are called  safe-requests . <br>
   	 Ex: GET requests  are safe , where as POST requests  are not safe to repeat. <br>
   	 
   	 <br>
   	<b> Triggers to send  GET  request :</b><br>
   	 <ol>
   	 <li>Type url in the address bar and submit is always GET request. </li>
   	 <li>Clicking hyperlink is always  GET request. </li>
   	  <li>Submitting the form , where  method attribute specify with GET value is always GET  request.  <br>
<pre>   
&lt;form action="/test"  method="GET"&gt;
  ----------- ---- 
&lt;/form&gt;
</pre>
  	   </li>
   	  	<li>Submitting the form without  method attribute is always GET request i.e., default method for form is GET. <br>
<pre>
&lt;form action="/test"&gt;
   ----------
   ---------
&lt;/form&gt;
</pre>
   	  	</li>
   	 </ol>
   	 
   	 
   	 <h2 id="post">POST : </h2>
   	 <ol>
   	 <li>If we want to post huge amount of information  to the server  then we should go for POST. <br>Ex: uploading our resume in job portal. </li>
   	 <li>Usually in post requests update operation will be performed. The state of operation will be changed. </li>
   	 <li>In post request , client information will be encapsulated in the request body instead of appending  to the url . Hence we can send sensitive  data by using POST request. </li>
   	 <li>There is no limit on size  of request body . Hence we can send  huge amount of information  to the Server. </li>
   	 <li>We can send  binary data also in addition to text data. </li>
   	 <li>Bookmarking of POST  request is not possible. </li>
   	 <li>POST requests are not Idempotent  and not-safe to repeat. </li>
   	 </ol>
   	 <h6>Triggers to send POST request :</h6>
   	 <br>
   	 There is only  one-way  to send  POST  request that is to use the form  with  method attribute value is POST . <br>
<pre>
&lt;form action="/test"  method="POST"&gt;
   ----------
   ---------
&lt;/form&gt;
</pre>
   	 	
   	 	I.e., without having the form there is no chance of sending  POST request. <br>
   	 	
   	 	
   	 	<br>
   	 	
   	 	<h4>Differences between GET  &amp; POST  : </h4>  
   	 	<table border="2" bgcolor="yellow" width="99%" style="font-size: 25">
   	 	<tr><th>GET</th><th>POST</th></tr>
   	 	
   	 	<tr>
   	 			<td>If we are expecting information from server , then we should go for GET .</td>
   	 			<td>If we want  to post huge information to server  , then we should go for POST . </td>
   	 	</tr>
   	 	<tr>
   	 			<td>Usually read operation will be performed. </td>
   	 			<td>Write &amp; update  operators will be performed .</td>
   	 	</tr>
   	 	<tr>
   	 			<td>Client data will be appended  to url  in the form of Query-String .</td>
   	 			<td>Client data will be encapsulated in request body .</td>
   	 	</tr>
   	 	<tr>
   	 			<td>We can't send sensitive  information . </td>
   	 			<td>We can  send sensitive  information .</td>
   	  </tr>
   	 	<tr>
   	 			<td>We can send  only  limited information.</td>
   	 			<td>We can send  Huge  information.</td>
   	 </tr>
   	 	<tr>
   	 			<td>We can send  only  text data.</td>
   	 			<td>We can send  text &amp; binary  data.</td>
   	 	</tr>
   	 	<tr>
   	 			<td>Bookmarking is  possible .</td>
   	 			<td>Bookmarking is not- possible .</td>
   	 	</tr>
   	 	<tr>
   	 			<td>GET requests are Idempotent &amp; Safe.</td>
   	 			<td>POST requests are not-Idempotent &amp; not-Safe.</td>
   	 	</tr>
   	 	<tr>
   	 			<td>Multiple  ways to send  GET request.</td>
   	 			<td>Only one  way   to send  POST request.</td>
   	 	</tr>
   	 	</table>
   	 	<br>
   	 	
   	 	<h2 id="head">HEAD :</h2>
   	 	<ul>
   	 	<li>We can use this method to get only  response header information like content type , content length , last modified date  etc., but  no response body i.e., head request  retrives always  respone header but not response body.</li>
   	 	<li>For HEAD request , internally doGet( ) will be executed. HEAD request is part of GET request. </li>
   	 	<li>HEAD  requests are  Idempotent &amp; Safe. </li> 
   	 	</ul>
		
		
<pre>
HEAD request -----&gt;  doHead { 
                        doGet { 
                            take only header part of GET response and 
                             provide that as response to  HEAD request. 
                         } 
                      }  
</pre>		
		
   	 	

   <br>
   
  <h2 id="option"> OPTIONS :</h2>
   <ul>
   <li>This method is for getting supporting  http  methods to retrive a perticular resource  from the Server side . </li>
   <li>OPTIONS method is Idempotent and Safe. </li>
   <li><b>Note:</b> HEAD response is the part of GET  response  and  OPTIONS is the part of  HEAD  response .</li>
   </ul>
   <img src="mode/mod7.png" width="300" height="300">
   <h5>response from OPTIONS method  request :</h5>
 <b >  Http 1.1 | 200 |  OK</b>
<pre>
Host : www.jobs4times.com
Server : Apache
Date : Fri, o8 Nov
Allow : OPTIONS , HEAD , GET , POST
Content length : 0
</pre>
   <br>
   
   <h2 id="put">PUT :</h2>
   <ol>
   <li>We can use PUT method for placing a resource at Server side where  the location is specified by URL. </li>
   <li>At the specified location , if already another resource  present then the old resource is replaced  with provided new  resource . </li>
   <li>By means of  status code we can identify whether replacement is happend or not . </li>
   <li>200  means replacement happen , 201 means replacement not happen.</li>
   <li>PUT method is Idempotent  but not  Safe . </li>   
   </ol>
   
 <h2 id="delete">  DELETE :</h2>
   <ul>
   <li>We can use this method for deleting a perticular resource from Server side. It is exactly  counter part of  PUT  method. </li>
   <li>DELETE  is  Idempotent ,  but  not-Safe. </li>
   </ul>
 <b>  Note:</b> As the PUT  &amp; DELETE methods are not safe. Most of the web-servers  won't allow  these methods by default.<br>To allow these methods at  server side some configuration  changes are  required.<br>

<br>
<h2 id="trace">TRACE :</h2>
We can use this method for debugging purposes. If we want to know what request , server getting exactly as response, then we should go for TRACE  method. <br>
TRACE  method is Idempotent   and  Safe. <br>
<br>

<br>

<table border="2" bgcolor="yellow" style="font-size: 25" width="99%">
<tr align="center">
		<th>Method</th>
		<th>Is  Idempotent ?</th>
		<th>Is  Safe ?</th>
</tr>
<tr align="center">
		<td>GET</td>
		<td>Yes</td>
		<td>Yes</td>
</tr>
<tr align="center">
		<td>POST</td>
		<td>No</td>
		<td>No</td>
</tr>
<tr align="center">
		<td>HEAD</td>
		<td>YES</td>
		<td>YES</td>
</tr>
<tr align="center">
		<td>OPTIONS</td>
		<td>Yes</td>
		<td>Yes</td>
</tr>
<tr align="center">
		<td>PUT</td>
		<td>Yes</td>
		<td>No</td>
</tr>
<tr align="center">
		<td>DELETE</td>
		<td>Yes</td>
		<td>No</td>
</tr>
<tr align="center">
		<td>TRACE</td>
		<td>Yes</td>
		<td>Yes</td>
</tr>
</table>
<b>Note : </b>
The only non-idempotent  method  is POST . <br>
The following  methods   are  not  safe :  POST , PUT  ,  DELETE . <br>
<br>
<br>



















 
<h2 id="httpserv" style="background-color: rgb(0, 50, 0);"><u>HttpServlet </u>:</h2>

We can use HttpServlet class  as a  base class to  develop Http  based  Servlets. <br>
It  is  the child class of  GenericServlet. <br> 
For every  Http method  XXX , HttpServlet  class contains the corresponding  doXxx()  methods. <br><br>

<table bordercolor="red" border="2" style="font-size: 25"><tr><th> <font color="#008000">protected void doXxx() throws  ServletException, IOException</font> </th></tr></table> <br><br>
 
<h5>Ex: </h5>protected  void doGet(HttpServletRequest  request , HttpServletResponse response ) throws  ServletException, IOException <br><br>
doGet( ), doPost( ), doHead( ), doOption( ), doPut( ), doDelete( ),doTrace( ) . <br><br> 
 
<h5>HttpServlet  contains  2  service( )  methods. </h5>
<ol>
<li>public  void service(ServletRequest  request , ServletResponse response ) throws  ServletException, IOException </li>
<li>protected  void service(HttpServletRequest  request , HttpServletResponse response ) throws  ServletException, IOException </li>
</ol> 
  <img src="mode/mod8.png" ><br>
<strong>Ex:</strong>  Demo program for HttpServlet. <br>
<h6>
login.html</h6>We can use this  to send  post request to the server

<pre>
&lt;html&gt;
  &lt;body&gt;&lt;h1&gt;This is HttpServlet Demo&lt;/h1&gt;
    &lt;form action="/scwcd1c/test"  method="post"&gt;
     Enter Name : &lt;input type="text" name="uname" &gt;
     &lt;input type="submit"&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>



<h6>FirstServlet.java</h6>

<pre>
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class FirstServlet  extends HttpServlet {	
public void doGet(HttpServletRequest request, HttpServletResponse response)
	                               throws ServletException, IOException {      
		PrintWriter out=response.getWriter();
		String name=req.getParameter("uname");
		out.println("Hello"+name+"Good Morning , This is doGet method");
}
public void doPost(HttpServletRequest request, HttpServletResponse response)
	                               throws ServletException, IOException {      
		PrintWriter out=response.getWriter();
		String name=req.getParameter("uname");
		out.println("Hello"+name+"Good Morning , This is doPost method");
}	
}

</pre>

<h6>web.xml</h6>

<pre>
&lt;web-app&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;servlet-class&gt;FirstServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
 
 &lt;servlet-mapping&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/fs&lt;/url-pattern&gt;
 &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>

<h6>Deployment Structure  :</h6>
<br>
<img  src="mode/mod9.png">
<br>








 
<h2 id="lifehrequest"><u>Life Cycle of  HttpRequst :</u></h2>

<ol>
<li>When ever  we are  submitting the  form ,  browser prepares HttpRequest  and send to the Server. </li>
<li>Webserver  checks whether the request is for static or for dynamic information, by using URL. </li>
<li>If the request is for  static information , webserver provide required response. </li>
<li>If the request is for dynamic information , then webserver forwards that request to web-container. </li>
<li>Webcontainer identifies the corresponding matched servlet by using  web.xml </li>  
<li>Webcontainer checks whether the corresponding  Servler object is already  available or  not . If it is not already available , then  webcontainer  loads  the corresponding  .class  file and perform instantiation by  executing public   no argument  constructor . </li>
<li>After instantiation ,  immediately  webcontainer creates  the  ServletConfig  object and  invoke init( )   by  passing that config object as argument. </li>
<li>Webcontainer  creates ServletRequest  and  ServlerResponse  object and  by passing  those  as  arguments , It will invoke public service( ).  </li>
<li>With in that service( ) , request and response objects will be type casted into HttpServletRequest  and  HttpServletResponse     and invoke  protected  service( )  by  passing  those as arguments. 
<pre>
public  void service(ServletRequest  req , ServletResponse res ) 
                        throws  ServletException, IOException  {  
HttpServletRequest req=(HttpServletRequest)req ; 
HttpServletResponse res=(HttpServletResponse)res ;
service(req1 , res1);  
}
</pre>
</li>
 <li>With in the  protected service( )  we will identify HttpRequest method  and  corresponding  doXxx( ) will be  invoked. If it is not a valid Http method then it is method will return 501 status code response saying  invalid Http method .
<pre>
protected void service(HttpServletRequest request,HttpServletResponse response)
                                         throws  ServletException, IOException{
 	String method=request.getMethod( ) ; 		
 	if(method.equals("GET")) { 
 		doGet(req , res) ;		
 	}		
 	else if(method.equals("POST")) {			
 		doPost(req , res) ;		
 	}		
 	else if(method.equals("HEAD")) {	
 		doHead(req , res) ;		
 	}		
 	..........................	
 	.........................	
 	else {		
 	 prepare response with 501 Status code saying Invalid Http Method.
 	}
  }
</pre>
 </li>
 <li>If our Servlet class contain required doXxx( ) ,  then it  will be  executed . Otherwise  parent class  doXxx( )  will be  executed. </li> 
</ol> 
 
<font color="#FFFFFF" style="background-color: rgb(128, 128, 64);"><strong>NOTE : 
</strong></font><ol>
<li>For every web application, web container creates one ServletContext object at the time of application deployment. </li>
 <li>For every Servlet , web container creates one ServletConfig object  just before calling init( ). </li>
 <li>For every request web container creates one ServletRequest and one ServletResponse  objects just before calling service( ) . Once service( ) completes  both request and response objects will be eligible for Garbage Collector(GC). </li>
 </ol>

<br>

<ul>
<li><font color="#8000ff"><u><em><strong>Case 1 :</strong></em></u></font>     If we are writting public service( ) in our Servlet , then for any type of request [GET or POST] only  service( ) will be executed. </li>
<li><font color="#8000ff"><u><em><strong>Case 2 :</strong></em></u></font>  If our Servlet contains both  public service( ) and protected service( ) ,  then for  every request only public  service( )  will be executed. </li>
 <li><strong><font color="#8000ff"><u>Case 3 :</u></font> </strong>If our Servlet contains both service( ) and doGet( ) , then for any request  including  GET , only service( ) will be executed. And there is no chance of executing doGet( ).  
 <br>
<b> Note:</b> It is never recommended to place  service( )  in our Servlet. i.e., defining service( )  in our  Servlet  is  stupid kind of activity. 
 </li>
 <li><u><font color="#8000ff"><em><strong>Case 4 :</strong></em></font></u> If we are sending get request , but our Servlet doesn't contain doGet( ) , then HttpServlet doGet( ) will be executed which provides  response with 405  status code saying  Http method GET is not Supported by this url.  </li>
 <li><font color="#8000ff"><u><em><strong>Case 5 :</strong></em></u></font> If we are sending post request , but our servlet doesn't contain doPost( ) , then HttpServlet doPost( ) will be  executed , which provide 405 status code saying     Http method POST is not Supported by this url. </li>
 <li><em><strong><font color="#8000ff"><u>Case 6 :</u></font> </strong></em><font color="#008080"><strong>HttpServlet class doesn't contain  any abstract method , still it is declared as abstract class  what is the reason ? </strong></font><br>
 						For majority methods in HttpServlet , proper implementation  is not  available and these are just to send error  information . <br>
 						Hence if we are creating HttpServlet  object  directly and calling these methods , we will get just error information , with that we can't do  anything. <br>   To prevent instantiation  of HttpServlet , Sun  people declared HttpServlet class as  abstract . </li>
 <li><font color="#8000ff"><u><em><strong>Case 7 :</strong></em></u></font> To  provide same response for both GET and POST   request , we have  to  implement  doGet( )  and doPost( ) as follows .<br> 
 	<br>  
 	<strong>Ex:</strong> 
	
<pre>
public class FirstServlet extends HttpServlet {
public void doGet(HttpServletRequest request,HttpServletResponse response)
                                    throws ServletException, IOException {
		  // implemented required information  		  
}  
public void doPost(HttpServletRequest request,HttpServletResponse response)
                                     throws ServletException, IOException {
 			doGet( ) ;	  
}  
} 
</pre>
 </li> 
 <li><font color="#8000ff"><u><em><strong>Case 8 :</strong></em></u></font>  In our Servlet , It is not recommended to override the following  methods . Because these methods are  properly implemented inside HttpServlet.  <br>
 					<ol>
 					<li>service(ServletRequest request, ServletResponse response)</li>
 					<li>service(HttpServletRequest request, HttpServletResponse response) </li>
 					<li>doHead( ) </li>
 					<li>doOptions( ) </li>
 					<li>doTrace( ) </li>
 					</ol>
 </li>
 <li><em><strong><font color="#8000ff"><u>Case 9 :</u></font> </strong></em>In our Servlet , it is highly  recommended   to override  the following  methods ,  because  these methods doesn't  have proper implementation in HttpServlet. <br>
 		<ol>
 		<li>doGet( ) </li>
 		<li>doPost( ) </li>
 		<li>doPut( ) </li>
 		<li>doDelete( ) </li>
 		</ol>
 </li>
 <li><font color="#8000ff"><u><em><strong>Case 10 :</strong></em></u></font> To provide response to HEAD request ,  we have to  override  either doHead( )  or doGet( ) , otherwise we will get  405  status code  saying  Http method GET is not supported by this url. </li>
 </ul>

<hr style="background-color: rgb(0, 255, 64);">

<h2  id="hrequest"  style="background-color: rgb(0, 123, 64);">HttpServletRequest :(I) </h2>
Using  HttpServletRequest , write code to 
<ol>
<li>Retrieve Form  parameters 
<ol><li>getParameter( )</li><li>getParameterValues( )</li><li>getParameterNames( ) </li><li>getParameterMap( ) </li>  </ol> </li>

<li>Retrieve request Headers <ol><li>getHeader( )</li><li>getHeaders( )</li><li>getHeaderNames( )</li><li>getIntHeader( )</li><li>getDateHeader( )</li>  </ol> </li>

<li>Retrive Cookies  <ol><li>getCookies( )</li>  </ol> </li>
</ol> 
		 
 
	<h3 id="rpara" > <u>Retrieve Form  parameters  :</u></h3> 
	<ul>
	<li>Form parameters are  key-value  pairs , where  both key  and  values are  String  objects only. </li>
	<li>A parameter can be associated  with either a  single value  or  with  multiple  values.</li>
	<li>ServletRequest interface defines the following methods to retrieve  Form  parameters at  server  side .<br>
			<ol>
			<li>getParameter( ) </li>
			<li>getParameterValues( ) </li>
			<li>getParameterNames( ) </li>
			<li>getParameterMap( ) </li>
			</ol>
	</ul>		    
    <br>
    
    <ol>
    <li> <font color="#0000ff"><font color="#ff0000"><strong>getParameter( ) :</strong></font><br></font>
    <table border="2" bordercolor="red" style="font-size: 25"><tr><td>public String getParameter(String pname )</td></tr> </table>
    
    <ul>
    <li>    It returns the  value associated with  specified parameter.  </li>
    <li>If the parameter associated  with multiple values  then this method simply returns only  first value. </li>
    <li>If the specified parameter  not available  then we will get null argument is case-sensitive .
    <pre>String user=request.getParameter("uname");</pre>
     </li>     
    </ul>
    </li>
   
    <li>  <font color="#ff0000"><strong>getParameterValues( ) 
   </strong></font><table border="2" bordercolor="red" style="font-size: 25"><tr><td>public   String[ ]   getParameterValues(String  pname )</td></tr> </table>
    <ul>
    <li>It  returns  all  values  associated  with  specified  parameter. </li>
    <li>If the parameters not available , we will get null . </li>
    <li>Argument is Case-Sensitive.</li><li>&nbsp;Ex:
	<pre> 
    String[ ]  course=request.getParameterValues(&quot;course&quot;);
    for(String s:course)  {
    out.println(s);
    }</pre> 
    </li>    
    </ul>
    </li>
    
    <li> <strong><font color="#ff0000">getParameterNames( ) 
    </font></strong><table border="2" bordercolor="red" style="font-size: 25"><tr><td>public   Enumeration   getParameterNames( )</td></tr> </table>
    <ul>
    <li>Returns all Form parameters names. </li>
    <li>If the request is not  associated  with  any  form parameters. Then we will get empty  enumeration object but not null. <br><br>
    Ex:
	<pre>Enumeration e= request.getParameterNames( ) ;
    	while(e.hasMoreElements( ) {
    	 String pname=(String)e.nextElement( ) ;
    	 String pvalue=request.getParameter(pname);
		 out.println(pname+" "+pvalue);
		 }
   </pre>
     </li>    
    </ul>
     </li>
     
     <li><strong><font color="#ff0000">getParameterMap( ) 
     </font></strong><table border="2" bordercolor="red" style="font-size: 25"><tr><td>public   Map   getParameterMap( )</td></tr> </table>
     <ul>
     <li>Returns the map object  containing parameter names as keys and parameter values as map values. </li>
     <li>Keys are  strings  and  values are  string[ ] .</li>
     <li>If the request doesn't  associated with any parameters , this  method  returns empty  map object , but not null. <br>
     <br>
     <table  border="2" bordercolor="red" style="font-size: 25" width="90%">
     <tr><th>key(String)</th> <th>value(String[ ]) </th>    </tr>
     <tr><td>subject</td><td>{SCJP , SCWCD }</td></tr>
      <tr><td>user</td><td>{ arun  }</td></tr>
       <tr><td>..........</td><td>...........</td></tr>
        <tr><td>----------</td><td>---------</td></tr>
     </table>
     </li>     
     </ul>
   
     
     <br>
     Ex:
	 <pre>    
     Map  m = request.getParameterMap( ) ;
     for(Object  o : m)  {
     Map.Entry  m1=(Map.Entry) o;
     String pname=(String)m1.getKey( );
     String[ ]  pvalue=(String[])m1.getValue() ;
     out.print(pname+"......." );
     
     for( String s1 : pvalue ) {  
     out.println(s1 + "  , ");  
     } 
     out.println("   ");   
     }
	 output :
	 subject .....SCJP , SCWCD
	 user.......arun
	 </pre>
     </li>
    </ol>
Example :

<pre>
Map m=req.getParameterMap();
Set keySet=m.entrySet();
Iterator itr=keySet.iterator();
while(itr.hasNext()) {
Map.Entry  entry=(Map.Entry)itr.next();
String pname=(String)entry.getKey();
out.println(pname);
String[] pvalues=(String[])entry.getValue();
out.println(pvalues);
</pre>


Example  :
<pre>
public void doPost(..).. {
response.setContentType();
PrintWriter pw=res.getWriter();
out.println("<!--<html><head><title>Form  Parameters Demo--><!--</title></head><body> </body></html>-->");
out.println("name :"+ request.getparameter("uname"));
............
............
}
</pre>

	
     
     <br>
     
     <h3 id="rheader" ><u>Retrieving  Request  headers :</u></h3>
     <ul>
     <li>For every request browser  sends its configuration information  in the form of request headers. These may include the media types accepted by  browser , encoding  types supported by browser the type of browser etc. </li>
     <li>Server uses these request headers  to  send  customized  responses  to the  client. </li>
     </ul> 
      
   <h6>  <strong>The following are some of the important  request  headers. 
     </strong></h6><ol>
     <li><strong><font color="#8000ff">Accept :</font></strong><br>media types  accepted by  browser.[ like   txt/html , pdf , ppt , jar ]  </li>
     <li><strong><font color="#8000ff">Accept-Encoding: </font></strong><br> Encoding  types supported by  browser. </li>
     <li><strong><font color="#8000ff">User-agent: </font></strong><br> It  represents the type of the browser. </li>
     <li><font color="#8000ff"><strong>Content-length: </strong></font><br>It represents  the length  of request body. </li>
     <li><strong><font color="#8000ff">Cookie : </font></strong><br>Used to  send cookies  for Session managament. </li>
     </ol>  
      
   <h6>  <strong>Utilities of  Request headers : </strong></h6>
     <ol>
     <li>By using Accept-Encoding  request header at Server side we can identity whether browser supports compression from or  not. </li>
     <li>If browser supports compressed form , we can send response in compressed form. So that  we can save  download time and  bandwidth. </li>
     <li>By using User-agent request  header at server side we can identify the type of browser which sends the request. Based on that we can send  browser compatable  customized responses. </li>
     <li>By using Cookie request header we can send Cookie  to the server so that  we can  achieve session  management. </li>
</ol> 
     <h5> 
    HttpServletRequest  defines the following  methods to  retrieving header information at  server side </h5>
     <ol>
    <li><strong><font color="#ff0000">getHeader( )  
       </font></strong><table  border="2" bordercolor="red" style="font-size: 25"> <tr><td>public String getHeader(String hname)</td></tr> </table>
		     <ul>
		     <li>It returns the value  associated with specified request header. </li>
		     <li>If the header associated  with  multiple  values  then  this  method returns only 1<sup>st</sup>  value .</li><li> If  the specified request header is not available  then we will get null. </li>
		     <li>Argument is  not-case sensitive . </li>
		     <li>Ex:
<pre>
String  hvalue=request.getHeader("accept");

output :
accept -- text/html , application/xhtml+xml , application/xml ;
</pre> </li>
		     </ul>
	</li>
	<li><font color="#ff0000"><strong>getHeaders( ) </strong></font><br>
	<table  border="2" bordercolor="red" style="font-size: 25"> <tr><td>public Enumeration getHeaders(String hname)</td></tr> </table>
			<ul>
			<li>Returns all values associated with specified header . </li>
			<li>If the specified header not available ,  then this  method returns empty Enumeration object, but not null.</li>
			<li>Argument is not-case sensitive . </li>
			</ul>
</li>
<li><font color="#ff0000"><strong>getHeaderNames( ) </strong></font><br>
		<table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public Enumeration getHeaderNames( )</td></tr> </table>
		Returns all request  header  names   associated with that request object. 
<br>
<br>

HttpServletRequest defines the following more convinient methods to retrive int and date  values(Headers) directly .
</li>

<li><font color="#ff0000"><strong>getIntHeader( ) 
</strong></font><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public int getIntHeader(String  hname);</td></tr> </table>
Ex:
<pre>
String length=request.getIntHeader("content-length");
int l=Integer.parseInt(length);
  (OR)
int l=request.getIntHeader("content-length");
</pre>
If the specified request header is not associated  with int value , then this method returns NumberFormatException. 

<pre>
req.getIntHeader("user-agent");//RE:java.lang.NumberFormatException
</pre>
If the specified request header  is   not  available in getIntHeader() , this method returns "-1" but  not null.
</li>

<li><font color="#ff0000"><strong>getDateHeader( ) 
</strong></font><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public  long  getDateHeader(String  hname);</td></tr> </table>
<ul>
<li>Returns the date value associated with specified  header as no. of  milliseconds  Since Jan 1<sup>st</sup> 1970. </li>
<li>If we pass  these milliseconds  as  arguments  to  Date  constructor. We  will get exact date<br>
Ex:
<pre>
long l=request.getDateHeader("date");
Date  d=new Date(l);
</pre>
</li> 
<li>If the specified header is not  associated  with the date , then we  will  get  RuntimeException  saying  IllegalArgument Exception. </li>
<li>
If the specified request header is not available in getDateHeader() , this method returns "-1" but not null. </li></ul></li>
</ol>

<h6>
Write a  Servlet  to  print all request-headers associated  with the request.</h6>
<strong>EX:</strong>
<pre> 
public class  ReqHeader   extends  HttpServlet { 
public  void doGet(HttpServletRequest request,HttpServletResponse response)
                                     throws ServletException, IOException {
PrintWriter out = response.getWriter( ) ; 
Enumeration e = request.getHeaderNames( ) ;
while(e.hasMoreElements( ) ) {
	String hname=(String)e.nextElement( ); 
	String hvalue=request.getHeader(hname); 
	out.println(hname+&quot;------&quot;+hvalue);
	 }
 } 
}
</pre> 
 


    
<h3 id="rcookie" ><u>Retriving Cookies from the request :</u></h3>
<ul><li>HttpServletRequest  interface   defines the  following methods to retrive  cookies  from  the  request object . <br>
				Cookie[]  c = request.getCookiees( ) ;
</ul>
<img src="mode/mod10.png" width="892"><br>
    
    <h4 id="client">Retrieving client &amp; Server  information from the request :</h4>
    
    ServletRequest interface  defines the following  methods to retrieve  client and server  information  from request. 
    <ol>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public String  getRemoteHost( )</td></tr> </table>   Returns fully qualified name of the client which  sends the request. </li>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public String  getRemoteAddr( )</td></tr> </table> Returns IP-address  of the client . </li>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public String  getRemotePort( )</td></tr> </table>  Returns  the port no. on which the client is  running . </li>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public String  getServerName( )</td></tr> </table> Returns  the  name  of the Server to which the  request has been  sent . </li>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public String  getServerPort( )</td></tr> </table> Returns  the  port no. on which server is running . </li>
    </ol>
    
    <br><br>
<strong>A  request triggered from   www.jobs4times.com with  an IP-address 192.168.203.32  running on port 1012. Place the appropriate ServletRequest methods to their corresponding values.</strong><br><br>

<img src="mode/mod11.png"><br><br>
    <h2  id="hresponse"  style="background-color: rgb(0, 25, 0);"><font color="#FFFF00">HttpServletResponse :</font></h2>
    By using  HttpServletResponse  interface , write code  
    <ol>
    <li>To set Response Headers .
	<!--<ol type="i"><li>addHeader( )</li><li>setHeader( )</li><li>addIntHeader( )</li><li>setIntHeader( )</li><li>addDateHeader( )</li><li>setDateHeader( )</li>	</ol>	-->	</li>
    <li>To set content type of Response . <!--<ol type="i"><li>response.setContentType("text/html");</li><li>response.setHeader("content-type" , "text/html");</li>	</ol>-->	</li>
    <li>To acquire  text stream for response. <!--<ol type="i"><li>response.getWriter( );</li>	</ol> -->    </li>
    <li>To acquire binary stream for response .<!-- <ol type="i"><li>response.getWOutputStream( );</li>	</ol>--></li>
    <li>To redirect the  request  to  another URL . <!--<ol type="i"><li>response.sendRedirect("/test2" );</li><li>	response.setStatus(302);</li><li>response.setHeader("location" , "/test2");</li>		</ol>--> </li>
    <li>To add  cookies  to  response. <!--<ol type="i"><li>response.addCookie(c );</li>	</ol>--> </li>
    </ol>
    
    <h3 id="reheader"  style="background-color: rgb(255, 1 , 0);"><font color="#FFFFFF"><u>Setting  HttpResponse Headers :</u></font></h3>
    <ul>
    <li>Http  response header  describes the  configuration  information  of the server and  information about the response  like content-type , content-length , last modified data etc., </li>
    <li>Browser using these  response  headers  to display  response  body properly  to the  end   user. </li>
   </ul> 
     
    <strong>HttpServletResponse defines  the following  methods to add headers to the  response .  
</strong><ol><li>
    		<table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void addHeader(String hname , String hvalue )</td></tr> </table>
    		<ul><li>If the specified  header  name is already  available , to the existing values , this new value  will also  be  added. </li><li>Replacement  will not  Occur .</li></ul></li>
    <li><table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void setHeader(String hname , String hvalue )</td></tr> </table>
    			<ul><li>If the specified header is already available . Then  the old  value will be replaced with new value .</li></ul><br>Some times headers  associated with  int &amp; date values .
    </li>
    <li>	public void addIntHeader(String hname , int  hvalue ) </li>
    <li>public void setIntHeader(String hname , int  value ) </li>
    <li>public void addDateHeader(String hname , long ms ) </li>
    <li>public void setDateHeader(String hname , long ms ) </li>
</ol>  
   <strong>Note:</strong><br>
   If the header associated  with  multiple  values . Then  we have to  use  addHeader( ) <br>
   If the header   associated  with  only  one  value , then we should go  for  setHeader( ) <br>
   
 <br> 
  
 <h3 id="recontent" ><u> Set Content type of  Response : </u> </h3>
 Content type header  represents MIME  type (multipurpose internet mail extension)  of the  response.
 <h5>
 Common MIME  Types :</h5>
 <ol>
 <li>text/html 		--------&gt; Html text as  response </li>
 <li>text/xml    		--------&gt; xml document  as  response </li> 
 <li>image/jpeg			--------&gt; JPEG as  response  </li>
 <li>image/png    		--------&gt; png as  response </li>
 <li>application/ms-excel    		--------&gt; excel  sheet  as  response </li> 
 <li>application/ms-word    		--------&gt; word document  as  response </li>
 <li>application/pdf 		--------&gt; PDF file  as  response  </li>
 <li>application/jar    		--------&gt; jar file  as  response </li>
 </ol> 
  
 <strong>We can set  MIME  type  by using the following  2 ways   
  
 </strong><ol>
 <li><b>By ServletResponse interface : </b><br>It contains the following method to set the response.	 <table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void setContentType(String   mimeType)</td></tr> </table> Ex:<pre>response.setContentType("application/PDF")</pre>	</li>
 <li><b>By HttpServletResponse interface : </b><br>It contains setHeader( )  to set  content type.<table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void setHeader(String   hname , String  hvalue)</td></tr> </table> <br>Ex:<pre>response.setHeader("content type" , "text/html");  </pre> Note: In general response.setContentType( ) is recommended to use.  </li>
 </ol>
    
 <br> 
 <h3 id="restream" > <u><strong>To  acquire  text  stream  for the  response :  
 </strong></u> </h3><ol>
 <li>We can send text data as the response  by using PrintWriter object .</li>
 <li>We can get PrintWriter  object  by using  getWriter( )  of  ServletResponse . 
 		<table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public PrintWriter  getWriter( )  throws  IOException</td></tr> </table> 
 		<strong>Ex:</strong><pre> PrintWriter  out = response.getWriter( ) ;</pre> 
 </li>
 </ol> 
  
 <h3 id="rebinary" ><u><strong> To  acquire  Binary stream  as response :  </strong></u></h3><u><strong>
 </strong></u><ol>
 <li>We can send Binary  information(video , image  files)  by using   ServletOutputStream  object. </li>
 <li>By  using  getOutputStream( )  of  ServletResponse  we can get  this object . 
 <br>
 <table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public ServletOutputStream  getOutputStream( )   throws  IOException</td></tr> </table> 
 <strong>Ex: </strong><pre>ServletOutputStream  sos=response.getOutputStream ( ) ;</pre>
 </li>
 </ol>
 
 <hr>
<pre>
 Demo   program  to send image  file as  response  to the client
 
 import javax.servlet.*;
 import javax.servlet.http.*;
 
 public class BinaryStream extends HttpServlet  {
 	public void doGet(HttpServletRequest request,HttpServletResponse response)
	                                      throws ServletException,IOException{
 	response.getContentType("image/jpeg");
 	ServletOutputStream sos = response.getOutputStream( ) ;
	
	//File  f= new File("c:\\tomcat\sunset.jpeg");
	
 	String path=getServletContext( ).getRealPath("sunset.jpeg"); 	
 	File  f= new File(path);
 	FileInputStream fis=new  FileInputStream(f);
	
 	byte[]  b=new byte[(int)f.length()];  
	             //f.length()  returns long  so we have to convert into int.
			   //[] --&gt; accepts int only
	
	
 	fis.read(b);        //reading the image &amp; place into byte[]
 	sos.write(b);       //write byte[] to response
 	sos.flush( );
 	sos.close( );
 	}
 }
 </pre> 
<hr> 
<h6>To  send XML data as a response :</h6>
<pre>
response.setHeader("content-Type","text/xml");
PrintWriter out=response.getWriter();
out.print("&lt;?xml version=\"1.0\"?&gt;");
out.print("&lt;greeting language=\"en_US\"&gt;");
out.print("hello world");
out.print("&lt;/greeting&gt;");
</pre>
<hr>
<strong>Note :</strong> 
<br> At  any point of time  we  can get either PrintWriter  object  (or) ServletOutputSteram object  but not both ,  simultaneously. 
<br> Otherwise  we will get  RuntimeException saying IllegalStateException  <br> Because from the Servlet we can send  only one response  at  a time.  
 
<pre>
public void doGet( )  {
	PrintWriter out=response.getWriter( );
	ServletOutputStream sos =response.getOutputStream( ) ;
	-----------
	-----------
	}
	</pre> 
	<strong>Output:</strong> RuntimeException  saying <strong>IllegalStateException</strong>  getWriter( ) has already  been called  for this response.<br><br><font color="#ff0000"><strong><font color="#0000ff">&nbsp;IIQ:</font>By using which of the following stream  we can  send both binary &amp; text data  as response from the Servlet ? 
		</strong></font><ol>
		<li>PrintWriter(<img  src="scjp/WebRoot/wrong.html">)</li><li>ServletOutputStream (<img src="scjp/WebRoot/fileio/image003.html">)</li><li>ServletInputStream (<img  src="scjp/WebRoot/wrong.html">)</li><li>None of the above (<img  src="scjp/WebRoot/wrong.html">)</li>
</ol> 
     
     
 <h3 id="reredirect"><font color="#FFFFFF"><u><strong>Re-directing  HttpRequest to   another  url : </strong></u></font></h3>
  
<img src="mode/mod12.png"><br>
  
<br>Forward &amp;  include should work when both servlets  should be  in  same  server . <br>
Some times we have to re-direct  the request to  another url  we  can  achieve  this by using  sendRedirect( )  of  HttpServletResponse .
<table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void sendRedirect(String targetpath)  throws  IOException</td></tr> </table> 
 
 
<br><h5>Process of  send Redirection : 
</h5>
<img src="mode/mod13.png"><br>
<ol><li>Browser  sends  request to Servlet1 </li>
<li>If  servlet1 is not  responsible to  provide response , then it will  update  browser  to contact  servlet2. This can be informed by  setting status code 302 &amp; location header  with servlet2.</li>
<li>Browser by  seeing status  code 302  creates a  new request object &amp; sends  to  Servlet2. </li>
<li>Servlet2  provides desired response to the browser &amp; the browser  inturn display  that response  to the end user .</li>
</ol><h6>Demo  program for send  Re-direct  :</h6>
<pre>
public class FirstServlet  extends   HttpServlet {
public void doGet(HttpServletRequest request,HttpServletResponse response)
                                     throws ServletException, IOException {
	response.sendRedirect("test2");
					(or)
	response.setStatus("302");
	response.setHeader("location" , "scwcd/test2");
}
}
</pre>
<pre>
public class SecondServlet  extends   HttpServlet {
	public void doGet(HttpServletRequest request,HttpServletResponse response)
                                        throws ServletException, IOException {
		PrintWriter out=response.getWriter( );
		out.println("2nd  Servlet ");
		}
 }
</pre>

 
 <ul>
 <li>When ever we are sending request to FirstServlet , SecondServlet  will provide the  response  through re-direction</li>
 <li>After committing the response we are not  allow to perform re-direction. Otherwise we will get RuntimeException saying IllegalStateException(Tomcat  people doesn't  provide support for this).</li>
 </ul>
<pre>
public void doGet(HttpServletRequest request,HttpServletResponse response)
                                     throws ServletException, IOException{
-----------------
---------------------
out.flush();	//committing the response
response.sendRedirect("/test2");	//RE:IllegalStateException
}
</pre>

Applicable for forward also. <br>


<h3 id="diffredfor"><u><font color="#FFFFFF">Differences  between  send-Redirection    and   forward mechanism :  </font></u></h3>
<table border="2"  bgcolor="yellow"  width="99%" style="font-size: 25">
<tr><th>send Re-direct </th> <th>forward </th></tr>

<tr><td><img src="mode/mod13.png" width="450"></td><td><img src="mode/mod14.png" width="450"></td></tr>

<tr><td>This mechanism will work at client side. Hence client aware of which Servlet  is providing the required response.</td>
<td>This mechanism will work at server side  and it is  not visible to the client. Hence client is not  aware of which Servlet  is providing the required response.</td></tr>

<tr><td>In this approach an extra trip is required to the client  side . Hence network traffic increases &amp; effects the performence  of the system. </td>
<td>No extra trip is required to the client &amp; hence there are no network traffic &amp; performance problem.</td></tr>

<tr><td>This  is only possible mechanism to  communicate  with resoueces  which are  present outside of web-container.</td>
<td>forward mechanism  will work  with in the web-container  only and  we can't  use  this  mechanism to communicate  with  the resources  present  outside  of container.  </td></tr>

<tr><td>Seperate  new  request  object will be  created in  send Redirection .</td>
<td>Same request object  will be forwarded . </td></tr>

<tr><td>By  using  HttpServletResponse  object . we can achieve send redirection.<br/> response.sendRedirect("/test2");</td>
<td>By using Request Dispatcher object we can achieve forward mechanism . <br/> rd.forward(req , res);  </td></tr>

<tr><td>After commiting  the Response  we are not  allow to perform send  Redirection .Otherwise we will get RuntimeException saying IllegalStateException. </td>
<td>After Commiting Response , we can't  perform forward  otherwise IllegalStateException. </td></tr>

</table> 
     
    <br><h3 id="recookie"  style="background-color: rgb(0, 255, 0);"><font color="#0000ff">Adding Cookies to the response : 
    </font></h3>HttpServletResponse contains the following method to addCookie to the Response object.  
     
    <table  border="2" bordercolor="red" style="font-size: 25" > <tr><td>public void addCookie(Cookie c )</td></tr> </table> 
    <br>&nbsp;&nbsp;&nbsp;<strong> Ex: </strong><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Cookie c=new Cookie(String name , String value) ; 
    		<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; response.addCookie(c); 
     
    <br><br><br><strong>NOTE : </strong>
    <ol>
    <li>We can use redirection to communicate either with in the same server or outside the server. But recommended to use communicate outside.</li>
    <li>forward mechanism is applicable to communicate only  with in the same server . But outside of server we can't use. </li>
    <li>To communicate with in the same server we can use either forward or send redirection but  recommended to use forward. </li>
    </ol>
    
    <br><img src="mode/mod15.png" ><br>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 </td></tr></table> <a href="index-2.html"><font color="#000000"><strong>BACK</strong></font> </a> </div>
</body>

<!-- Mirrored from java.scwcd.jobs4times.com/Servlet-Technology-Model.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:11 GMT -->
</html>