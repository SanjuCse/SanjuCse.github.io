<!DOCTYPE HTML>
<html>
  
<!-- Mirrored from java.scwcd.jobs4times.com/Session-Management.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:18 GMT -->
<head>
    <title>Tutorial for servlet Session Management | Session API | Cookies | Hidden variables | URL Rewriting | Listeners | Request | Context | Session | Listeners  </title>
	
    <meta name="keywords" content=" Session Management,Session API, Creation of Session object, Invalidating a Session,
    invalidate( ),Session timeout mechanism,Important Methods of HttpSession,Attribute Management in Session Scope,
    Exchanging Session Id between Client and Server,Cookies,Important methods of Cookie class,Persistant (Vs) Non-Persistant Cookies,
    Advantages of Cookies,Limitations of Cookie,Differences between Session-API and Cookies,URL Rewriting,
    HttpServletResponse two methods to append Session id to the url,Advantage of URL Re-writing,Limitations,
    Hidden Variables, Listeners, Request Listeners, ServletRequestListener, ServletRequestAttributeListener,
    Context Listeners, ServletContextListener, ServletContextAttributeListener, Session Listeners, HttpSessionListener,
    HttpSessionAttributeListener, HttpSessionBindingListener, HttpSessionActivationListener ">
    
    <meta name="description" content="The basic limitation of Http is , Its a stateless protocol i.e., it is unable to remember client state across multiple request.
Every request to the server is considered as a new request. Hence some mechanism is required to remember client information across multiple requests. This mechanism is nothing but Session management /Session Tracking Mechanism. ">
    
    <meta name="content-type" content="text/html; charset=ISO-8859-1">
    
   <link rel="stylesheet" type="text/css" href="styles.css">
   
   
 
  
  </head>
  
  <body >
  <div align="center">
<table width="75%" border="1"> <tr><td>

 <table width="100%" cellpadding="0" cellspacing="0" border="0" >
     <tr>
<td width="50%" align="left"><a href="https://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="700" height="200">   </a> </td> 
   	<td  align="right"><a href="index-2.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> </tr>
</table>



<h1 align="center" style="background-color: rgb(0, 55, 0);"><font color="#ffff00">Session Management </font></h1>
<h2><font color="#fffff"><u>Agenda:</u></font></h2>
 
<ol>

<li><a href="#api">Session API</a>
<ul>
<li><a href="#create">Creation of Session object</a></li> 
<li><a href="#invalidate">Invalidating a Session</a> <ul>
<li><a href="#invali">invalidate( )</a></li> 
<li><a href="#time">By Session timeout mechanism</a></li></ul> </li>
<li><a href="#imphttp">Important Methods of HttpSession</a></li> 
<li><a href="#attribute">Attribute Management in Session Scope</a></li>  
<li><a href="#exchange">Exchanging Session Id between Client and Server</a></li></ul></li>



<li><a href="#cookie">Cookies</a><ul>
<li><a href="#impcookie">Important methods of Cookie class </a></li> 
<li><a href="#pervsnon">Persistant (Vs) Non-Persistant Cookies</a></li> 
<li><a href="#advcookie">Advantages of Cookies</a></li> 
<li><a href="#limitcookie">Limitations of Cookie</a></li> 
<li><a href="#diff">Differences between Session-API and Cookies</a></li> </ul> </li> 


<li><a href="#urlre">URL Rewriting</a><ul>
<li><a href="#sessionid">HttpServletResponse two methods to append Session id to the url</a></li> 
<li><a href="#advurl">Advantage of URL Re-writing</a></li> 
<li><a href="#limiturl">Limitations </a></li> </ul>  </li>


<li><a href="#hidden">Hidden Variables</a></li> 

<li><a href="#listeners">Listeners</a><ol>  

<li><a href="#reqlis">Request Listeners</a> <ol>
    <li><a href="#servreq">ServletRequestListener</a></li> 
    <li><a href="#servattribute">ServletRequestAttributeListener</a></li></ol>   </li>
    
    
<li><a href="#context">Context Listeners</a>  <ol>
<li><a href="#servcontext">ServletContextListener</a></li> 
<li><a href="#servattribute">ServletContextAttributeListener</a></li></ol>   </li>  

<li><a href="#sessionlis">Session Listeners</a> <ol> 
<li><a href="#httpses">HttpSessionListener</a></li> 
<li><a href="#httpattribute">HttpSessionAttributeListener</a></li> 
<li><a href="#httpsession">HttpSessionBindingListener</a></li>
<li><a href="#httpactivation">HttpSessionActivationListener</a></li> </ol>   </li> </ol></li> 
</ol>




   
   <br> 
   <font color="#0000ff"><strong>Objective: 
   </strong></font><ol>
   <li>For the given scenario  describe  the  Session API. </li>
   <li>Explain the process of creating  a  Session  object. </li>
   <li>What are  various  different  mechanisms  to  invalidate a  session </li>
   <li>The basic limitation of Http  is , Its a stateless  protocol i.e.,  it is unable  to remember client  state across  multiple request. </li>
   <li>Every request to the  server is considered as a new  request. Hence  some mechanism is required  to remember  client information  across multiple requests. This  mechanism is nothing but Session management /Session Tracking Mechanism.</li>
   <li><strong>The following are various Session management  mechanisms. </strong><ol>   <li>Session-API</li>   <li>Cookies</li>   <li>URL Rewriting</li>   <li>Hidden Variables <br>It is not official  Session management  from Sun. It is just  a  programmers trick  to  remember client information across multiple requests.		</li></ol>			</li>
    </ol>
 <br>

<h2 id="api">1.Session-API :</h2>
<img alt="" src="session/ses3.png"> 
<ol>
<li>When ever client  sends 1<sup>st</sup> request to the server, If the server wants to remember  client information for the future purpose then  it will create a Session object stores the  required Session information in the form of Session scoped  attributes.</li>
<li>Server sends the corresponding session-id as the part of  1<sup>st</sup> response.</li>
<li>Client saves that  Session-id  and  send back to the Server with  every  consecutive  request.</li>
<li>By accessing  Session-id  and  corresponding Session object , Server can able to  remember  client information  accross  multiple requests. This mechanism is nothing  but Session management by using Session-API. </li>
<li>In this  mechanism entire Session information  will be  stored at Server side , and only Session-id  will be  maintained by Client. <br> Ex:Bank Locker   </li> 
</ol>
<h3 id="create">Creation of Session object :</h3>
HttpServletRequest  interface  defines   the following  methods for the creation of  Session object.
<ol>
<li>	<table border="1"><tr><td>public HttpSession getSession( )</td></tr></table>
		<h5> HttpSession session=request.getSession( );</h5>
		<ul>
		<li>First this method will check  whether the request is already associated  with  any Session or not. If the request associated  with  any  session  then existing  Session object  will be returned.</li>
		<li>If the request is not associated  with  any Session , then only a  new Session object  will be  created.</li> 
		</ul>		
</li>
<li>	<table border="1"><tr><td>public HttpSession getSession(boolean b )</td></tr></table>
		<ul>
		<li>if the argument is true , then this method simply acts as getSession( )</li>
		<li>If the argument is false , then  this method first checks whether the request  is already associated  with  any Session or not, If  it is already associated with a Session , then existing Session object will be returned. </li>
		<li>If the request is not  associated  with a Session  then this method simply returns  null , without creating  new object. </li>
		<li><strong>Note:</strong> There is always  guarantee that first  method  returns a  Session  object. It may be newly created or already  existing one.</li>
		<li>There is no guarantee that getSession(false) method  will return Session object. </li> 
		</ul>
</ol>
<img alt="" src="session/ses1.png">
<ul>
<li>After providing  credentials in the  login page  the  request  will be forwarded to the ValidateServlet.</li>
<li> With in the ValidateServlet , we will check  whether the credentials  are  valid or not. If the credentials are valid , a  new Session object will be  created  and  forward  the request  to inbox.jsp , Hence  with in the Validate Servlet. We  have to use request.getSession( ) method  because we can create a new Session object , if it is not already there . </li>  
<li>To access inbox.jsp , compulsory request  should  be associated  with Session.</li>
<li>If the Session is not already there inbox.jsp  is not  responsible to create  new  Session  object   and  just simply  forwards the  request to login page.</li>
<li>Hence to meet this requirement  inside  inbox.jsp  we have to use request.getSession(false);</li> 
</ul>
<h6>Which of the two statements are  equal ?</h6>
<ul>
	<li>HttpSession session = request.getSession( ); </li>
	<li>HttpSession session=context.getSession(true);</li>
	<li>HttpSession session = request.getSession(false); </li>
	<li>HttpSession session = request.getSession(true); </li>
</ul>

Answer : 1 &amp; 4

<h3 id="invalidate">Invalidating a  Session :</h3>
We can invalidate a Session  by using  the following 2 ways
<ol>
<li>By invalidate method </li>
<li>By timeout mechanism </li>
</ol>
<h5 id="invali">1.invalidate( ) :</h5>
HttpSession  interface contains invalidate( )   to invalidate a Session explicitly.
<table border="1"><tr><td>public void invalidate( )</td></tr></table>
When ever  we click  logout  button , internally this  method will be executed.<br>
<b>Ex: session.invalidate( )</b>
<br><br><br>
LogoutServlet.java
<pre>
public class LogoutServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 HttpSession session=request.getSession(false);
 if(session!=null)
	session.invalidate();
 else
	out.println("No session is  invalidate()");
}
}
</pre>
web.xml
<pre>
&lt;servlet&gt;
  &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;session.LogoutServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/logout&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>

<h5 id="time">2.By Session timeout  mechanism :</h5>
<ol>
<li>If we are  not performing  any  operation for a predefined amount of time on the session object, then session will be expired automatically </li>
<li>This  pre-defind  amount  of time  is called "Session time out ".</li>
<li>We can configure  Session  time out  at  Server level or  a  particular  web-application  level or  for a  particular Session object level.</li> 
</ol>


<ul>
<li>
<h6>Automatic Support from the WebServer :</h6>

Most of the Web-Servers provide  default support  for Session time out mostly it is 30 minutes.  We can  customize  this  value based on our requirement. This Session  timeout  is application for all sessions , Which are created  in that  Server irrespective of application.</li>

<li><h6> Configuring  Session timeout at  application level : </h6>
<ol>
<li>
We  can configure Session timeout for entire web-application  in  web.xml  as  follows
<pre>
&lt;web-app&gt;
	&lt;session-config&gt;
		&lt;session-timeout&gt; 10 &lt;/session-timeout&gt;
	&lt;/session-config&gt;
&lt;/web-app&gt;
</pre>

</li>
<li>The session-config is direct child tag of web-app .Hence we can take any where with in  web-app  </li>
<li> The unit to the  session  timeout  is in minutes.</li>
<li>  Zero (or) negative value indicates  that  session never expires.(untill we click the logout button)</li>
<li>  This session timeout  value  is applicable for all sessions , which are created as part of web application.</li>
</ol>
</li>

<li>
<h6>Configuring Session timeout  for a particular Session object :</h6>
<ol>
<li>We can set the Session timeout  by  using  setMaxInactiveInterval( )  method for a perticular Session object.
<table  border="2"  style="font-size: 27"><tr><td>public  void setMaxInactiveInterval(int seconds)</td></tr></table>
  <b> Ex: session.setMaxInactiveInterval(120);</b>
</li>
<li>The argument  is in  seconds, -ve value indicates  session never expires, Zero value indicates  session expires immediately .</li>
<li>This session time out  is applicable only for a particular  session object on which this  method has called.</li>
</ol>
</li>

</ul>


<h2>Comparision  between  two Session timeout  mechanism :</h2> 
<table border="2"  style="font-size: 27">
<tr><th width="12%">Property</th><th width="44%">&lt;session-timeout&gt; </th> <th>setMaxInactiveInterval( )</th></tr>
<tr><td>Scope</td><td>It is applicable for all the Sessions which are  created in that application.</td><td>It is applicable only for a particular Session object on which we called this method </td></tr>
<tr><td>Units</td><td>Minutes</td><td>Seconds</td></tr>
<tr><td>Zero  value </td><td>Session never expires</td><td>Session expires  immediately</td></tr>
<tr><td>- ve </td><td>Session never  expires</td><td>Session never expires</td></tr>
</table>
 
   <h3 id="imphttp"> Important  Methods of HttpSession :</h3>
 <ol>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  booleanisNew( ) </td></tr></table>  We can use this method  to check whether  the Session object  is newly created  or  not .</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  void inValidate( )</td></tr></table> To expires a  session forcefully.</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  void setMaxInactiveInterval(int seconds)</td></tr></table> To set session  timeout  for  a particular  Session object .</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  void setMaxInactiveInterval( )</td></tr></table> It  returns the session timeout  value in seconds.</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  String getId( )</td></tr></table> Returns the  session id.</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  long getCreationTime( )</td></tr></table>  Returns the time  when  the  Session was  created in milliseconds , Since Jan 1<sup>st</sup>1970.</li>
 <li>If we are passing  this long  value to the Date  constructor , we will get exact  Date and time.<table  border="2"  style="font-size: 27"><tr><td>Date  d = new  Date( l);</td></tr></table> </li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  long  getLastAccessedTime( )</td></tr></table>  Returns  the time  when  the client  accessed recently the ............</li>
 <li><table  border="2"  style="font-size: 27"><tr><td>public  ServletContext getServletContext( ) </td></tr></table>   Returns  the  ServletContext  object   to which  this Session belongs.</li>
 </ol>

<h4 id="attribute">Methods in HttpSession  to perform  Attribute  Management in Session Scope :</h4>
<ol>
<li>public void setAttribute(String name, Object  value) </li>
<li>public  Object  getAttribute(String name )  </li>
<li>public void removeAttribute(String name) </li>
<li>public Enumeration  getAttributeNames( ) </li>
</ol>
<strong>Note :</strong>
Once session  expires  we can't  call  any  of the  above  methods , validation leads  to RuntimeException  saying "IllegalStateException".But this rule is not applicable  for  getServletContext( )  method .

<pre>
HttpSession session=reqest.getSession();
session.invalidate();
-------------------
session.isNew(); //java.lang.IllegalStateException
-------------------
out.println(session.getServletContext());  //valid
</pre>


<h6>Ex: Demo  program for Session  Management by session API</h6>

login.html
<pre>
&lt;form action="./sessionone"&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td&gt;Name :&lt;/td&gt;&lt;td&gt; &lt;input type="text" name="uname"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Value : &lt;/td&gt;&lt;td&gt; &lt;input type="text" name="value"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="submit"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;a href="./sessiontwo"&gt;Session Information&lt;/a&gt;
</pre>
SessionServletOne.java
<pre>
public class SessionServletOne extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  response.setContentType("text/html");
  PrintWriter out = response.getWriter();
  String name=request.getParameter("uname");
  String value=request.getParameter("value");
  
  HttpSession session=request.getSession();
  if(session.isNew()) {
	  out.println("New Session got created "+session.getId());
  }
  else {
	  out.println("With existing Session id : "+session.getId());
  }
   session.setAttribute(name, value);
   session.setMaxInactiveInterval(120);
   
   RequestDispatcher rd=request.getRequestDispatcher("login.html");
   rd.include(request, response);
		
}

}
</pre>
SessionServletTwo.java
<pre>
public class SessionServletTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  response.setContentType("text/html");
  PrintWriter out = response.getWriter();
  
  HttpSession session=request.getSession(false);
  if(session==null) {
	  out.println("No Session id  associated with request ");
  }
  else {
	Enumeration  e=session.getAttributeNames();
	out.println("&lt;table border=3&gt;&lt;tr&gt;&lt;th&gt;Session Attribute Name&lt;/th&gt;
	              &lt;th&gt;Session Attribute Value&lt;/th&gt;&lt;/tr&gt;");
	
	while(e.hasMoreElements()){
		String name=(String) e.nextElement();
		String value=(String) session.getAttribute(name);
		out.println("&lt;tr&gt;&lt;td&gt;"+name+"&lt;/td&gt; 
		                         &lt;td&gt;"+value+"&lt;/td&gt;&lt;/tr&gt;");
	}
	
	out.println("&lt;/table&gt;");
	
	
	out.println("&lt;br&gt;The Session creation Time is :"+
	                                new Date(session.getCreationTime()));
	out.println("&lt;br&gt;The session last accessed time is :"+
	                            new Date(session.getLastAccessedTime()));
	out.println("&lt;br&gt;The Session max inactvate interval is :"+
	                                   session.getMaxInactiveInterval());
}
  out.println("&lt;br&gt;&lt;a href=login.html&gt; login page &lt;/a&gt;");

}

}
</pre>

web.xml
<pre>
&lt;web-app&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;SessionServletOne&lt;/servlet-name&gt;
  &lt;servlet-class&gt;session.SessionServletOne&lt;/servlet-class&gt;
&lt;/servlet&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;SessionServletTwo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;session.SessionServletTwo&lt;/servlet-class&gt;
  &lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SessionServletOne&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/sessionone&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SessionServletTwo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/sessiontwo&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;session-config&gt;
  &lt;session-timeout&gt;1&lt;/session-timeout&gt;
&lt;/session-config&gt;

&lt;/web-app&gt;
</pre>

<h3 id="exchange">Exchanging Session Id   between  Client  and  Server :</h3>


<img alt="" src="#">
<ol>
<li>Whenever Client  sends 1<sup>st</sup> request  to the Sever , If any request  information is required  to remember  for  the future purpose  then server creates  a Session object  and  score  the required  information in  the form of Session scopped attributes.</li>
<li>Server sends  corresponding  session id  to the  client  as the part of  1<sup>st</sup>  response.For  this server uses "set-cookie" response header.</li>
<li>Whenever  client got  the  response , it retrives  the session id  and  stored in the  local file System.</li>
<li>With every  consecutive  request  client send back the corresponding  Session id to the server, for this client uses "cookie"  request  header.</li>
<li>By accessing  Session id  and  corresponding  Session  object  Server  can able to  remember  client  information  across  multiple requests.</li>
<li>By using set-cookie response header  and cookie  request header  session id will be exchanged between  client and server.</li>
</ol>  
<img alt="" src="session/ses3.png"> 
 <br>
Session id will be stored  as per application in the client  side.
<table border="1">
<tr><th>header</th><th>value</th></tr>
<tr><td>cookie</td><td>sid</td></tr>
</table>

<br>
Ex: Note:(Bank locker ):

<ol>
<li>If the required Session  information   is very  less than  creating  a separate  Session object  and  maintaining  that  object  at Server side is not recommended  because  it impacts  performense of the  System.</li>
<li>To  resolve this, we should go for  cookie  Session management   mechanism ,  where  required  Session   information  is maintained  at  client side  and  Server  is not responsible  to maintain  any Session information.</li>
</ol>



<h2 id="cookie">Cookies :</h2> 
<img alt="" src="session/ses2.png"> 
<ol>
<li>Cookie is a small amount  of  information  (key , value)  pair.</li>
<li>Whenever  client sends a request  to the  Server  , if any  information  required  to remember  for  future  purpose  then server  creates  a Cookie  object  with that  information  and  send that Cookie  back to the client  as the  part of  response . For, this , server uses  set-cookie  response   header.</li>
<li>Whenever  client  got the  response  it retrives  the cookies send by the  Server  and stores  those cookies in the  local file system.</li>
<li>Client sendback all the Cookies  send by the server with every consecutive  request for this client use cookie request header.</li>
<li>By  accessing  those  cookies  server  can able  to  remember  client  information across  multiple requests.</li>
<li>We can create  Cookie  object  by using  Cookie class constructor. <table  border="2"  style="font-size: 27"><tr><td>Cookie cookieobject = new  Cookie(String  key , String  value ); </td></tr></table>  </li>
<li>After  creating  the Cookie  object  we have  to  add   that  Cookie  to the  response  by  using  addCookie( ).<table  border="2"  style="font-size: 27"><tr><td>response.addCookie(cookieobject) ;</td></tr></table></li>
<li>At  server  side , we can retrive  all  cookies  send  by the  client  by  using  getCookies( ). <table  border="2"  style="font-size: 27"><tr><td>Cookies[ ]  cookieobject = request.getCookies( ); </td></tr></table> </li>
<li>If the request   doesn't associated  with  any Cookies  then  this method  returns null.</li> 
</ol>


<h3 id="impcookie">Important methods  of  Cookie class :</h3>
<ol>
<li><table  border="2"  style="font-size: 27"><tr><td>public String getName( ) </td></tr></table> This method  returns the  name of the Cookie.</li>
<li><table  border="2"  style="font-size: 27"><tr><td>public  String  getValue( ) </td></tr></table> Returns value  of  the   Cookie. </li>
<li><table  border="2"  style="font-size: 27"><tr><td>public  int  getMaxAge( )</td></tr></table> Returns  the maximum  age  of  Cookie  in seconds. </li> 
<li><table  border="2"  style="font-size: 27"><tr><td>public  void  setMaxAge(int  seconds )</td></tr></table>  To  set max  age  of  cookie.
<ol>
<li>"+ve" value indicates that cookie  will be expires  after that how many seconds  have passed.<br>Note that the  value is max age of the cookie, when the cookie  will expires , not the cookie current age. </li>
<li>"-ve"  value indicates the cookie  is not  stored permanently  and it will be deleted when browser exists/close.</li>
<li>"0" value  indicates  cookies   to be deleted.</li>
</ol></li>
</ol>

<h6>Demo  Program  for session management  by  cookies </h6>

login.html
<pre>
&lt;form action="./cookieone"&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td&gt;Name :&lt;/td&gt;&lt;td&gt; &lt;input type="text" name="uname"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Value : &lt;/td&gt;&lt;td&gt; &lt;input type="text" name="value"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="submit"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
&lt;a href="./cookietwo"&gt;Cookie Information&lt;/a&gt;
</pre>

CookieServletOne.java
<pre>
public class CookieServletOne extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
	String name=request.getParameter("uname");
	String value=request.getParameter("value");
	
	Cookie c=new Cookie(name, value);
	c.setMaxAge(120);
	response.addCookie(c);
	out.println("Cookie added Successfully");
	
	out.println("domain"+c.getDomain());
	out.println("comment"+c.getComment());
	out.println("maxage"+c.getMaxAge());
	out.println("version"+c.getVersion());
	out.println("hashcode"+c.hashCode());
	
	RequestDispatcher rd=request.getRequestDispatcher("login.html");
	rd.include(request, response);
	}

}
</pre>

CookieServletTwo.java
<pre>
public class CookieServletTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();

 Cookie[] c=request.getCookies();
 if(c==null){
  out.println("No cookies associated with this request");
 }
 else {
  out.println("&lt;table border=3&gt;&lt;tr&gt;&lt;th&gt;Cookie Name&lt;/th&gt;
                                &lt;th&gt;Cookie Value&lt;/th&gt;&lt;/tr&gt;");
		
  for(Cookie c1:c){
	String name=c1.getName();
	String value=c1.getValue();
	out.println("&lt;tr&gt;&lt;td&gt;"+name+"&lt;/td&gt;&lt;td&gt;"+value+"&lt;/td&gt;&lt;/tr&gt;");
  }
  out.println("&lt;/table&gt;");
		
  }
}

}
</pre>


web.xml
<pre>
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;CookieServletOne&lt;/servlet-name&gt;
    &lt;servlet-class&gt;session.CookieServletOne&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;CookieServletTwo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;session.CookieServletTwo&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;CookieServletOne&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/cookieone&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;CookieServletTwo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/cookietwo&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>

<h3 id="pervsnon">Persistant (Vs)  Non-Persistant  Cookies :</h3>
<table border="1"><tr><th>Persistant Cookies </th><th>  Non-Persistant Cookies </th></tr>
<tr><td><ol>
 <li>If  we set max  age  for   the Cookie , such type of Cookies  are  called "Persistant Cookies".</li>
 <li>These  cookies  will be  stored  permanently  in the  local  file system.</li>
 <li>Once  the  time  expires ,  these  Cookies  will be  disabled  automatically.</li></ol> </td><td><ol><li>If we are  not  setting  max  age for the Cookie , such  type of  Cookies are called  Non-Persistant/temporary  Cookies.</li>
 <li>These will be  stored  in the  browsers cache  and  disabled  automatically Once  browser will  be  closed.</li>  
</ol> </td></tr>
</table>

 

<h5 id="advcookie">Advantages  of  Cookies :</h5> 
<ol>
<li>It is  very easy  to  implement. </li>
<li>Persist across  browser  shutdowns,  server shutdowns  and  application redeployments.</li>
<li>If very less  Session   information   is  available  or  if huge no. of end-users are available  then  the  best  suitable  mechanism  is Cookies.</li>
</ol>
<h6 id="limitcookie">Limitations  of  Cookie :</h6>
<ol>
<li>To meet security  constraints there may be  a chance  of   disabling  cookies  at  client side. In this case  Session management   by  Cookies  wan't  work .</li>
<li>The  maximum  no. of  Cookies supported  by  the browser  is  fixed.(maximum of 30, based on browser) </li>
<li>The  size  of  Cookie  is also fixed. Hence  we  can't   store  huge  amount  of  information   by  using   Cookies.</li>
<li>The  Cookies  should  be  travelled  every  time  across  the  network. Hence there  may be a  chance   of  network  over  heads. i.e., it impact performance </li>
</ol>

<h4 id="diff">Differences   between  Session-API     and  Cookies :</h4>

<table border="1">
<tr><th>Session-API</th><th>Cookies</th></tr>
<tr><td>If huge  amount  of Session information is  available ,  then  we  should  go for  Session-API .</td><td>If  very less  amount  of  Session information  is  available , then we should go for  Cookie.</td></tr>
<tr><td>Session  information  will be maintained  at  Server  side.</td><td>Session  information will be maintained at client side.</td></tr>
<tr><td>The Session information  can be  any type  and  need not be  String type.</td><td>Session information should be  String type</td></tr>
<tr><td>Session  information  won't   persist  across  server  shutdown &amp; application re-deploys.</td><td>Session  information  will be  persist  across  Server   shutdowns  &amp; application deployments.(The cookies should be persist)</td></tr>
</table>
<br>
<b>Note:</b>
To  meet Security  constraints   there  may be a chance   of disabled cookies at client  side . In this case  Session  management  by  using   Session-API   and  Cookies  won't  work. To  handle    this  requirement  we should go for url-rewriting .<br>
<h2 id="urlre">URL - Rewriting :</h2>
<ol>
<li>Whenever  Cookies   are  disabled at   client side , browser unable to see "set-cookie"  response header  and hence  browser unable  to get  session id   and  cookies  send by  the Server .</li>
<li>Due  to this  browser  can't   send  session id  &amp;  Cookies  to the  server and  hence server is unable  to  remember  client  information  across  multiple requests .  So that  Session  management  fails. </li>
<li>To  resolve  this  we  should  go for  url rewriting  technique.</li>
<li>The central idea  in this  technique   is  append   required  Session  information   to the url , instead  of appending   to  "set-cookie"   response   header.</li>
<li>Whenever  client  clicks  url  for  further  communication server  can get required  Session  information with the url . So that  Server  can able  to remember  client  information  across  multiple requests.
		<table  border="2"  style="font-size: 27"><tr><td>URL  Re-writing = URL + session information </td></tr></table>   OR   <table  border="2"  style="font-size: 27"><tr><td>URL Re-writing = URL ; jsessionid=1234</td></tr></table></li>
</ol>

<br><h5 id="sessionid">HttpServletResponse defines  the  following   two  methods to append  Session id   to  the  url</h5>
<ol>
<li><table  border="2"  style="font-size: 27"><tr><td>public  String  encodeURL(String url) </td></tr></table> Returns  url  by  appending jsession id </li>
<li><table  border="2"  style="font-size: 27"><tr><td>public String encodeRedirectURL(String  url)</td></tr></table>  Returns  the url  by appending  session id . This URL can be used as an argument to send sendRedirect() method</li>
<li>The above 2 methods  will append  jsessionid  to the  url  iff cookies  are disabled  at  client  side.</li>
<li>If  cookies are  enabled  then  these  methods   returns  the same   url  without  appending  jsessionid . </li>
<li>HttpServletRequest  defines  the following  methods to  identify whether  the sessionid  is   coming as the part of  url or  with cookie request header.
		<ol>
		<li>public  boolean  isRequestedSessionIdFromURL( ) </li>
		<li>public  boolean  isRequestedSessionIdFromCookie( ) </li>
		</ol>
 </li>
 <li>By  using  these  methods  we can identify  underlying  Session  management   technique.</li>
 </ol>
 
 <h6 id="advurl"> Advantage  of URL Re-writing :</h6>
 There is no chance of  disabling  url  re-writing technic  hence this technique  will work  always . It is universally supported. 
 <h5 id="limiturl"> Limitations :</h5>
 <ol>
 <li>It is very difficult  to  rewrite  every  url to  append  Session information .</li>
 <li>Url  rewriting   works only   for  dynamic  document i.e.,  response  should  contain  at  least  one  url .</li>
 <li>To keep our  web-application  as  robust  we  can use  both cookies  and  url  rewriting  together.</li>
 <li>If  cookies are  enabled then  cookies  will  work  otherwise  url  rewriting   will   work.</li>
 </ol> 
 
 <br>
 <h5>Demo program on URL rewriting</h5>
 
login.html
<pre> 
&lt;form action="./redirectone"&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td&gt;Name :&lt;/td&gt;&lt;td&gt; &lt;input type="text" name="uname"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="submit"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
</pre>


UrlRedirectServletOne.java
<pre>
public class UrlRedirectServletOne extends HttpServlet {

@SuppressWarnings("deprecation")
public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  response.setContentType("text/html");
  PrintWriter out = response.getWriter();
  
  String name=request.getParameter("uname");
  HttpSession session=request.getSession();
  session.setAttribute("uname", name);
  out.println("Welcome to Aksahay");
  
 // out.println("&lt;br&gt; &lt;a href=./redirecttwo?name=" 
         // +name+ "&gt; click here to get User &lt;/a&gt;");
  
  out.println("&lt;br&gt; &lt;a href= "+response.encodeUrl("./redirecttwo") +
      " &gt;  click here to get User &lt;/a&gt; ");
  
		
}

}
</pre>

UrlRedirectServletTwo.java
<pre>
public class UrlRedirectServletTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 
 HttpSession session=request.getSession(false);
 String name=(String)session.getAttribute("uname");
 
 //String name=request.getParameter("name");
 out.println("Good Morning :"+name);

}

}
</pre>

web.xml
<pre>
&lt;web-app&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;UrlRedirectServletOne&lt;/servlet-name&gt;
    &lt;servlet-class&gt;session.UrlRedirectServletOne&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;UrlRedirectServletTwo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;session.UrlRedirectServletTwo&lt;/servlet-class&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;UrlRedirectServletOne&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/redirectone&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;UrlRedirectServletTwo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/redirecttwo&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>


<br><br>



<h2 id="listeners">Listeners</h2>
Objective :
<ul>
<li>Describe  the web-container  event life cycle  model  for the request, Session  and  webapplication(context). </li>
<li>Create and  configure  Listener  class for  each  Scope. </li>
<li>Create  and  configure  attribute  Listeners  for each scope.</li>
<li>For the given  scenario  identify  proper attribute  Listener.</li>
<li>In the webapplication there may be a chance of occuring several  events like ...
		<ol>
		<li>Request object creation/destruction</li>
		<li>Session object creation/destruction</li>
		<li>Context  object  creation/destruction </li>
		<li>Attribute addition  in request/session  Scope</li>
		<li>Removal of attribute  in  request/session Scope </li>
		</ol> 
</li>
<li>We can configure Listeners classes   to listen  these  events  and  they  can do  appropriate  things   whenever that  event  occurs.</li>
</ul>
When ever a perticular event occurs if we want to perform surtain operation then we should go for Listeners. 

<h3>All the Listeners  are divided  into 3 groups.</h3>


		<ol>
		<li><h5>  RequestListeners : </h5>
		These Listen  the  events related to request.<br>
				There  are  2  types  of  RequestListeners.
				<ol>
				<li>ServletRequestListener</li>
				<li>ServletRequestAttributeListener</li>
				</ol> <br>
		</li>
		<li><h5>Session Listeners :</h5> Listens  the events  related  to   Sessions .<br>
				There  are  4  types  of  Session Listeners.
				<ol>
				<li>HttpSessionListener</li>
				<li>HttpSessionAttributeListener</li>
				<li>HttpSessionBindingListener</li>
				<li>HttpSessionActivationListener</li>
				</ol><br>
		</li>
		<li><h5>ContextListener :</h5> Listens the events  related  to  context.<br>
				There are  2  types  of  context  Listeners.
				<ol>
				<li>ServletContextListener</li>
				<li>ServletContextAttributeListener</li>
				</ol>
			</li>
		</ol>


<br>


<b>Note :</b>

java.util.EventListener  is the super interface  for all  the Listeners  in our  servlets.<br> This Listener  doesn't  contain  any method and acts as marker interface.
<br><br><img alt="" src="session/lis.png"><br> 

<h2 id="reqlis">RequestListeners :</h2>


<h3 id="servreq">ServletRequestListener </h3>
<img alt="" src="session/lis3.png"> <br>
This Listener life cycle events of request object like request object creation and destruction.
<p>This interface defines 2 methods</p> 
<ol><li>
<b>public void requestInitialized(ServletRequestEvent e)</b>        <br>
This method will be executed automatically by the WebContainer, at the time of request object creation, i.e., just before executing service()
</li><li>
<b>public void requestDestroyed(ServletRequestEvent e)  </b>    <br>
This method will be executed automatically by the WebContainer at the time of request object destruction, i.e., just after completing service().
</li></ol>
  

<h5>ServletRequestEvent(C) :</h5>
<img alt="" src="session/lis1.png"> <br>
It defines the following 2 methods
<ol>
<li>public ServletRequest getServletRequest()</li>
<li>public ServletContext getServletContext()</li>
</ol>


<h5>java.util.EventObject </h5>
ServletRequestEvent is the child class of EventObject, it contains only one method getSource()
<p><strong>public Object getSource()</strong></p>
It returns source of the event, in this case the source of the event is web application which is represented by ServletContext object hence getSource() method returns ServletContext object.

<br>

 

<br>
ServletRequestListenerDemo.java
<pre>
public class ServletRequestListenerDemo implements ServletRequestListener {
 static int count;
 static {
  System.out.println("ServletRequestListener class is  loading ");
 }
	
 public ServletRequestListenerDemo() {
  System.out.println("ServletRequestListener Object is  created ");
 }

 public void requestDestroyed(ServletRequestEvent event) {
  System.out.println("The  request object destroyed at :"+new java.util.Date());
  System.out.println("The source of destroyed request is :"+event.getSource());		
 }

 public void requestInitialized(ServletRequestEvent event) {
  count++;
  System.out.println("new request object is created at :"+ new java.util.Date());
  System.out.println("The source of  creation request is :"+event.getSource());
  System.out.println("The context is :"+event.getServletContext());
  System.out.println("The  request is :"+event.getServletRequest());
}
}
</pre>


RequestServlet.java

<pre>
public class RequestServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("The hit count of the web application is :"+
                            ServletRequestListenerDemo.count);
}
}
</pre>

web.xml
<pre>
&lt;web-app&gt;
&lt;listener&gt;
 &lt;listener-class&gt;listener.ServletRequestListenerDemo&lt;/listener-class&gt;
     // fully qualified name
&lt;/listener&gt;  
  &lt;servlet&gt;
    &lt;servlet-name&gt;RequestServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.RequestServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt; 
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;RequestServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/request&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre>

<ul><li>
By using listener tag we can configure listener class in web.xml
</li><li>
listener tag is the direct child tag of web-app, hence we can take any where with in the web-app.
</li><li>
web container is responsible for the creation of listener object for this WC always calls public no-arg constructor, hence every listener class should compulsory contains public no-arg constructor otherwise Instantiation Exception.
</li><li>
Instantiation of the listener will be happen at the time of web-application deployment or sever start-up.
</li></ul>

<strong> Note :</strong>
In the above program count value won't persist across server shutdown or application un-deployment  but we can persist count value by using ServletContextListener.
 





<h3 id="servattribute">ServletRequestAttributeListener</h3>
This Listener listens to events related to request scoped attributes like attribute addition, attribute removel, attribute replacement.
<br><br> 
This interface defines following methods
<ol>
<li><strong>public void attributeAdded(ServletRequestAttributeEvent e)</strong> <br>
      This method will be executed automatically by the by the WC, when ever we  are  adding  an attribute an request scope.</li>
<li><strong>public void attributeRemovel(ServletRequestAttributeEvent e)</strong> <br>
     This method will be executed automatically by the by the WC, when ever we  are  removing   an attribute from request scope.   </li>
<li><strong>public void attributeReplaced(ServletRequestAttributeEvent e)</strong> <br>
     This method will be executed automatically by the by the WC, when ever we  are  replacing an existing attribute named with new value. This method returns old value, but not new value.  </li>
</ol>


 


<h5>ServletRequestAttributeEvent</h5>

It is the child class of ServletRequestEvent, this class defines the following 2 methods
<ol>
<li><strong>public String getName()</strong><br> It returns name of the attribute  which is adding request scope.</li>
<li><strong>public Object getValue() </strong><br> It returns the value of attribute which is added or removed , In this case of replacement this method returns old value.</li> 
</ol>


<br>
<img alt="" src="session/sreq2.html">
<br>


ServletRequestAttributeListenerDemo.java
<pre>
public class ServletRequestAttributeListenerDemo implements
		ServletRequestAttributeListener {

	public ServletRequestAttributeListenerDemo() {
		System.out.println("ServletRequestAttributeListenerDemo obj created ");
	}

	public void attributeAdded(ServletRequestAttributeEvent event) {
		System.out.println("Attribute added name :"+event.getName());
		System.out.println("Attribute added value :"+event.getValue());
	}

	public void attributeRemoved(ServletRequestAttributeEvent event) {
		System.out.println("Attribute removed name :"+event.getName());
		System.out.println("Attribute removed value :"+event.getValue());
	}

	public void attributeReplaced(ServletRequestAttributeEvent event) {
		System.out.println("Attribute replaced name :"+event.getName());
		System.out.println("Attribute replaced value :"+event.getValue());
	}

}

</pre>

ServletRequestAttribute.java
<pre>
public class ServletRequestAttribute extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 //PrintWriter out = response.getWriter();

 request.setAttribute("Ashok", "SCJP");
 request.setAttribute("Ashok", "SCWCD");
 request.removeAttribute("Ashok");
}
}
</pre>

web.xml
<pre>
&lt;listener&gt;
    &lt;listener-class&gt;listener.ServletRequestAttributeListenerDemo&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;ServletRequestAttribute&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.ServletRequestAttribute&lt;/servlet-class&gt;
  &lt;/servlet&gt;
 
  
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletRequestAttribute&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/requestattribute&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</pre>








<h2 id="context">ContextListener :</h2>

<h3 id="servcontext">ServletContextListener</h3>
This Listener listens life cycle events of context object like creation &amp; destruction.

This Listener defines the following 2 methods
<ol>
<li><strong>public void contextInitialized(ServletContextEvent e)</strong><br> This method will be executed at the time of context object created or application deployment.</li>
<li><strong>public void contextDestroyed(ServletContextEvent e)</strong><br> This method will be executed at the time of context object destruction. i.e., at the time of application un-deployment.</li>
</ol>

<h5>ServletContextEvent : </h5>
It is the child class <strong>java.util.EventOject</strong>   and it contains only one method 
<strong>public ServletContext getServletContext(). </strong>

<br><img alt="" src="session/sreq2.html"><br>

<h6>Demo program to ContextListener  to  print hitcount  of the web-application  which  should  persist  across  server shutdown.</h6>

<pre>
ServletRequestListenerDemo.java
</pre>

ServletContextListenerDemo.java
<pre>
public class ServletContextListenerDemo implements ServletContextListener {

public void contextDestroyed(ServletContextEvent event) {
 System.out.println("context destroyed ");
		
 String path=event.getServletContext().getRealPath("abc.txt");
		
	try{
		PrintWriter out=new PrintWriter(path);
		out.print(ServletRequestListenerDemo.count);
		out.flush();
	} catch (Exception e) { }
}
	

public void contextInitialized(ServletContextEvent event) {
 System.out.println("context initialized ");
		
 String path=event.getServletContext().getRealPath("abc.txt");
		
	try{
		BufferedReader br=new BufferedReader(new FileReader(path));
		String s=br.readLine();
		
		if(s!=null) {
			int c=Integer.parseInt(s);
			ServletRequestListenerDemo.count=c;
		}
	}catch (Exception e) {} 
}
}
</pre>



ServletContext.java
<pre>
public class ServletContext extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("Hitcount persist acoss server shutdown 
  in Servlet context listener :"+ServletRequestListenerDemo.count);
}
}
</pre>

web.xml
<pre>
  &lt;listener&gt;
    &lt;listener-class&gt;listener.ServletContextListenerDemo&lt;/listener-class&gt;      
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;ServletContext&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.ServletContext&lt;/servlet-class&gt;
  &lt;/servlet&gt; 
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletContext&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/context&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;listener&gt;
 &lt;listener-class&gt;listener.ServletRequestListenerDemo&lt;/listener-class&gt;
&lt;/listener&gt;
</pre>
<ul>
<li>We can configure more than one listener of the same type but the order of the execution is based on the order of Listener tag in the web.xml</li>
<li>If both listeners  are 2 different types the order is not important.</li>
</ul> 



<h4>Demo Program on ServletContextListener </h4>
It is not a Dog object in realtime it is DataSource object.


<br><br>

Dog.java
<pre>
public class Dog {
 public String breed;
 public Dog(String breed) {
	 this.breed=breed;
 }
 public String getBreed(){ 
	 return breed;
 }
}
</pre>

ServletContextListenerDog.java
<pre>
public class ServletContextListenerDog implements ServletContextListener {

public void contextInitialized(ServletContextEvent event) {
 System.out.println("context listener dog initialized");
 ServletContext context=event.getServletContext();
 String dogBreed = context.getInitParameter("breed");
 Dog d=new Dog(dogBreed);
 context.setAttribute("dog",d);
}

	public void contextDestroyed(ServletContextEvent event) {
		System.out.println("context listener dog destroyed"); 
}
}
</pre>

ServletContextDog.java
<pre>
public class ServletContextDog extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("Servlet Context Listener  Dog ");
		
 Dog d=(Dog) getServletContext().getAttribute("dog");
 out.println("<br>The dog breed is : "+d.getBreed());		
}
}
</pre>

web.xml
<pre>
  &lt;listener&gt;
    &lt;listener-class&gt;listener.ServletContextListenerDog&lt;/listener-class&gt;
    //The whole point is to be initialized the app'n before 
                    //any servlet is initialized
  &lt;/listener&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;breed&lt;/param-name&gt;
    &lt;param-value&gt;Great Puppy&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;ServletContextDog&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.ServletContextDog&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletContextDog&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/contextdog&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</pre>

<ol>
<li>Container read the deployment descriptor for the application including &lt;listener&gt; and &lt;context-param&gt; elements.</li>
<li>Container creates a new ServletContext object for this application that all parts of application will share.</li>
<li>Container creates name/value pairs of strings for each context init-parameters.</li>
<li>Container gives the ServletContext reference to the name value parameters.</li>
<li>Container creates a new instance of the ServletContetListenerDemo class.</li>
<li>Container calls the listener context initialized method by passing ServletContextEvent, the EventObject has a reference to the ServletContext so the Eventhandling  code can get the context form the event &amp; get the ContextInitParameters from the Context.</li>
<li>Listener asks ServletContextEvent for a reference to ServletContext.</li>
<li>Listener asks ServletContext for the ContextInitParameter(breed).</li>
<li>Listener uses this initParameter  to construct a new Dog object.</li>
<li>Listener sets the dog object as attributes in the servlet context scope.</li>
<li>Container makes a new servlet(i.e., makes a new ServletConfig) with initParameter gives a ServletConfig reference to the ServletContext, when it calls servlet init method.</li>
<li>Servlet gets a request and ask the ServletContext for the attribute "dog".</li>
<li>Servlets calls getBreed() on the Dog object.</li>
</ol>

<h3 id="servattribute">ServletContextAttributeListener</h3>
This listener listens events related  to context scoped attributes , i.e., attribute added in the context scope or replacement  or removal.
This interface defines the following methods
<ol><li>
public void attributeAdded(ServletContextAttributeEvent e)</li><li>
public void attributeRemoved(ServletContextAttributeEvent e)</li><li>
public void attributeReplaced(ServletContextAttributeEvent e)</li></ol>






<h5>ServletContextAttributeEvent </h5>
It is child class of ServletContextEvent, it contains the following 2 methods.
<ol>
<li>public String getName() </li>
<li>public Object getValue() </li>
</ol>

<br><img alt="" src="session/sreq3.html"><br>

<h2 id="sessionlis">Session Listeners :</h2>

<h3 id="httpses">HttpSessionListener</h3>
HttpSessionListener listens lifecycle events of session object like session object creation and destruction, this interface defines the following 2 methods.
<ol>
<li>public void sessonCreated(HttpSessionEvent e)</li>
<li>public void sessonDestroyed(HttpSessionEvent e)</li>
</ol>

<h5>HttpSessionEvent</h5>
It is the child class of java.util.EventObject, it contains only one method. <br>
<strong>public HttpSession getSession()</strong>

<br><img alt="" src="session/sreq3.html"><br> 

HttpSessionListenerDemo.java
<pre>
public class HttpSessionListenerDemo implements HttpSessionListener {
 static int count;
 public void sessionCreated(HttpSessionEvent event) {
 System.out.println("new session object created at :"+new  java.util.Date());
 count++;
}

public void sessionDestroyed(HttpSessionEvent event) {
 System.out.println("session object is destroyed :"+ new java.util.Date());
 count--;
}

}
</pre>

SessionServlet.java
<pre>
public class SessionServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
		
 HttpSession session=request.getSession();
 //session.setMaxInactiveInterval(120);
 out.println("The no, of users online is :"+HttpSessionListenerDemo.count);
}
}
</pre>

web.xml
<pre>
  &lt;listener&gt;
    &lt;listener-class&gt;listener.HttpSessionListenerDemo&lt;/listener-class&gt;
  &lt;/listener&gt; 
    &lt;session-config&gt;
    &lt;session-timeout&gt;3&lt;/session-timeout&gt;
  &lt;/session-config&gt; 
  &lt;servlet&gt;
    &lt;servlet-name&gt;SessionServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.SessionServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SessionServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/session&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</pre>


<h3 id="httpattribute">HttpSessionAttributeListener</h3>
This Listener listens events related to session scoped attributes like attribute addition in the session scope, or removal or replacement.
<p>This interface defines the following  methods</p>
<ol>
<li><strong>public void attributeAdded(HttpSessionBindingEvent e)</strong><br/>This method will be executed automatically by the WC, when ever we are adding any type of objects in the session scope. 
</li>
<li><strong>public void attributeReplaced(HttpSessionBindingEvent e)</strong><br/> This method will be executed automatically by the WC, when ever we are replacing an existing object with new object.
</li>
<li><strong>public void attributeRemoved(HttpSessionBindingEvent e)</strong><br/> This method will be executed automatically by the WC, when ever we are removed any type of attribute  in the session scope.</li>
</ol>
<p><strong>Note : </strong> There is no class named with HttpSessionAttributeEvent for this requirement the request class is HttpSessionBindingEvent. </p>

<h5>HttpSessionBindingEvent</h5>
It is the child class of HttpSessionEvent , and it contains 2 methods 
<ol>
<li>public String getName()</li>
<li>public Object getValue()</li>
</ol>
<br><img alt="" src="session/sre4.html"><br>

<h3 id="httpsession">HttpSessionBindingListener</h3>
When ever we are  trying to add or remove or replacement  a perticular type of object in session scope, if we want to perform any operation then we should go for HttpSessionBindingListener.
<p>This interface defines the following 2 methods</p>
<ol>
<li><strong>public void valueBound(HttpSessionBindingEvent e)</strong><br> This method will be executed automatically by the WC, when ever we are trying to add a perticular type of object in session scope.</li>
<li><strong>public void valueUnbound(HttpSessionBindingEvent e)</strong><br> This method will be executed automatically by the WC, when ever we are trying to remove a perticular type of object in session scope.</li>
</ol> 

<ul>
<li> For replacement operations both methods will be executed but valueBound() first and followed by valueUnbound().</li>
<li>It is not required to configuure HttpSessionBindingListener in web.xml </li>
<li>When ever we are trying to add an attribute in session scope , WC will check whether the corresponding class implements HttpSessinBindingListener  or not , if it is implements HttpSessionBindingListener then valueBound() will be executed automatically by the WC.</li>
<li>WC follows the same approach for attributeRemoval  and  attributeReplacement also.</li>
<li>If we configure both attribute &amp; binding listeners then binding listener  will executed  first followed by attribute listener.</li>
</ul>


<h6>Demo program </h6>

HttpSessionAttributeListenerDemo.java
<pre>
public class HttpSessionAttributeListenerDemo implements
		HttpSessionAttributeListener {

 public void attributeAdded(HttpSessionBindingEvent event) {
		System.out.println("Attributes added");
 }

 public void attributeRemoved(HttpSessionBindingEvent event) {
		System.out.println("Attribute removed");
 }

 public void attributeReplaced(HttpSessionBindingEvent event) {
		System.out.println("Attribute replaced");
 }
}
</pre>

HttpSessionBindingListenerDemo.java
<pre>
public class HttpSessionBindingListenerDemo implements
		HttpSessionBindingListener {

 public void valueBound(HttpSessionBindingEvent event) {
 System.out.println("Session object has  added  to the Session scope : bound ");
 }

 public void valueUnbound(HttpSessionBindingEvent event) {
 System.out.println("Session object has removed to the Session scope : unbound ");
 }
}
</pre>

ServletSessionAttributeBind.java
<pre>
public class ServletSessionAttributeBind extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

	response.setContentType("text/html");
	PrintWriter out = response.getWriter();
	
	HttpSession session=request.getSession();
	session.setAttribute("a1", "SCJP");
	session.setAttribute("a1", "SCWCD");
	session.setAttribute("a2", new HttpSessionBindingListenerDemo());
	session.setAttribute("a3", new HttpSessionBindingListenerDemo());
	session.setAttribute("a2", new HttpSessionBindingListenerDemo());
	session.removeAttribute("a2");
	session.setAttribute("a1", new HttpSessionBindingListenerDemo());
	
	
	out.println("HttpSessionBindingListener not required to configure");		
	}
}
</pre>

web.xml
<pre>
  &lt;listener&gt;
    &lt;listener-class&gt;listener.HttpSessionAttributeListenerDemo&lt;/listener-class&gt;
  &lt;/listener&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;ServletSessionAttributeBind&lt;/servlet-name&gt;
    &lt;servlet-class&gt;listener.ServletSessionAttributeBind&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ServletSessionAttributeBind&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/sessionbind&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</pre>




<h3 id="httpactivation">HttpSessionActivationListener</h3>
If a web-application is destributed across several JVM's such type of web-application is called distributed web applications.
<br>
<strong>The main advantage of distributed web-applications are --</strong>
<ol>
<li><strong>by loadbalancing :</strong> we can improve performance of the application. </li> 
<li><strong>by handling : </strong> fail over situations we can keep our application  has robust. </li> 
</ol>

<ul>
<li>In distributed web-applications the session object is required to migrate from one JVM to another JVM.</li>
<li>When ever a session object is migrating from one JVM to another JVM , the corresponding session scoped attributes also will migrate across the network , hence session scoped attributes should serializable.</li>
<li>At the time of sesson object migration , if want to perform any operation then we should go for HttpSessionActivationListener.</li>
</ul>

This Listener defines the following 2 methods.
<ol> 
<li><strong>public void sessionWillPassivate(HttpSessionEvent e)</strong> <br> This method is called on each implementing  object bound to the session just before serialization.</li>
<li><strong>public void sessionDidActivate(HttpSessionEvent e)</strong> <br> This methode wii be executed on each implements  object bound to the session just after de-serialization.</li>
</ol>
<p>The session id 343 migrates from one VM1 to another VM2, in other words it is no longer exists on VM1 once it is moves to VM2. This migration means the session was passivated on VM1 and activated  on VM2.</p>
<br><img alt="" src="session/lis4.png"><br>
<p>The container get  the request the corresponding session id  and realize this session id is on a different virtual machine i.e., VM1 </p>  
<h6>Q : requestA for SercletA could happend for VM1 and requestB for ServletA could endup and different VM , what happens to the things ServletContext, ServletConfig and HttpSession objects ?  </h6>
<p>Only HttpSession object (and their attributes) moves from one VM to another VM.
<br/>There is one ServletContext per one JVM, there is one ServletConfig per Servlet,per VM but there is only one HttpSession object  for a given  session id per web-app'n, regardless of how many virtual machines the app'n  distributed across.</p>
<p><strong>Note : </strong> HttpSessionActivationListener is also not required to configure in web.xml </p>





HttpSessionActivationListenerDemo.java
<pre>
public class HttpSessionActivationListenerDemo implements
		HttpSessionActivationListener {

 public void sessionDidActivate(HttpSessionEvent arg0) {
 System.out.println("object bound to the session just after De-Serialization");
 }

 public void sessionWillPassivate(HttpSessionEvent arg0) {
 System.out.println("object bound to the session just before Serialization");
 }
}
</pre>

<br><br><img alt="" src="session/lis2.png"><br><br>

<table border="2">
<tr>
<th>Listener</th><th>Purpose</th><th>Corresponding Methods</th><th>Corresponding Events</th><th>Corresponding Event Methods</th><th>is required to configure web.xml</th></tr>
<tr><td>ServletRequest<br>Listener</td><td>To listens life cycle events of request object. i.e., request object creation &amp; destruction </td><td>requestInitialized()<br>requestDestroyed() </td><td>ServletRequest<br>Event </td><td>getServletRequest()<br>getServletContext()  </td><td>Yes </td></tr>
<tr><td>ServletRequest<br>AttributeListener </td><td>To listens events related request scoped attributes </td><td>attributeAdded() <br>attributeReplaced() <br>attributeRemoved()  </td><td>ServletRequest<br>AttributeEvent </td><td>getName()  getValue() </td><td>Yes</td></tr>
<tr><td>ServletContext<br>Listener  </td><td>To listens life cycle events of context  object. i.e., context object creation &amp; destruction </td> <td>contextInitialized() <br> contextDestroyed() </td><td>ServletContext<br>Event </td><td> getServletContext()</td><td>Yes</td></tr>
<tr><td>ServletContext<br>AttributeListener </td><td>To listen events related to context scoped attributes </td><td>attributeAdded() <br>attributeReplaced() <br>attributeRemoved() </td><td> ServletContext<br>AttributeEvent </td><td>getName()  getValue()  </td><td> Yes </td></tr>
<tr><td>HttpSession<br>Listener</td><td>To listens life cycle events of session  object. i.e., session object creation &amp; destruction </td><td>sessionCreated() sessionDestroyed()</td><td>HttpSession<br>Event</td><td>getSession()</td><td>Yes</td></tr>
<tr><td>HttpSession<br>AttributeListener</td><td>To listen events related to session scoped attributes </td><td>attributeAdded() <br>attributeReplaced() <br>attributeRemoved() </td><td><strike> HttpSession<br>AttributeEvent</strike> <br>HttpSession<br>BindingEvent</td><td>getName()  getValue()</td><td>Yes</td></tr>
<tr><td>HttpSession<br>BindingListener</td><td>When ever we are adding or removing or replacing a perticular type of object in session  scope , to perform certain activity then we should go for this Listener</td><td>valueBound() valueUnbound()</td><td>HttpSession<br>BindingEvent</td><td>getName() getValue()</td><td>not required</td></tr>
<tr><td>HttpSession<br>ActivationListener </td><td>If we want to perform any activity just before serialization and just after de-serialization in distributed web-applications   </td><td> sessionWillPassivate() sessionDidActivate()</td><td>HttpSession<br>Event</td><td>getSession() </td><td>not required</td></tr>
</table>





<p>&nbsp;</p>





   
   
 </td></tr></table> <a href="index-2.html"> BACK </a> </div>  
   
 </body>

<!-- Mirrored from java.scwcd.jobs4times.com/Session-Management.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:21 GMT -->
</html>