<!DOCTYPE HTML>
<html>
  
<!-- Mirrored from java.scwcd.jobs4times.com/Web-Container-Model.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:13 GMT -->
<head>
    <title>Tutorials for Advanced Java Web Container Model,ServletContext parameter,Comparison between Servlet init &amp; context initialization parameters,Servlet Scopes,
    Request Scope,Session Scope,Application Scope (or) Context Scope,Multi-threading issues associated with each scope,Differences between parameters and attributes,To print all context scoped attributes,To print hit count of the web-application,To print no. of requests send in each(current) Session,
    To print no.of Session objects created in application,no. of requests triggered Ip-address wise,How do we make Context scoped attributes Thread safe ?,RequestDispatcher,Differences between getting RequestDispatcher by ServletRequest &amp; ServletContext,RequestDispatcher's methods,Forward mechanism,
    Include mechanism,Differences between forward( ) and include( ),Foreign RequestDispatcher,FILTERS (servlet 2.3 v),FILTER- API,Filter,FilterConfig,FilterChain,Configuring Filter in web.xml,Mapping of Filter,Mapping to a particular url-pattern,Mapping to a particular Servlet,Mapping to entire web-application,dispatcher tag,
    Difference between Filter's doFilter() and FilterChain's doFilter(),Wrappers,RequestWrapper,ResponseWrappers,Demo program for request wrapper,Demo program for response wrapper </title>
    
	
    <meta name="keywords" content="ServletContext,parameter,Servlet,init,context, initialization, parameters,Servlet Scopes,Request Scope,Session Scope,Application Scope (or) Context Scope, Multithreading,parameters,attributes,hit count,web-application,requests,Session,objects, triggered,Ip-address,
    Thread safe,RequestDispatcher,RequestDispatcher,ServletRequest,ServletContext,RequestDispatcher, methods,Forward mechanism,Include mechanism,forward( ),include( ),Foreign RequestDispatcher,FILTERS (servlet 2.3 v),FILTER- API,Filter,FilterConfig,FilterChain,web.xml,url-pattern,dispatcher tag,Filter's doFilter() and FilterChain's doFilter(),
    Wrappers,RequestWrapper,ResponseWrappers">

    <meta name="description" content=" For every Servlet , web container will create one ServletConfig object to maintain Servlet level initialization parameter . By using this object Servlet can get its configuration information.
Similarly for every web-application webcontainer creates one ServletContext object to maintain application level configuration information.
We can maintain request scope by using ServletRequest ( or ) HttpServletRequest object .
Session scope is maintained by HttpSession object.
Application Scope is maintained by ServletContext object.">

    <meta name="content-type" content="text/html; charset=ISO-8859-1">
    
    <link rel="stylesheet" type="text/css" href="styles.css">  

  </head>
  
  <body>
  
<div align="center">
<table width="75%" border="3"> <tr><td>


 <table width="100%" cellpadding="0" cellspacing="0" border="0">
     <tr>
    <td width="50%" align="left"><a href="https://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="700" height="200">   </a> </td> 
   	<td  align="right"><a href="index-2.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 
  
    </tr> 
   	</table>  	







<h1 align="center" style="background-color: rgb(0, 55, 0);"><font color="#ffff00">Web Container Model</font></h1>
<h2><font color="#fffff"><u>Agenda:</u></font></h2>
<ol >



<li><a href="#scontext">ServletContext parameter </a><ul>
<li><a href="#diffinitcontext">Comparision between Servlet init &amp; context initialization parameters</a></li></ul></li>

<li><a href="#sscope">Servlet Scopes</a><ol>
<li><a href="#reqscope">Request Scope</a></li>
<li><a href="#sesscope">Session Scope</a></li>
<li><a href="#appscope">Application Scope (or) Context Scope</a></li></ol> <ul>
<li><a href="#multi">Multithreading issues associated with each scope</a></li>
<li><a href="#diffparamattribute">Differences between parameters and attributes </a></li>
<li><a href="#printcontext"> To print all context scoped attributes:</a></li>
<li><a href="#printhit">  To print hit count of the web-application:</a></li>
<li><a href="#printreq">To print no. of requests send in each(current) Session</a></li>
<li><a href="#printsession">To print no.of Session objects created in application</a></li>
<li><a href="#triggered">no. of requests triggered Ip-address wise</a></li>
<li><a href="#contextscope">How do we make Context scoped attributes Thread safe ?</a></li></ul></li>


<li><a href="#rdispatcher">RequestDispatcher</a><ul>
<li><a href="#diffsrsc">Differences between getting RequestDispatcher by ServletRequest &amp; ServletContext </a></li>
<li><a href="#rdmethod">RequestDispatcher's methods</a><ol>
<li><a href="#forward">Forward mechanism</a></li>
<li><a href="#include">Include mechanism</a></li></ol></li>
<li><a href="#diffforinc">Differences between forward( ) and include( ) :</a></li>
<li><a href="#foreign">Foreign RequestDispatcher</a></li></ul> </li>


<li><a href="#filter">FILTERS (servlet 2.3 v) </a><ul>
<li><a href="#filterapi">FILTER- API :</a><ol>
<li><a href="#filt">Filter </a></li>
<li><a href="#fconfig">FilterConfig</a></li>
<li><a href="#fchain">FilterChain </a></li></ol></li> 
<li><a href="#conweb">Configuring Filter in web.xml </a></li>
<li><a href="#mapping">Mapping of Filter :</a><ul>
<li><a href="#mapurl">Mapping to a particular url-pattern</a></li>
<li><a href="#mapservlet">Mapping to a particular Servlet</a></li>
<li><a href="#mapwebapp">Mapping to entire web-application</a></li></ul></li>
<li><a href="#dispatchertag">dispatcher tag</a></li>
<li><a href="#difffilter">Difference between Filter's doFilter() and FilterChain's doFilter() </a></li></ul> </li>



<li><a href="#wrapper">Wrappers</a><ul>
<li><a href="#reqwra">RequestWrapper</a></li>
<li><a href="#reswra">ResponseWrappers</a></li>
<li><a href="#reqpro">Demo program for request wrapper</a></li>
<li><a href="#respro">Demo program for response wrapper</a></li></ul></li>

</ol>


  
  
  
   
   
         
 <h2 id="scontext"><u>ServletContext  parameter :</u></h2>For the ServletContext  initialization  parameter. 
 <ol>
 <li>Write Servlet code to access initialization  parameters.</li>
 <li>Create  the  deployment descriptor elements  for the initialization parameter.</li>
 </ol>       

<ol>
<li>For every Servlet , web container will create one ServletConfig object  to maintain Servlet  level  initialization  parameter  . By using  this object Servlet can  get its configuration information.</li>
<li>Similarly for every web-application  webcontainer  creates  one ServletContext  object to maintain application level configuration information </li>
<li>Servlet can get  application level  configuration information  through this context object  only. </li>
<li>ServletConfig per  Servlet , where as ServletContext  per  Web-application.</li>
<li>If  initialization parameters are common for all  Servlets then it is not recommended  to declare those parameters  at Servlet level , we  have  to  declare  such type of parameters at application -level   by using  &lt; context-param &gt;
<br><br>
&lt;web-app&gt;<br>
&lt;context-param&gt;<br>
&lt;param-name&gt;username&lt;/param-name&gt;<br>&lt;param-value&gt;scott&lt;/param-value&gt;<br>&lt;/context-param&gt;<br>&lt;/web-app&gt;<br><br> </li>

<li>We can declare  any number of context parameters but one &lt; context-param &gt;  for  each Servlet. </li>
<li>&lt; context-param &gt; is the direct child tag of &lt;web-app &gt; &amp; hence we can declare any where with in  &lt;web-app&gt;  </li>
<li>The  context  initialization  parameters  are  available through out the web-application any where. </li>
<li>If we want to use same init-parameters then we  can  declare at  context-level  as<br>
			<pre> 
&lt;context-param&gt;
	&lt;param-name&gt;username&lt;/param-name&gt;<br>	&lt;param-value&gt;scott&lt;/param-value&gt;<br>&lt;/context-param&gt;<br>
			</pre>
	</li>
	<li>With in the Servlet we can access  these  context initialization  parameters by  using  ServletContext object. </li>
	<li>We can get ServletContext  object  by using getServletContext( )  of   ServletConfig  interface. 
	<br>
	With in out Servlet  the following 3 possible ways to  get the ServletContext object .	<table border="2"  bordercolor="red" ><tr><td>ServletContext  context=getServletContext( ) </td></tr> </table>
	<table border="2"  bordercolor="#009900" ><tr><td>ServletContext  context=getServletConfig().getServletContext( ) </td></tr> </table>
	<table border="2"  bordercolor="#6633CC" ><tr><td>ServletContext  context=this.getServletConfig().getServletContext( ) </td></tr> </table>
	</li> 
	 </ol>
	 <br> We can retrive ServletContext  parameters by using ServletContext object for that purpose
<strong>ServletContext  interface</strong>   defines the  following methods  for  accessing  context  initialization  parameters. 
<ol>
<li>String  getInitParameter(String name)</li>
<li>Enumeration getInitParameterNames( ) </li>
</ol>

<br>Demo  program to display  context  initialization  parameters :
<pre>
public class FirstServlet  extends HttpServlet {	
public void doGet(HttpServletRequest request, HttpServletResponse response)
	                               throws ServletException, IOException {      
PrintWriter out=response.getWriter();
ServletContext  context=this.getServletConfig().getServletContext( );
Enumeration enum=context.getInitParameterNames( );
while(enum.hasMoreElements()){
String paramValue=(String)enum.getInitParameter(paramName);
out.println(paramName+"  ... "+paramValue);
}
}
</pre> 

web.xml


<pre>
&lt;web-app&gt;
  
&lt;context-param&gt;
   &lt;param-name&gt;user&lt;/param-name&gt;
   &lt;param-value&gt;scott&lt;/param-value&gt;
&lt;/context-param&gt;
    
&lt;context-param&gt;
   &lt;param-name&gt;pwd&lt;/param-name&gt;
   &lt;param-value&gt;tiger&lt;/param-value&gt;
&lt;/context-param&gt;
  
&lt;servlet&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;servlet-class&gt;FirstServlet&lt;/servlet-class&gt;
  
  &lt;init-param&gt;
      &lt;param-name&gt;&lt;/param-name&gt;
	  &lt;param-value&gt;&lt;/param-value&gt;
  &lt;/init-param&gt;  
&lt;/servlet&gt;
 
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;first&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/fs&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre>



<p>Note : With in the Servlet if we can call getInitParameter()  directly  then it provides  Servlet initialization parameters but not ServletContext  parameters , hence initparameters by default Servlet initialization parameters.</p>



 
<font color="#ff0000"><u><strong>Note:</strong></u></font>We can Access Servlet initialization parameters  in the following ways .<br>
<pre>
String value=getInitParameter("movie");
String value=getServletConfig( ).getInitParameter("movie");
</pre>
<br>
We can Access context  initialization parameters  in the following ways . 
<pre>
String value=getServletContext( ).getInitParameter("movie");
String value=getServletConfig( ).getServletContext( ).getInitParameter("movie");
</pre>

<br><br> 
<u><strong><font color="#ff0000">Note: </font></strong></u>
Whether Servlet or context init-parameters ,  these are deploy time constants i.e., from the Servlet , we can read their values but we are not allow to modify&nbsp;  i.e., we have only  getter()'s   but not  setter()'s  


<h2 id="diffinitcontext"> 
<font color="#FFFFFF"><u>Comparision between  Servlet  init &amp; context   initialization parameters : </u></font></h2>

<table bgcolor="yellow" width="99%"  border="2">
<tr><th>Property</th><th>Servlet init-param</th><th>Servlet  context-param</th></tr>

<tr><td>declaration</td>
<td>By using init-param  with in  servlet.<br/>
<pre>
&lt;servlet&gt;
	&lt;init-param&gt;
		&lt;param-name&gt;
		&lt;param-value&gt;
	&lt;/init-param&gt;
&lt;/servlet&gt;
</pre>
</td>
<td>By using init-param  with in  web-app.<br/>
<pre>
&lt;servlet&gt;
	&lt;context-param&gt;
		&lt;param-name&gt;
		&lt;param-value&gt;
	&lt;/context-param&gt;
&lt;/servlet&gt;
</pre>
</td></tr>

<tr><td>Servlet code to Access  the parameter</td>
<td>String value=getInitParameter("pname");<br> (or) <br>
String value=getServletConfig( ).getInitParameter("pname");</td>
<td>String value=getServletContext( ).getInitParameter("pname"); <br> (or) <br>
String value=getServletConfig( ).getServletContext( ).getInitParameter("pname");</td></tr>

<tr><td>Availability(Scope)</td>
<td>Available only for a particular Servlet in which  &lt;init-param&gt;  is declared. </td>
<td>Available for all Servlet's &amp; Jsp's   with in the web-application. </td></tr>

</table>
<br>
<h3 id="sscope" style="background-color: rgb(0, 25, 0);"><font color="#FFFFFF">
Servlet Scopes :</font></h3>&nbsp;<font color="#0000ff"> 
<u><strong>Objective :</strong></u></font>
For the fundamental  Servlet attribute scopes. (Request, session &amp; context ) 
<ol>
<li>Write Servlet code to add retrieve  and remove  attributes. </li>
<li>For the given scenario  identify  the proper scope. </li>
<li>Identify  multithreading issues   associated  with each  scope.</li>
</ol>
There are 3 types of  parameters  available.
<ol>
<li>Form parameters or Request parameters</li>
<li>Servlet Initialization parameters </li>
<li>ServletContext parameters </li>
</ol>
<br> 
<font color="#800040"><strong>Attribute </strong>:</font> Place holder to store the information with in the web-application.  <br>
<p>
The main purpose of these parameters are to bring information from outside environment into the Servlet , and these are  read-only .</p>
Based on our requirement we can't create a new parameter , we can't  modify  and we can't remove  existing parameters  with in the Servlet. Here  we can't use parameters  to  store  and share  information between  the  components of application.  <br>
To handle this requirement  sun people introduced attributes concept. <br>
<p>Based on our requirement we can create a new  attribute , we can modify and remove  existing attributes. Hence attributes concept is best suitable to store and share information between the components of web-application.</p> <br>
Based on our requirement , we have to store this attributes into the proper scopes. <br><br> 
<strong>There are 3 scopes are possible in the Servlets . 
</strong><ol>
<li>Request Scope </li>
<li>Session Scope </li>
<li>Application (or) context scope </li>
</ol> 
 
<h5 id="reqscope"><u><font color="#400080">Request Scope :  
</font></u></h5><ol>
<li>We can maintain request scope by using  ServletRequest ( or ) HttpServletRequest object . </li>
<li>Request  scope will start at the  time of request object  creation (i.e., just before starting service( ) ) and end at the time of  request  object destruction i.e.,  just  after completing  service( )  </li>
 <li>The information stored in  request scope is available for  all  components  which are processing  that  request. </li>
</ol> 
 
<strong>ServletRequest interface  defines  the following   methods  to  perform  attribute  management  in  request scope : 
</strong><ol>
<li> <table  border="2" ><tr><td> public void setAttribute(String name , Object value) </td></tr> 	</table>
	
		To add  an attribute. <br>
		If the specified  attribute  is already  available , then the old value replaced with new  value.<br>
</li>
<li> <table  border="2" ><tr><td> public  Object getAttribute(String name) </td></tr> 	</table>
	Returns  the value associated  with specified  attribute.<br>
	If the attribute is not available  then we will get null.</li>
	
<li><table  border="2" ><tr><td>public void removeAttribute(String  name); </td></tr> 	</table>This method remove an specified attribute  from request  scope.   </li>
<li><table  border="2" ><tr><td> public Enumeration  getAttributeNames( ); </td></tr> 	</table>This  method returns all attribute names  associated with request object.</li>
</ol>

The most common area  where  we can use  request  scope  is  RequestDispatcher  forward and include mechanisms.

<br> 
<strong>Note: 
</strong><ol>
<li>Adding an attribute in a scope is  called  attribute  binding , where as removing an  attribute  from  a scope  is called  attribute unbinding.</li>
<li>In any scope , attribute name should be unique  i.e., there is no chance of existing  2  attributes with in same  name  in the  same scope. </li>
</ol> 
 
 
<h6 id="sesscope"><u>Session Scope :  
</u></h6><ol>
<li>This scope is maintained  by  HttpSession  object. </li>
<li>Session scope will start  at the time of session  object  creation &amp; ends  at the time of session object destruction. </li>
<li>Information stored in the  session scope is available  for  all  components  which are participating in that Session. </li>
</ol> 
 
<strong>HttpSession interface  defines the  following methods  to perform  attribute  management  in session scope : 
</strong><ol>
<li>public  void  setAttribute(String name , Object value)  </li>
<li>public   Object   getAttribute(String name) </li>
<li>public void removeAttribute(String name ) </li>
<li>public  Enumeration getAttributeNames( )  </li>
</ol> 
 
<u><strong>Note : 
</strong></u><ul>
<li>Once session expires we can't   call these  methods , Other wise we will get "IllegalStateException".
<pre>
session.invalidate();
session.getAttribute("raja");
</pre> </li><li> 
	<u><font color="#0000ff">EX</font></u>: Login   information should be available for  entire session . Hence we have to store this information  in the Session scope .  
   </li>
</ul>


<br> 
 
<h5 id="appscope"><u>Application Scope (or) Context Scope :</u> </h5>
<ol>
<li>This Scope is maintained by ServletContext  object. </li>
<li>Application scope will start  at the time of  context object creation and end at the time of Context object destruction. i.e., application scope will start  at application deployment time/server start up   and  ends at application undeployment/server shutdown.</li>
<li>The information stored in the application  scope will be available for all components of web application irrespective of end-user. </li>
</ol> 
 
<strong>ServletContext  defines the following methods  for attribute management in  application scope : 
</strong><ol>
<li>public void setAttribute(String name , Object value) </li>
<li>public Object getAttribute(String name ) </li>
<li>public void removeAttribute(String name ) </li>
<li>public  Enumeration getAttributeNames( )  </li>
</ol> 
 
<h6 id="multi"><u>Multithreading  issues associated  with  each scope : </u>
</h6><ol>
<li>For every request , a new request object will be created which is accessed  by  only  current thread. Other threads are not allowed to access  request scoped attributes . Hence request scoped attribute are  always Thread-safe. </li>
<li>With in the same session , we can send  multiple requests symultaneously by opening new browser window . Hence Session object can be accessed  simultaneously  by multiple threads. Hence Session scoped attributes  are not Thread-safe . </li>
<li>Context scoped attributes  can be accessed  simultaneously  by  multiple threads. Hence these are not Thread-safe.</li>
<li>Instance &amp; static variables of Servlet can be  accessed simultaneously by multiple  threads, hence these are not Thread-safe. </li>
 <li>For every thread a seperate copy of local variable will be created. Hence these local variables are Thread-safe. </li>
</ol>

<table   width="70%" border="2">
<tr><th>Member</th>
<th>is Thread Safe ?</th></tr>	

<tr><td>Request Scoped attributes</td>
<td>YES</td></tr>

<tr><td>Session Scoped attributes</td>
<td>NO</td></tr>

<tr><td>Context  Scoped attributes</td>
<td>NO</td></tr>

<tr><td>Static   Variables</td>
<td>NO</td></tr>

<tr><td>Instance  Variables</td>
<td>NO</td></tr>

<tr><td>Local  Variables</td>
<td>YES</td></tr>

</table> 
 <br>
Parameters are key-value  pairs . <br>Both key &amp; value are  String objects. <br>Hence at the time of  retrieval  it is not required to perform any  type -casting . <br>We  can assign directly parameter value  to the String type variable  without  performing any type-casting.
<pre>
String  pvalue=request.getParameter(&quot;user&quot;); 
String  pvalue=request.getInitParameter(&quot;user&quot;); 
</pre> 
Attributes also key-value pairs but keys are String type and values can be  any Object type. <br>Hence at the time of retrival. Compulsary  we should  perform type-casting.<br>

<pre>
String value = request.getAttribute("user"); 
CompiletimeError:Incompatible types
           found:java.lang.Object
        required:java.lang.String  
</pre>
<br>
String value=(String)request.getAttribute("user");
<h5>

IIQ: To access the  value  of  request scoped attribute  user, which of the following is valid ?</h5>
<ol>
<li>String user=getParameter("user");  -----&gt; invalid</li>
<li>String user=request.getParameter("user"); -----&gt; invalid </li>
<li>String user=request.getInitParameter("user"); -----&gt; invalid </li>
<li>String user=request.getAttribute("user"); -----&gt; invalid </li>
<li>String user=(String)request.getAttribute("user");-----&gt; valid </li>
</ol>
<b>Example :</b>
<pre>
public class FirstServlet extends HttpServlet {

StringBuffer buffer1=new StringBuffer("raja");
static StringBuffer buffer2=new StringBuffer();
	
 public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  StringBuffer filter=new StringBuffer();
  HttpSession session=request.getSession();  
 }
</pre>
The  above example which of the following are Thread Safe ?
<ol>
<li>buffer1 <img src="wrong.png"></li><li>buffer2 <img src="wrong.png"></li><li>request <img src="right.png"></li><li>filter <img src="right.png"></li><li>session <img src="wrong.png"></li>
</ol>
<br>
<h2 id="diffparamattribute"> 
 
Differences  between  parameters  and  attributes : 
</h2>

<table   width="99%" border="2" >
<tr><th>Parameters</th><th>Attributes</th></tr>
 
<tr>
<td>We can use parameters to bring information from  outside environment  into  Servlet.</td>
<td>We  can use attributes  to share  information with in the application between components.</td>
</tr>

<tr>
<td>Parameters are read-only.   i.e., with in the Servlet we can perform only  read-operation  and  we can't modify their  values  i.e.,  we have  only getter methods  but  not  Setter. </td>
<td>Attributes are not read-only. We have both getter &amp; setter methods.  Based on our  requirement we can  create a new attribute remove &amp; replace already existing attributes.</td>
</tr>

<tr>
<td>Parameters  are  deployment  time constants.</td>
<td>Attributes  are  not  deployment  time constants</td>
</tr>

<tr>
<td>Parameters are  key-value  pairs  where  both key &amp; value  String objects only.<br>key ----&gt;String <br>value ---&gt; String </td>
<td>Attributes  are  key-value  pairs  where   key is  String type  but  value can be any Object type .<br>key ----&gt;String <br>value ---&gt; Object</td>
</tr>

<tr>
<td>At the time of retrieval  it is not required  to perform  any type-casting.</td>
<td>At the time of retrieval  compulsary  we should  perform type-casting.</td>
</tr>
</table><br>

CustRequest.java
<pre>
public class CustRequest extends HttpServletRequestWrapper{
	
	public CustRequest(HttpServletRequest request) {
		super(request);
	}

	public String getString(String word){
		String word1=super.getParameter(word);
		if(word1.equals("java")|| word1.equals("scjp")) 
			return word;
		else
			return word1;
	}
}
</pre>

TargetServlet.java
<pre>
public class TargetServlet extends HttpServlet {
public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		
		PrintWriter out = response.getWriter();
		String word=((ServletRequest) response).getParameter("word");
		out.println("You  typed :"+word);
	}
}
</pre>

<ol>
<li>Usage  Filters Concept  in out web application is considered as following "Intercepting Filter Design pattern".</li>
<li>Usage of  Wrapper concept in our web-application is considered as "decorator design pattern".  </li>
</ol>



<h5 id="printcontext">Demo program to print all context scoped attributes:</h5>
<pre>
public class ContextAttributeDemo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  PrintWriter out = response.getWriter();
  out.println("&lt;h1&gt;Context Attributes &lt;/h1&gt;");
  ServletContext context=getServletContext();
  context.setAttribute("course", "SCWCD");
  Enumeration e=context.getAttributeNames();
  
  while (e.hasMoreElements()) {
	String aname = (String) e.nextElement();
	Object avalue=context.getAttribute(aname);
	out.println(aname+"......."+avalue+"&lt;br&gt;");	
  }
}
}

<u>output :</u>

org.apache.catalina.resources.......
   org.apache.naming.resources.ProxyDirContext@50a649
   
course.......SCWCD

com.sun.faces.config.WebConfiguration.......
     com.sun.faces.config.WebConfiguration@d507e9
	 
org.apache.AnnotationProcessor.......
    org.apache.catalina.util.DefaultAnnotationProcessor@1fa6d18
</pre>
   
   For every web-application , web-container always add some attributes in application Scope  for its internal  purpose. Here context  Scoped attributes  never be empty.<br>
   
 <h6 id="printhit">  
   Ex 2: Write a program to print hit  count  of the web-application:<br>	(i.e., to print no. of requests  to the web-application)</h6> 
<pre> 
public class HitCountDemo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 PrintWriter out = response.getWriter();
 ServletContext context=getServletContext();

 Integer count=(Integer)context.getAttribute("hitcount");
 if(count==null){
	 count=1;
 }
 else {
	 count++;
 }
 
context.setAttribute("hitcount", count);
out.println("Hit Count is :"+count);
System.out.println("count : "+count);
}
}
</pre> 
   <u><strong>Note:</strong></u>The main limitation of this program is count value can't persist across application re-deployment  and restarts. <br><br>
   Incrementing  the count value  code, we have to place in every  Servlet which may result  duplicate code  and  cause several problems. We can resoive  these  problems by  using Listeners.<br>
   <h5 id="printreq">Write a program  to print no. of  requests  send in each(current)    Session.</h5>
<pre>
public class SessionCount extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
 PrintWriter out=response.getWriter();
 HttpSession session=request.getSession();
 Integer count=(Integer)session.getAttribute("hitcount");
 
 if(count==null)
	 count=1;
 else
	 count++;
 
 session.setAttribute("hitcount", count);
 out.println("The no.of counts in Session is :"+ count);
}
}
</pre>
  
  <ul><li> 
   For every browser  new  Session  will be  created.</li><li>Per every user count value is : 1 (first browser)</li> <li>Other browser  value  : 2 <br>(From one browser if we send any no.of requests, count  value won't  be  increase.)</li> <li>
   If we open  new browser(tab)   from old-----&gt;file -----&gt; new ----&gt; window</li></ul>
   <br>
   <h5 id="printsession">Write a  program  to print  no.of  Session  objects  created in application<br>	(i.e., to print total  no. of users  login to the application): </h5>
<pre>
public class UserCount extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 PrintWriter out = response.getWriter();
 ServletContext context=getServletContext();
 Integer count=(Integer)context.getAttribute("hitcount");
 HttpSession session=request.getSession();
 
 if(session.isNew()) {
	 if(count==null)
		 count=1;
	 else
		 count++;
	 
	 context.setAttribute("hitcount", count);
 }
 out.println("No of Users logged in : "+ count);
}

}
</pre>
  
   
<h5 id="triggered">WAP to display no. of  requests triggered  Ip-address wise. (from same machine): </h5>
<pre>
public class IPAddress extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 ServletContext context=getServletContext();
 String ipaddress=request.getRemoteAddr();
 Integer count=(Integer)context.getAttribute(ipaddress);
 
 if(count==null){
	 count=1;
 }
 else {
	 count++;
 }
 
 context.setAttribute(ipaddress, count);
 out.println("The no. of requests : "+ count);
}
}
</pre>    
    
<h6 id="contextscope">How do we make  Context scoped attributes Thread safe ?</h6> 
 
<img src="contain1/con1.png" width="955">

<br>

<pre>
public class ContextScopeThreadSafe extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("The Context coped Attributes : ");
 getServletContext().setAttribute("foo", "42");
 getServletContext().setAttribute("ball","22");
 out.println(getServletContext().getAttribute("foo"));
 out.println(getServletContext().getAttribute("ball"));	
}
}
</pre>

<h6>Step 1 : </h6>
Servlet A set the ContextAttribute foo  with the value 42<br>
<img src="contain1/con2.png">

<h6>Step 2 : </h6>
Servlet A set the ContextAttribute ball  with the value 22
<br><img src="contain1/con3.png">

<h6>Step 3 : </h6>
Thread B becomes the running Thread(Thread A  goes back to runnable but not running) and set the context attributes  ball  with  value of  16.  <br>
<img src="contain1/con4.png">

<h6>Step 4 : </h6>
Thread A  become  the running Thread again  and get the value of ball  and print it's  to the response.
<br>
<img src="contain1/con5.png">
<br><br>

<pre>
public synchronized void doGet(HttpServletRequest request, 
      HttpServletResponse response)throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("The Context coped Attributes : ");
  --------------------
}
</pre>
synchronized a doGet() won't product Context attributes.
<p>
synchronizing  doGet() means that only one Thread of Servlet A  can be running at a time it doesn't stop  other servlets or jsp's  from  accessing  context  scoped attributes.</p>

<p>
synchronizing doGet() would stop other Threads  from the same Servlet from accessing  context scoped attributes  but it  won't to any thing  to stop a completely  different   servlets  or  jsp's 
</p>
  <h5>Note : </h5> We  don't need lock on the servlet object , we need to lock on ServletContext.The typical way to protect context attributes syncronize on context object it self.
  
  <p>If every one accessing  context attributes get the lock on context  object then you are guarantee  that only one method  at a time can be getting  or setting  context scoped  attibutes.</p>
  
  
<pre>
public class ContextSyncronize extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("Test the Context scoped Attributes :");

 synchronized (getServletContext()) {
  getServletContext().setAttribute("foo", "42");
  getServletContext().setAttribute("ball", "22");
  out.println(getServletContext().getAttribute("foo"));
  out.println(getServletContext().getAttribute("ball"));
 }
 }
}
</pre>  
  
  Now  we are getting lock on Contect object , in this way to proteced Context scoped attributes (you don't want  to lock on Servlet object , synchronized(this) )  <br>


   <h2 id="rdispatcher" style="background-color: rgb(0, 0, 160);"> 
   <font color="#ffffff">RequestDispatcher:</font></h2><font color="#0000ff"><strong>Objective: 
   </strong></font><ol><li>Describes RequestDispatcher  mechanism. </li>
   <li>Write Servlet code  to create  RequestDispatcher. </li>
   <li>Write  Servlet code to forward or  include  target  resource.</li>
   <li>Identify  and describe the attributes added  by web-container while forwarding  and including.</li>
    </ol> 
    <strong>It is not recommended  to define  entire  functionality  in a single component. It has several serious  dis-advantages: 
    </strong><ol>
    <li>For every change re-design of component is  required. Hence enhancement will become  very complex and creates maintainability problems.</li>
    <li>It doesn't  promote re-usability  of the  code. <br>
    		We can resolve these  problems  by  maintaining  a  separate component  for each  task. </li> 
     </ol> 
<br><img src="contain1/con6.png"><br>      
     <strong>The main advantages of this approach is : 
     </strong><ol>
     <li>With out effecting   remaining  components , we can  modify any  component. Hence enhancement will become very easy  and improves  maintainability. </li>
     <li>This approach promotes re-usability of the code. </li> 
     </ol> 
     <strong>Example: 
     </strong><ol>
     <li>Where ever validation  logic is  required we can reuse same validation logic  without re-writing. </li>
     <li>If the functionality  is distributed across several components, these components have to communicate with each other to provide response to end-user. We can achieve  this communication  by using RequestDispatcher.</li>
     </ol>
	 <h5>   Servlet code to get RequestDispatcher : </h5>
   We can get RequestDispatcher  either by  ServletRequest object (or) by ServletContext object.<br>
   
   <br> 
    
   <u><font color="#ff0000"><strong>By ServletRequest </strong></font>:</u><br><br>&nbsp;ServletRequest interface  defines  the following  method to get RequestDispatcher object. <br>
   <table  border="2">
   <tr>
   <td>public  RequestDispatcher  getRequestDispatcher("String  target") </td>
   </tr>  
  </table> <br>
   
  The target resource path can be specified either  by absolute path (or) relative path. <br>
   
  <strong>Example: 
  </strong>
<pre>RequestDispatcher rd=request.getRequestDispatcher(&quot;/test2&quot;); //absolute path
RequestDispatcher rd=request.getRequestDispatcher(&quot;test2&quot;); //relative path
</pre>
  
  If the target resource is not available then we will get 404  status code saying requested   resource is not available. 
  
  <h5><u><font color="#ff0000">By  ServletContext object : 
  </font></u></h5>
  ServletContext  interface  defines the following 2 methods to get the  RequestDispatcher object.<br>
  <table  border="2">
  <tr>
  <td>public RequestDispatcher getRequestDispatcher("String  target"); </td>
  </tr>
  </table> 
   
  Target resource path compulsory  we should specifying  by using absolute path. If we are using  relative path  then we will get  <strong>IllegalArgumentException</strong>.<br> 
  <strong>Ex: </strong><br>
  RequestDispatcher rd=context.getRequestDispatcher("/test2"); //valid  because absolute path<br>
  RequestDispatcher rd=context.getRequestDispatcher("test2"); //IllegalArgumentException because  relative path <br>
  <br>
  If the target resource is not  available , then we will get 404 status code. <br>
  <br>
  
   <table  border="2">
   <tr>
   <td>public  RequestDispatcher  getNamedDispatcher("String  servletName") ;   //in this servletName is logicalname </td>
   </tr>  
  </table>
  <ol>
  <li>If URL pattern is not defined  for the target Servlet then we have to use this method.</li>
  <li>The  argument represents  the value associated  with Servlet name tag in web.xml  which represents  logical  name of the Servlet. </li>
  <li>If the target Servlet  is  not available  then we will get null but not 404 status code .On that null if we are trying to perform  forward (or) including we will NullPointerException. </li>
   </ol> 
   <strong>Ex: 
   </strong>
   
   <table  border="2">
   <tr><td>RequestDispatcher rd=context.getNamedDispatcher("targetServlet");	 //in this targetServlet is logicalname </td></tr>
   </table>
   <br> 
   <h3 id="diffsrsc"><u><strong><font color="#ffffff">Differences  between  getting RequestDispatcher by ServletRequest &amp; ServletContext : 
   </font></strong></u></h3>
   
   <table border="2">
   <tr><th width="50%">RequestDispatcher  from ServletRequest</th><th>RequestDispatcher  from ServletContext</th></tr>
   
   <tr>
   <td>RequestDispatcher rd = request.getRequestDispatcher("/test2");<br><br>
 		    RequestDispatcher rd = request.getRequestDispatcher("test2");<br><br>
 		    The  target  resource can be  specified  either by absolute path (or) relative path. 
  </td>
   <td> RequestDispatcher rd = context.getRequestDispatcher("/test2"); <br><br>
 			
 			 The  target  resource should  be  specified  only by absolute path but not  relative path. Otherwise  we will get IllegalArgumentException.  
    </td>
   </tr>
   
   <tr>
   <td>We can use  this RequestDispatcher  to communicate  only with in the same application</td>
   <td>We  can use  this  to communicate  either with in the same or  outside of the application . But  recommended to use to communicate  outside of the web-application</td> 
   </tr>
   
   <tr>
   <td>We  can't get RequestDispatcher by &lt;servlet-name&gt; tag</td>
   <td>We  can get RequestDispatcher by &lt;servlet-name&gt;  for this we have getNamedDispatcher( )</td>
   </tr>   
</table>

<br> <u>
Note : </u>  &lt;servlet-mapping&gt; tag is optional  to configure  servlet  with in the web.xml , that time nobody can access that servlet  directly  from browser, in that case  the remaining  servlets can  communicate  by using  it's logical name.




<h5 id="rdmethod">RequestDispatcher's methods :</h5> 
RequestDispatcher interface  defines the following  2  methods. 
<ol>
<li>public void forward(ServletRequest request, ServletResponse response) throws ServletException, IOException </li>
<li>public void include(ServletRequest request, ServletResponse response) throws ServletException, IOException</li>
</ol><h2 id="forward" style="background-color: rgb(0, 0, 128);"> 
 
<font color="#ffffff">Forward mechanism :</font></h2><img src="contain1/con7.png">
<ol>
<li>If the 1<sup>st</sup>  Servlet is responsible for  some preliminary  processing &amp;  2<sup>nd</sup> Servlet is responsible  to provide  requirement response then we should  go for forward  mechanism.</li>
<li>Just before  forwarding response object will be cleared automatically by the web-container . Hence if any response added by the  first servlet  won't be delivered to the end-user. Only second servlet response will be displayed.</li>
<li>In forward mechanism second  servlet has  complete  control on response object. Hence it can change response headers like  contentType( ) .  </li>
<li>In forward mechanism , the same request object  will be forwarded  to the second servlet. Hence information sharing between the components is always possible  in the form of request scoped attributes. </li>
<li>After forwarding the request to second  servlet the control will come to the first servlet again to execute remaining  statements. In the remaining statements  if we are trying to write anything to the  response these statements will be ignored by the web-container. In the remaining statements if any exception  raised  only  that exception  information will be displayed for  end user instead of  second servlet response .  i.e.,  Second servlet response will be delivered after  completing remaining statements execution only. </li>
</ol>
 Ex:   
<pre>
public class ForwardServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("Hello");
 RequestDispatcher rd=request.getRequestDispatcher("/forward2");
 rd.forward(request,response);
 out.println("Hi");
 System.out.println(10/0);  //--&gt;1
}
}   
</pre>

<pre>
public class ForwardTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("This is Second Forward Servlet ");
}
}
</pre>
   
   <ul><li>  If we are sending the request to the FirstServlet,  ArithmeticException will be displayed for the end-user instead of second Servlet response. </li>
   <li>If we are commenting line1, then only 2<sup>nd</sup> Servlet response will be displayed  for the  end-user.</li>
   <li>Recursive forward call always  raises RuntimeException  saying StackOverFlowError. </li>
   </ul>
 
 After committing the response , we can't perform forward  (or)  redirection . Otherwise we will get RuntimeException saying java.lang.IllegalStateException <br>
 <br>
  Ex:
  <br>

<pre>
public class ForwardTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

  response.setContentType("text/html");
 PrintWriter out = response.getWriter();

 out.println("This is  Forward Servlet ");
 out.flush();
 RequestDispatcher rd=request.getRequestDispatcher("/forward");
 rd.forward(request, response);
  // ---life cycle will start to the second servlet
}
}
</pre>

We can pass Query String as part of forward mechanism

<pre>
public class ForwardTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("This is  Forward Servlet ");
 RequestDispatcher rd=request.getRequestDispatcher("/forward?uname=raja&amp;pwdscwcd");
 rd.forward(request, response);
}
}
</pre>
<pre>
public class ForwardServet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 String name=request.getParameter("uname");
 String pwd=request.getParameter("pwd");
 out.println(name+"........."+pwd);
}
}
</pre>



 
 
login.html
<pre>
&lt;form action="/servlet/vs"&gt;
&lt;table&gt;
&lt;tr&gt;&lt;td&gt;Name :&lt;/td&gt;&lt;td&gt; &lt;input type="text" name="uname"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Password : &lt;/td&gt;&lt;td&gt; &lt;input type="text" name="pwd"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="submit"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;
</pre>


ValidateServlet.java
<pre>
public class ValidateServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("Validate Servlet");
 String name=request.getParameter("uname");
 String pwd=request.getParameter("pwd");
 
if(name.equalsIgnoreCase("raja")&amp;&amp;pwd.equalsIgnoreCase("scwcd")){
	 RequestDispatcher rd=getServletContext().getRequestDispatcher("/inbox.jsp");
	 rd.forward(request, response);
}
else {
	 RequestDispatcher rd=request.getRequestDispatcher("error.jsp");
	 rd.forward(request, response);
 }
}

}
</pre> 
 
 error.jsp
<pre>
Invalid Credentials , please  login here 
&lt;a href="login.html"&gt;LOGIN&lt;/a&gt; 
</pre> 
 
 index.jsp
<pre>
&lt;h1&gt;Successful  Login&lt;/h1&gt;
</pre>

 
 <ul>
 <li>Attributes added  by web-container while forwarding the  request.</li>
 <li>While forwarding the request from  one Servlet to another ,  web-container  will always add  some  attributes  in request  scope to provide Original  request  information to  the  second  Servlet. </li>
 </ul>   
    
 <u><strong>The following is the list of  attributes  added by web-container:</strong></u> 
 <ol>
 <li>javax.servlet.forward.request-uri </li>
 <li>javax.servlet.forward.context-parh </li>
 <li>javax.servlet.forward.servlet-path </li>
 <li>javax.servlet.forward.path-info </li>
 <li>javax.servlet.forward.query-string </li>
 </ol>
 
 <u><strong>Note: 
 </strong></u><ol>
 <li>If we are getting RequestDispatcher by using getNamedDispatcher , the web-container won't add any  attributes in request scope. </li>
 <li>With in the same Servlet we can't call  forward  more than once  directly . Otherwise we will get IllegalStateException.</li>
 </ol>
 
 
    <h2 id="include" style="background-color: rgb(128, 64, 0);"> <font color="#ffffff">Include mechanism :</font></h2>
    
    <ol>
    <li>In several components  required some common functionality, Its never recommended to hardcode that functionality in every component. We have to separate  component  and  we have to make that functionality available by using include mechanism for  every  component.</li>
    <li>This approach promotes code  re-usability and  reduces maintainability problems. </li>
    <li>Hence the maintain  objective of include mechanism is to include the response  of other resourses in the current response . This include is best suitable  for JSP to include  Headers and Footers , Banner information and  Logos  etc. </li>   
    <li>In the include mechanism  the first Servlet  is responsible to provide total response . But it can include the response of some   other  components. </li>
    <li>In the Include, second servlet doesn't  have complete control on the response  object. It is not allowed to change  response  headers , If it is trying to change  these changes will be ignored by web-container. </li>
    </ol>
    
 Ex:
     
<pre>
public class IncludeServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 out.println("First Include Servlet &lt;br&gt;");
 
 RequestDispatcher rd=request.getRequestDispatcher("/include2");
 rd.include(request, response);
 
 out.println("First Include Servlet Again ");
}
}
</pre>

<pre>
public class IncludeTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("Include Second Servlet &lt;br&gt;");	
}
}
</pre>

When ever we are sending  the request  to IncludeServlet the following is the output :
<pre>
First Include Servlet 
Include Second Servlet 
First Include Servlet Again 
</pre>
    
    After committing the response we can  call	 include( )   But we can't call  forward( ) and sendRedirect( ) . <br>
    With in the Servlet we can  call include any no.  of times . But we can call forward( )  only once and mostly as last  statement. <br>
    <br> 
     <h5><u><strong>Attributes  added  by Web-container while performing include </strong>: 
    </u></h5>While performing include  web-container will add  the  following attributes  in request  scope  to  make original  request  information available to the second Servlet. <br>
    <ol>
	  <li>javax.servlet.include.request-uri </li>
	 <li>javax.servlet.include.context-parh </li>
	 <li>javax.servlet.include.servlet-path </li>
	 <li>javax.servlet.include.path-info </li>
	 <li>javax.servlet.include.query-string  </li>
 </ol>  
  
 <u><strong>Note:</strong></u> 
 When ever we are  getting RequestDispatcher  by using getNamedDispatcher( ) , then web-container won't add these attributes in request scope. <br>
 
 
 
<h3 id="diffforinc"> <u><font color="#ffffff">Differences  between forward( )  and  include ( ) :</font></u></h3> 
  
 <table  border="2">
 <tr><th>forward( )</th><th>include( )</th></tr>
 <tr><td><img alt="" src="contain1/con7.png" width="455">  <br> s1  ----&gt;forwarding Servlet<br> s2  ----&gt;forwarded  Servlet  </td><td><img alt="" src="contain1/con8.png" width="455"> <br> s1  ----&gt; including Servlet<br> s2  ----&gt; included  Servlet 	</td></tr>
 <tr><td>Once first Servlet forwards  the request to the second Servlet , second Servlet is completely control on response object , provide the response.  </td><td>In the  case of include first Servlet is responsible  to  provide required response. </td></tr>
 <tr><td>While performing forward  call the response  object  will be  cleared automatically. Hence  FirstServlet response won't  be displayed  for the  end-user.  </td><td>While performing  include, the  response object  won't  be cleared. Hence first servlet response  also will be displayed  for the  end-user. </td></tr>
 <tr><td>After  committing  the response  we  can't   perform  forward. Otherwise we will get IllegalStateException. </td><td>After committing  the response we can call  include  mechanism.  </td></tr>
 <tr><td>With in the same Servlet we can call forward( )  only  once and  mostly  as  the last statement. </td><td>With in the Servlet  we can call  include( )  any no.  of   times. </td></tr>
 <tr><td>In the  case of  forward( ) ,  second Servlet has complete  control  on the  response  object. </td><td>In the case of include , 2 <sup>nd</sup>Servlet doesn't  have  complete  control on the  response  object.  It is  not  allowed  to  change response  headers. </td></tr>
 <tr><td>forward mechanism  we  can use  frequently in Servlets  because   it is  associated  with  processing. </td><td>Include  mechanism  we can use  frequently  in JSP's , Because  it is associated  with view part. </td></tr>
 </table>
 
 
 
 <h5 id="foreign">
 <font color="#ff0000"><u> Foreign  RequestDispatcher :</u></font><br>Inside Servlet1 :</h5>
<pre>
ServletContext  context=getServletContext( ); 
ServletContext  fcontext=context.getServletContext(&quot;/webapp2&quot;); 
RequestDispatcher  rd=fcontext.getRequestDispatcher(&quot;/test2&quot;); 
rd.forward(req , res ); 
</pre>


 <ol>
 <li>By default most of the webservers  including  Tomcat won't   provide  support for cross context communication.</li>
 <li>In this case getRequestDispatcher( )  returns null, on that  null if we are  trying call  forward( ) (or )   include( )  we  will get NullPointerException. </li>
 <li>To  provide support for  cross  context communication  at  Server  level some configuration changes are  required.</li>
 <li>As RequestDispatcher  mechanism  will  work with  in the same server.  Hence  both the applications  should be  deployed  in the same Server.</li>  
 </ol> 
  
  
 <font color="#808040"><u><strong>Important Interview Questions : </strong></u></font>
 <ol>
 <li>What is the  purpose  of  RequestDispatcher ? </li>
 <li>Explain RequestDispatcher   mechanism ? </li>
 <li>Differences  between context.getRequestDispatcher() &amp; context.getNamedDispatcher( ) ? </li>
 <li>Various possible ways to get RequestDispatcher  ? </li>
  <li>Differences  betwee forward  &amp;  sendRedirection  ?  </li>
  <li>What is the Difference  betwee forward  &amp;  include ? </li>
  <li>What is foreign  RequestDispatcher    and how we can get ? </li>
  <li>Explain RequestDispatcher  mechanism   between  2  applications  of the same  Server ? </li>
  <li>What are the  attributes  added   by the web-container  while  forwarding  and including the request ? </li>
  <li>What is the purpose  of these  attributes &amp; explain  its  meaning ?  </li>
 </ol>
 
 <h2 id="filter" style="background-color: rgb(128, 0, 255);">   
 <font color="#ffff00"><u>FILTERS</u>&nbsp;  (</font><font color="#ffff00">servlet 2.3 v) :  
   
</font></h2><u><strong><font color="#0000ff">Objective :</font></strong></u> 
<ol>
<li>Describe  web-container request processing model. </li>
<li>Write  and  configure  a  filter. </li>
<li>Create a  request  and response  Wrapper  for the  given  design problem.</li>
<li>If we want to perform any activity  at the time of pre-processing and post-processing  of the request. Then we should go for Filters.</li>
<li>This concept introduced in Servlet 2.3 version. </li>
</ol> 
  <img alt="" src="contain1/con9.png"><br>
 <u><strong>The most  common application areas of Filter are...  
 </strong></u><ol>
 <li>Logging </li>
 <li>Security checks like Authentication &amp; Authorization </li>
 <li>Altering request information  </li>
 <li>Altering response information </li>
 <li>Compression of response </li>
 <li>Encryption of response etc. </li>
 </ol> 
  
 <h2 id="filterapi" style="background-color: rgb(255, 0, 0);"><font color="#ffffff"><u><strong>FILTER- API  : </strong></u></font></h2>
 We can develop Filters concept  by using  the following  3  interfaces. 
 <ol>
 <li>Filter </li>
 <li>FilterConfig </li>
 <li>FilterChain </li>
 </ol>
  <br> 
 <h2 id="filt" style="background-color: rgb(255, 0, 128);"><u><font color="#ffffff">Filter :  
 </font></u></h2>Every Filter in java should  implement  Filter interface either directly or indirectly.<br>
 Filter interface  defines  the  following  3  methods. 
 <ol>
 <li>init( ) :
 		<table border="1" ><tr><td>public void init(FilterConfig  config)  throws ServletException </td></tr>	</table>
 		This method will be executed only once to perform initialization  activity after  instantiation immediately. 
 </li>
 <li>destroy( ) :
 		<table border="1"><tr><td>public void destroy( ) </td></tr>	</table>
 		This  method will be executed only once to perform CleanUp activities , just before  taking the Filter  from out of Serice.
 </li>
 <li>doFilter( ) :
 		<table border="1"><tr><td>public void doFilter(ServletRequest request , ServletResponse response, FilterChain  chain)  throws ServletException, IOException </td></tr>	</table>
 		This method will be executed for  every  request, Entire Filtering  logic we have to define in this  method only.<br>
 		We can use FilterChain object to forward the request to the  next level . It can be another Filter (or) Servlet. 
 </li>
 </ol>
  <br><h2 id="fconfig" style="background-color: rgb(0, 128, 64);"> 
 <font color="#ffffff" style="background-color: rgb(128, 128, 192);"><u>FilterConfig : 
 </u></font></h2><ul>
 <li>For  every Filter, web-container creates one  FilterConfig object to hold its configuration information. </li>
 <li>Web-container  handover FilterConfig object to the  Filter as  argument  to init( ) method . </li>
 </ul> 
 <strong>FilterConfig interface defines  the  following 4 methods : 
 </strong><ol>
 <li>public String getFilterName( );  <br>Returns logical name of the  Filter configured in web.xml  by using  &lt;filter-name &gt;  tag .</li>
 <li>public  String getInitParameter(String parameter) </li>
 <li>public Enumeration getInitParameterNames( ) </li>
 <li>public ServletContext getServletContext( ) </li>
  </ol>
<h2 id="fchain"> 
 <font color="#ffffff"><u style="background-color: rgb(128, 128, 192);">FilterChain : 
 </u></font></h2><ul>
 <li>We can use FilterChain to forward the request  to the  next  level.[It may be another filter (or) Servlet ].</li>
 <li>FilterChain interface  defines the following doFilter( ).
<table border="1"><tr><td>public void doFilter(ServletRequest request, ServletResponse response )throws ServletException, IOException</td></tr></table>
 </ul>
 
<pre>
public class FirstFilter implements Filter {
	
 public void init(FilterConfig config) throws ServletException {
 }

 public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
  PrintWriter out=response.getWriter();
  out.println("This is First Filter before processing the request  
                                         i.e., pre-processing");
	
  chain.doFilter(request, response);
  out.println("This is First Filter after processing the request  
                                       i.e., post-processing");
 }
	
 public void destroy() {
 }

}
</pre>

<pre>
public class TargetServletFilter extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("This is Target Servlet Filter ");
	}
}
</pre>




 
 <br> 
 <u><strong>Analysis :</strong></u> <br><br><img alt="" src="contain1/con91.png">
 <ol>
  <li> When ever we are Sending the  request to the Servlet , web-container checks is any Filter  configured for this Servlet (or)  not  </li>
  <li>If any Filter is configured web-container  forwards the request to the Filter instead of Servlet. </li>
  <li>After completing  Filtering  logic Filter  forwards  the request  to the  TargetServlet. </li>
  <li>After  processing the request by TargetServlet  the response  will be forwarded to the Filter instead of browser.</li>
  <li>After executing Filtering logic , Filter forwards  the total response to the end-user . </li>
</ol>
<br> <h6 id="conweb">Configuring Filter in web.xml  :</h6>
<pre>
  &lt;servlet&gt;
    &lt;servlet-name&gt;TargetServletFilter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;jobs.TargetServletFilter&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetServletFilter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/tsfilter&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

  &lt;filter&gt;
    &lt;filter-name&gt;firstfilter&lt;/filter-name&gt;
    &lt;filter-class&gt;jobs.FirstFilter&lt;/filter-class&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;firstfilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/tsfilter&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</pre> 
 
<br><u>Note:</u> 
The life cycle of a Filter will start at the time of application deployment (or) Server startup.i.e., Filter class loading, instantiation and execution of init( )  will be performed automatically at the time of either application deployment  or Server StartUp. Hence load-on-startup  concept is not applicable for Filters.<br>
Web-container is responsible to perform instantiation  of the Filter for this it always calls public no-argument constructor . Hence every Filter class  should compulsory contain public no-argument constructor.<br>

 
<h4 id="mapping">Mapping of Filter : 
</h4>
We can map a Filter either for a particular url-pattern (or) to a particular Servlet (or) to the whole web-application.
<h6 id="mapurl">
Mapping to a particular  url-pattern :</h6>
<pre> 
&lt;filter-mapping&gt; 
	&lt;filter-name&gt;DemoFilter&lt;filter-name&gt; 
	&lt;url-pattern&gt;/test&lt;/url-pattern&gt; 
&lt;/filter-mapping&gt; 
 
</pre>  
When ever  we are  sending a request for with  specified  url-pattern  then only  Filter will  be executed.

<h5 id="mapservlet">
Mapping to a  particular Servlet :</h5>

<pre>
&lt;filter-mapping&gt;
  &lt;filter-name&gt;DemoFilter&lt;/filter-name&gt;
  &lt;servlet-name&gt;TargetServlet&lt;/servlet-name&gt;
&lt;/filter-mapping&gt;
</pre>

Once Servlet got the request automatically&nbsp; Filter&nbsp; will be executed.
<h6 id="mapwebapp">Filter mapping to entire web-application :</h6>

For any request  to the  web-application , whether  it is for Servlet or JSP , this Filter will be executed.<br> 
<u><strong>Note:</strong></u> 
Mapping a Filter to the whole web-application is possible from Servlet 2.5 version onwards only.
<h3 id="dispatchertag"> 
<u>&lt;dispatcher&gt;  : </u></h3>
A servlet  can get the request  in one of the following possible ways. <br> 
<img alt="" src="contain1/con101.png">
<pre>
A request directly  from the browser. (REQUEST )
By RequestDispatcher 's  forward call. (FORWARD)
By RequestDispatcher's include call. (INCLUDE )
By RequestDispatcher's error call. (ERROR) 
</pre>
<ul><li>
By default Filter will be executed   only for  direct end-user request, and won't be executed   for  RequestDispatcher's   forward &amp; include  and error-page   calls. 
</li>
<li>But in Servlet 2.4  version Sun people introduced &lt;dispatcher&gt;   to extend Filter concepts for  remaining cases also. i.e.,  for which type of request Filter will be  executed is decided by &lt; dispatcher &gt;  tag.</li>
</ul> 
<strong>The allowed values for &lt;dispatcher &gt;  tag are... 
</strong><ul>
<li>REQUEST</li><li>FORWARD</li><li>INCLUDE</li><li>ERROR</li>
</ul> 
 
<u><strong>Ex</strong></u>: 

If we want to execute  Filter for direct end-user request and for RequestDispatcher's  forward call.We have to configure &lt;filter-mapping &gt;  tag as  follows.

<pre>
&lt;filter-mapping&gt;
 &lt;filter-name&gt;DemoFilter&lt;/filter-name&gt;
 &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
 &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
 &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;<br>
</pre>

In this case Filter won't be executed for RequestDispatcher's INCLUDE call and ERROR page call.
<br><br><u><strong>Ex 2 :</strong></u>  
To execute a Filter only for RequestDispatcher's include call we have to configure &lt;filter-mapping&gt; as follows.

<pre>
&lt;filter-mapping&gt;
 &lt;filter-name&gt;
 &lt;url-pattern&gt;
 &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</pre>

When ever we are Using &lt;dispatcher&gt; tag,
 then default behaviour won't be reflected. i.e., we are Overriding default-behaviour by using &lt;dispatcher&gt; tag.<br> 
 
<br><u><strong>Demo Program : 
</strong></u>
<br><img alt="" src="contain1/con10.png">
 
 
<br>FirstDispatcherServlet.java 
<pre>
public class FirstDispatcherServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 
 out.println("First Dispatcher Servlet Pre-processing&lt;br&gt;");
 RequestDispatcher rd=request.getRequestDispatcher("/dispatcher1");
 rd.include(request, response);
 out.println("&lt;br&gt;First Dispatcher Servlet Post-processing&lt;br&gt;");
}
}
</pre>
 
TargetDispatcherServlet.java 
<pre>
public class TargetDispatcherServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

 response.setContentType("text/html");
 PrintWriter out = response.getWriter();
 for(int i=0;i&lt;5;i++)
 out.println("&lt;br&gt;This is Target Dispatcher Servlet"+i+"&lt;br&gt;");
}
}
</pre>
TargetDispatcherServletTwo.java
<pre>
public class TargetDispatcherServletTwo extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println(10/0);
	}

}

</pre>
DispatcherFilter.java
<pre>
public class DispatcherFilter implements Filter {

public void destroy() {
 System.out.println("Destroy method");		
}

public void doFilter(ServletRequest request, ServletResponse response,
	FilterChain chain) throws IOException, ServletException {
 PrintWriter out=response.getWriter();
 out.println("&lt;br&gt;This is First Filter before processing the request
                             i.e., pre-processing&lt;br&gt;");
			
 chain.doFilter(request, response);
  out.println("&lt;br&gt;This is First Filter after processing the request
                            i.e., post-processing&lt;br&gt;");
}

public void init(FilterConfig config) throws ServletException {
 System.out.println("Filter init method");
}
}
</pre>


<br>
We can configure more than  one Filter for a TargetServlet and all these Filters  will be  executed one by one and forms FilterChain.<br>
<img alt="" src="contain1/con11.png" width="950"><br><br>
Demo program : 
<br><img alt="" src="contain1/con111.png" width="950">
<br> 
 
<u><strong>Note :</strong></u> 
The log information will be stored in the  following  file locating in logs folder of Tomcat.(localhost.2013.04.16.txt........date) 
<br> 
<strong>Web-container's  rule for  ordering  of Filters in FilterChain : 
</strong><ol>
<li>Identify all Filters  which are  configured  according to url-pattern and Execute  all these filters  from top to bottom .</li>
<li>Identify all Filters which are  configured  according to servlet-name  and execute all these Filters  from top- to- bottom.
	<br>	i.e., The Filters which are configured  by url pattrens  will get high priority  when compared  with Filters which are  configured by servlet-name.
</li>
</ol>
Ex:
<pre>
&lt;filter-mapping&gt;
  &lt;filter-name&gt;Filter1&lt;/filter-name&gt;
  &lt;url-pattern&gt;/Recipes/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
 
&lt;filter-mapping&gt;
  &lt;filter-name&gt;Filter2&lt;/filter-name&gt;
  &lt;url-pattern&gt;/Recipes/HotList.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
 
&lt;filter-mapping&gt;
  &lt;filter-name&gt;Filter3&lt;/filter-name&gt;
  &lt;url-pattern&gt;/Recipes/Add/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

&lt;filter-mapping&gt;
  &lt;filter-name&gt;Filter4&lt;/filter-name&gt;
  &lt;url-pattern&gt;/Recipes/Modify/Modify.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
 
&lt;filter-mapping&gt;
  &lt;filter-name&gt;Filter5&lt;/filter-name&gt;
  &lt;url-pattern&gt;*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</pre>

<table border="1">
<tr><th>Request URI</th><th>Order of Execution</th></tr>
<tr><td>/Recipes/HotList.do</td><td>Filter 1,5,2</td></tr>
<tr><td>/Recipes/HotReport.do</td><td>Filter  1,5</td></tr>
<tr><td>/HotList.do</td><td>Filter 5</td></tr>
<tr><td>/Recipes/Modify/Modify.do</td><td>Filter 1,5,4</td></tr>
<tr><td>/Recipes/Add/AddRecipes.do</td><td>Filter 1,3,5 </td></tr>
</table>



<h6 id="difffilter">Difference between Filter's doFilter()  and  FilterChain's doFilter() :</h6>


<table bgcolor="yellow"  style="font-size: 25" border="1">
 <tr><th>Filter's  doFilter( )</th><th>FilterChain's  doFilter( )  </th></tr>
 <tr><td>public void doFilter(ServletRequest  request , ServletResponse response , FilterChain fc) throws ServletException, IOException </td><td>public void doFilter(ServletRequest  request , ServletResponse response ) throws ServletException, IOException </td></tr>
 <tr><td>We can use this method to  define entire  filtering logic.</td><td>We  can use  this  method to  forward  request  to the  next   level. </td></tr>
 <tr><td>This doFilter( )  is a callback  method because web-container  will call this method  automatically for every  request. </td><td>It is a inline method  because  we have to call this  method  explicitly then  only it will be  executed .</td></tr>
 </table>
 
 <br>
 <br> 
 <h2 id="wrapper">Wrappers :</h2>
 <ul>
 <li>Some times it is required to alter request  and response information in  filters , we can achieve this by using Wrapper  class. <br>
	 Ex 1: With in the filter  we have to convert  end-users  resume format from PDF to DOC file ,  We can achieve this by Wrapper. <br>
	 Ex 2: In the filter  we have to compress  the  response  and  we can  send  that  compressed  response to  the  end-user. So that we can reduce  download  time,  We can achieve  this by using Wrapper. 
 </li>
 </ul> 
  
 <strong>There  are 2 types of  Wrapper classes  
 </strong><ol>
 <li>RequestWrapper </li>
 <li>ResponseWrapper</li>
 </ol> 
  
<h3 id="reqwra">RequestWrapper : </h3>
<ul>
 <li>To alter request  information </li>
 </ul> 
 <strong>There are 2 types of RequestWrapper classes 
 </strong><ol>
 <li>ServletRequestWrapper</li>
 <li>HttpServletRequestWrapper </li>
 </ol>
 <img alt="" src="contain1/con12.png">
 <h4 id="reswra">ResponseWrappers : </h4>
 
 
 <ul>
 <li>To alter response  information </li>
 </ul> 
  
 <strong>There are two types of Response Wrappers.</strong> 
 <ol>
 <li>ServletResponseWrapper</li>
 <li>HttpServletResponseWrapper</li>
 </ol> 
  <img alt="" src="contain1/con13.png">
  
  <br>
 <h3 id="reqpro">Demo program  for  RequestWrapper :</h3>
 (Sending the duplicate manager instead of original manager to the estate ) 
  
 <br> 
<img alt="" src="contain1/con14.png" width="950">
 <br>
 
 <ol>
 <li>End user enter  the word and  click the  submit  button. </li>
 <li>Web-container forwards the request to the  filter  instead of  Servlet. </li>
 <li>Filter creates  a  customized request object  by  using Wrapper. </li>
 <li>Filter  forwards  that  customized  request  object  to the target Servlet instead of Origial request. </li>
 <li>With in the target  Servlet  if we are applying  any  operation  on the request  object  our own  customized behaviour  will be reflected. but not  original request behaviour. </li>
 <li>Target Servlet  prepares the response &amp;  forward  to filter instead  of browser. </li>
 <li>Filter forwards  that  response  to the end-user. </li>  
 </ol>
 
 <h6>Demo Program :</h6>
 
wrapper.html 
<pre>
&lt;form action="./wrapper"&gt;
Enter Word : &lt;input type="text" name="word"&gt;&lt;br&gt;
&lt;input type="submit" value="submit"&gt;
&lt;/form&gt;
</pre>
 
BadWordWrapperFilter.java 
<pre>
public class BadWordWrapperFilter implements Filter {

public void destroy() {
  System.out.println("destroy method");
}

public void doFilter(ServletRequest request, ServletResponse response,
	FilterChain chain) throws IOException, ServletException {
 CustomizeWrapperRequest myRequest=new 
               CustomizeWrapperRequest((HttpServletRequest) request);
 chain.doFilter(myRequest, response);
}

public void init(FilterConfig config) throws ServletException {
  System.out.println("init method");
}
}
</pre>
 
CustomizeWrapperRequest.java
<pre>
public class CustomizeWrapperRequest extends HttpServletRequestWrapper {

public CustomizeWrapperRequest(HttpServletRequest request) {
 super(request);
}
	
public String getParameter(String x) {
 String word1=super.getParameter(x);
		
 if(word1.equalsIgnoreCase("java") || word1.equalsIgnoreCase("scjp") ){
	return "SLEEP";
 }
 else {
	return word1;
 }
}
}
</pre>
TargetWrapperServlet.java
<pre>
public class TargetWrapperServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		String word=request.getParameter("word"); 
		out.println("The Entered word is :"+word);
	}
}
</pre>


<h4 id="respro">Write a Demo program  for response wrapper :</h4>


<img alt="" src="contain1/con15.png">
<br>
ResponseWrapperFilter.java
<pre>
public class ResponseWrapperFilter implements Filter {

public void destroy() {
 System.out.println("Response Wrapper destroy");
}

public void doFilter(ServletRequest request, ServletResponse response,
	FilterChain chain) throws IOException, ServletException {
	
 CustomizeWrapperResponse myReponse=new CustomizeWrapperResponse(
                           (HttpServletResponse) response); 
 chain.doFilter(request, myReponse);
 String text=myReponse.toString();
	
 if(text!=null)
 text=text.toUpperCase();
 response.getWriter().write(text);
}

public void init(FilterConfig config) throws ServletException {
 System.out.println("Response Wrapper init");		
}

}
</pre>
CustomizeWrapperResponse.java
<pre>
public class CustomizeWrapperResponse extends HttpServletResponseWrapper {

	protected CharArrayWriter charWriter;
	protected PrintWriter writer;

	public CustomizeWrapperResponse(HttpServletResponse response) {
		super(response);
		charWriter=new CharArrayWriter();
	}
	
	public PrintWriter getWriter() throws IOException {
		if(writer!=null){
			return writer;
		}
		return writer=new PrintWriter(charWriter);
	}
	
	public String toString() {
		String text=null;
		
		if(writer!=null) {
			text=charWriter.toString();
		}
		return text;
	}

}
</pre>
TargetResponseWrapperServlet.java
<pre>
public class TargetResponseWrapperServlet extends HttpServlet {

public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		response.setContentType("text/html"); 
		PrintWriter out = response.getWriter(); //customize response 
		out.println("Hi Ashok , Wrappers are very easy ");		
	}

}
</pre>


In the above program  some implementations required
<ul>
<li>We have to override getOutputStream() method. </li>
<li>Suppose  if we are getting  PrintWriter and ServletOutputStream , we have  to handle "IllegalStateException".</li> 
</ul>


<ul>
<li>Usage Filter concept in our web application  is considered as  following "Intercepting Filter Design Pattern".</li>
<li>Usage of wrapper concept in our web application is considered as "Decorator Design Pattern".</li> 
</ul>


<h6>all programs web.xml</h6>

<pre>
&lt;web-app&gt;
  
&lt;servlet&gt;
  &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.FirstServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/fs&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;CustRequest&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.CustRequest&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;CustRequest&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/cr&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;


&lt;servlet&gt;
  &lt;servlet-name&gt;TargetServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;TargetServlet&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/ts&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;


&lt;servlet&gt;
  &lt;servlet-name&gt;ContextAttributeDemo&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ContextAttributeDemo&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;ContextAttributeDemo&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/cad&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;HitCountDemo&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.HitCountDemo&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;HitCountDemo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hcd&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;SessionCount&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.SessionCount&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;SessionCount&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/sc&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;UserCount&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.UserCount&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;UserCount&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/uc&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;IPAddress&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.IPAddress&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;IPAddress&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ip&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;


&lt;servlet&gt;
  &lt;servlet-name&gt;ContextScopeThreadSafe&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ContextScopeThreadSafe&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt; 
    &lt;servlet-name&gt;ContextScopeThreadSafe&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/csts&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;ContextSyncronize&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ContextSyncronize&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ContextSyncronize&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/cs&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ForwardServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ForwardServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/forward&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
 

&lt;servlet&gt;
  &lt;servlet-name&gt;ForwardTwo&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ForwardTwo&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ForwardTwo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/forward2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;ValidateServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ValidateServlet&lt;/servlet-class&gt;
&lt;/servlet&gt; 
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ValidateServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/vs&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;IncludeServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.IncludeServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;IncludeServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/include&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;IncludeTwo&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.IncludeTwo&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
   &lt;servlet-name&gt;IncludeTwo&lt;/servlet-name&gt;
   &lt;url-pattern&gt;/include2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;TargetServletFilter&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetServletFilter&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetServletFilter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/tsfilter&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;FirstDispatcherServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.FirstDispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;FirstDispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/dispatcher&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;TargetDispatcherServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetDispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetDispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/dispatcher1&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;TargetDispatcherServletTwo&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetDispatcherServletTwo&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetDispatcherServletTwo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/dispatcher2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;TargetWrapperServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetWrapperServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetWrapperServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/wrapper&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;ResponseWrapperFilter&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.ResponseWrapperFilter&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ResponseWrapperFilter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/responsefilter&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;TargetResponseWrapperServlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;jobs.TargetResponseWrapperServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;TargetResponseWrapperServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/responsewrapper&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;






&lt;filter&gt;
  &lt;filter-name&gt;firstfilter&lt;/filter-name&gt;
  &lt;filter-class&gt;jobs.FirstFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;firstfilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/tsfilter&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;



&lt;filter&gt;
  &lt;filter-name&gt;dispatcherfilter&lt;/filter-name&gt;
  &lt;filter-class&gt;jobs.DispatcherFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;dispatcherfilter&lt;/filter-name&gt;
    &lt;servlet-name&gt;FirstDispatcherServlet&lt;/servlet-name&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
    &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;

&lt;filter&gt;
  &lt;filter-name&gt;BadWordWrapperFilter&lt;/filter-name&gt;
  &lt;filter-class&gt;jobs.BadWordWrapperFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
 &lt;filter-name&gt;BadWordWrapperFilter&lt;/filter-name&gt;
 &lt;url-pattern&gt;/wrapper&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
  
&lt;filter&gt;
  	&lt;filter-name&gt;ResponseWrapperFilter&lt;/filter-name&gt;
  	&lt;filter-class&gt;jobs.ResponseWrapperFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;ResponseWrapperFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/responsewrapper&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

 
 &lt;error-page&gt;
  &lt;exception-type&gt;java.lang.ArithmeticException&lt;/exception-type&gt;
  &lt;location&gt;/dispatcher1&lt;/location&gt;
 &lt;/error-page&gt;
 
 
 &lt;/web-app&gt;
</pre>










<br>

</td></tr></table><a href="index-2.html"><font color="#000000">BACK</font></a></div>

  </body>

<!-- Mirrored from java.scwcd.jobs4times.com/Web-Container-Model.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:25:18 GMT -->
</html>