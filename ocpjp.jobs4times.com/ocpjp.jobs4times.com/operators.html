<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<!-- Mirrored from ocpjp.jobs4times.com/operators.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
<head>
<meta name="content-type" content="text/html; charset=ISO-8859-1">

<title>Operators OCJP Exam Objectives  </title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<div align="center">   
<table border="1"> <tr><td width="900px">

<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500" height="200">   </a> </td> 
<td  align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 	  	
</tr>
</table>		
    
    
	
<h1 align="center"  style="background-color: rgb(64, 0, 64);"> <font color="#ffff00">Operators  </font>  </h1>


<h3>Question : 1</h3>
Given :
<pre>
public class Test{
public static void main(String[] args){
 int x=5;
 boolean b1=true;
 boolean b2=false;
 
if((x==4) &amp;&amp; !b2)
System.out.println("1");
System.out.println("2");
if((b2=true) &amp;&amp; b1)
System.out.println("3");
}
}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>2 </li>
<li>3 </li>
<li>1 2 </li>
<li>2 3 </li>
<li>1 2 3 </li>
<li>Compilation fails</li>
<li>An exception is thrown at runtime</li> 
</ol>
<p> Answer : D </p>



<h3>Question : 2</h3>
Given the command line java Pass2 and :
<pre>
public class Pass2{
public void main(String[] args){
 int x=6;
Pass2 p=new Pass2();
p.doStuff(x);
System.out.println("main x="+x);
}

void doStuff(int x) {
System.out.println("doStuff x="+ x++);
}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Compilation fails </li>
<li>An exception is thrown at runtime </li>
<li>doStuff x=6 main x=6 </li>
<li>doStuff x=6 main x=7 </li>
<li>doStuff x=7 main x=6 </li>
<li>doStuff x=7 main x=7 </li>
</ol>
<p> Answer : B </p>




<h3>Question : 3</h3>
Given :
<pre>
public class Pass{
public static void main(String[] args){
 int x=5;
Pass p=new Pass();
p.doStuff(x);
System.out.println("main x="+x);
}

void doStuff(int x) {
System.out.println("doStuff x="+ x++);
}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Compilation fails </li>
<li>An exception is thrown at runtime </li>
<li>doStuff x=6 main x=6 </li>
<li>doStuff x=5 main x=5 </li>
<li>doStuff x=5 main x=6 </li>
<li>doStuff x=6 main x=5 </li>
</ol>
<p> Answer : D </p>



<h3>Question : 4</h3>
Given :
<pre>
public class ClassA{
public int getValue(){
 int value=0;
 boolean setting=true;
 String title="Hello";
 if(value||(setting &amp;&amp; title=="Hello")){return 1;}
 if(value==1 &amp; title.equals("Hello")){return 2;} 
}

public static void main(String[] args){
 ClassA a=new ClassA();
 a.getValue(); 
}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>1 </li>
<li>2 </li>
<li>Compilation fails </li>
<li>The code runs with no output </li>
<li>An exception is thrown at runtime</li>
</ol>
<p> Answer : C </p>


<h3>Question : 5</h3>
Given :
<pre>
public class Batman{
int squares=81;
public static void main(String[] args){
new Batman().go();
}

void go(){
 incr(++squares);
 System.out.println(squares);
}
void incr(int squares){ squares+=10;} 
}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li> 81</li>
<li>82 </li>
<li>91 </li>
<li>92 </li>
<li>Compilation fails</li>
<li>An exception is thrown at runtime</li> 
</ol>
<p> Answer : B </p>





<h3>Question : 6</h3>
Given :
<pre>
class ClassA{
public int numberOfInstances;
protected ClassA(int numberOfInstances){
 this.numberOfInstances=numberOfInstances;
}
}
public class ExtendedA extends ClassA{	
protected ExtendedA(int numberOfInstances) {
 super(numberOfInstances);
}
public static void main(String[] args){
 ExtendedA ext=new ExtendedA(420);
 System.out.println(ext.numberOfInstances);
} 
}
</pre>

<strong>Which statement is true ?</strong>
<ol type="A">
<li>420 is the output </li>
<li>An exception is thrown at runtime. </li>
<li>All constructors must be declared public. </li>
<li>Constructors CANNOT use the private modifier </li>
<li>Constructors CANNOT use the protected modifier </li>
</ol>
<p> Answer :  A</p>


<h3>Question : 7</h3>
Given :
<pre>
public class Spock{
public static void main(String[] args){
 Long tail=2000L;
 Long distance=1999L;
 Long story=1000L;
if((tail&gt;distance)^((story*2)==tail))
 System.out.println("1");
if(((distance+1!=tail)^((story*2)==distance)))
System.out.println("2");
}
}
</pre>

<strong>What is result  ?</strong>
<ol type="A">
<li>1 </li>
<li>2 </li>
<li>12 </li>
<li>Compilation fails </li>
<li>No output is produced</li>
<li>An exception is thrown at runtime</li>
</ol>
<p> Answer :  E</p>




<h3>Question : 8</h3>
Given :
<pre>
class Hexy{
public static void main(String[] args){
 Integer i=42;
 String s=(i&lt;42)?"life":(i&gt;50)?"universe":"everything";
 System.out.println(s);
}
}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>null </li>
<li>universe </li>
<li>everything </li>
<li>Compilation fails</li>
<li>An exception is thrown at runtime.</li>
</ol>
<p> Answer : D </p>

<ul>
<li><strong>D</strong> is correct, this is a ternary nested in a ternary with a little unboxing thrown in. Both of the ternary expressions are false.</li>
<li><strong>A, B, C, E, F</strong> are incorrect based on the above.</li>
</ul>



<h3>Question : 9</h3>
Given :
<pre>
class Example{
public static void main(String[] args){
 Short s=15;
 Boolean b;
 // insert code here
}
}
</pre>

<strong>  ?</strong>
<ol type="A">
<li>b=(Number instanceof s); </li>
<li> b=(s instanceof Short); </li>
<li> b=s.instanceof(Short); </li>
<li> b=(s instanceof Number); </li>
<li> b=s.instanceof(Object);</li>
<li> b=(s instanceof String);</li>
</ol>
<p> Answer : B, D </p>

<ul>
<li><strong>B, D</strong>  correctly use boxing and instanceof together.</li>
<li><strong>A</strong> is incorrect because the operands are reversed.</li>
<li><strong>C, E</strong> use incorrect instanceof syntax.</li>
<li><strong>F</strong> is wrong because Short isn't in the same inheritance tree as String.</li> 
</ul>

<h3>Question : 10</h3>
Given :
<pre>
class Comp{
public static void main(String[] args){
 float f1=2.3f;
 float[][] f2={{42.0f},{1.7f,2.3f},{2.6f,2.7f}};
 float[] f3={2.7f};
 Long x=42L;
 //insert code here
 System.out.println("true");
}
}

And the following five code fragments :
F1. if(f1==f2)
F2. if(f1==f2[2][1])
F3. if(x==f2[0][0])
F4. if(f1==f2[1,1])
F5. if(f3==f2[2])
</pre>

<strong>What is true  ?</strong>
<ol type="A">
<li>One of them will compile, only one will be true. </li>
<li>Two of them will compile, only one will be true. </li>
<li>Two of them will compile, Two will be true. </li>
<li>Three of them will compile, only one will be true. </li>
<li>Three of them will compile, exactly two will be true.</li> 
<li>Three of them will compile, exactly three will be true.
</ol>
<p> Answer :  D</p>

<ul>
<li><strong>D</strong> is correct. Fragments F2, F3, and F5 will compile, and only F3 is true.</li>
<li><strong>A, B, C, E, F</strong> are incorrect. F1 is incorrect because you can't compare a primitive to an array. F4 is incorrect syntax to access an element of a two-dimensional array.</li>
</ul>




<h3>Question : 11</h3>
Given :
<pre>
class Fork{
public static void main(String[] args){
 if(args.length==1|args[1].equals("test")){
  System.out.println("test case");
 }
 else{
  System.out.println("production :"+args[0]);
 }
}
}

And the command-line invocation :
<strong>java Fork live2</strong>
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>test case </li>
<li>production</li>
<li>test case live2 </li>
<li>Compilation fails </li>
<li>An exception is thrown at runtime </li>
</ol>
<p> Answer : E </p>

<ul>
<li>E is correct. Because the short circuit(||) is not used, both operands are evaluated. Since args[1] is past the args array bounds, an java.lang.ArrayIndexOutOfBoundsException is thrown.</li>
<li><strong>A, B, C, D</strong> are incorrect based on the above.</li> 
</ul>

<h3>Question : 12</h3>
Given :
<pre>
class Foozit{
public static void main(String[] args){
 Integer x=0;
 Integer y=0;
 for(Short z=0;z&lt;5;z++)
 if((++x&gt;2)||(++y&gt;2))
 x++;
 System.out.println(x+" "+y);
}
}
</pre>

<strong> What is result ?</strong>
<ol type="A">
<li>5 1 </li>
<li>5 1 </li>
<li>5 3 </li>
<li>8 1 </li>
<li>8 2 </li>
<li>8 3 </li>
<li>10 2 </li>
<li>10 3 </li>
</ol>
<p> Answer : E </p>

<ul>
<li><b>E</b> is correct. The first two times the if test runs, both x and y are incremented once (the x++ is not reached untill the third iteration). Starting with the third iteration of the loop, y is never touched again, because of the short -circuit operator.</li>
<li><b>A, B, C, D, F, G, H</b> are incorrect based on the above.</li>
</ul>

<h3>Question : 13</h3>
Given :
<pre>
class Titanic{
public static void main(String[] args){
 Boolean b1=true;
 boolean b2=false;
 boolean b3=true;
if((b1&amp;b2)|(b2&amp;b3)&amp;b3)
System.out.println("alpha");
if((b1=false)|(b1&amp;b3)|(b1|b2))
System.out.println("beta"); 
}
}
</pre>

<strong> What is the result ?</strong>
<ol type="A">
<li>beta </li>
<li>alpha </li>
<li>alpha beta</li>
<li>Compilation fails </li>
<li>No output is produced </li>
<li>An exception is thrown at runtime.</li>
</ol>
<p> Answer : E </p>

<ul>
<li><b>E</b> is correct. In the second if test, the leftmost expression  is an assignment, not a comparison. Once b1 has been set to false, the remaining tests are all false.</li>
<li><b>A, B, C, D, F</b> are incorrect based on the above.</li>  
</ul>



<h3>Question : 14</h3>
Given :
<pre>
public class Feline {
public static void main(String[] args) {
Long x=42L;
Long y=44L;
System.out.print(" "+7+2+" ");
System.out.print(foo()+x+5+" ");
System.out.println(x+y+foo());
}
static String foo(){ return "foo";}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li> 9 foo47 86foo  </li>
<li> 9 foo47 4244foo  </li>
<li> 9 foo425 86foo  </li>
<li> 9 foo425 4244foo </li>
<li> 72 foo47 86foo  </li>
<li> 72 foo47 4244foo  </li>
<li> 72 foo425 86foo </li>
<li> 72 foo425 4244foo </li>
<li> Compilation fails  </li>
</ol>
<p> Answer :G  </p>
<ul>
<li><b>G</b> is correct. Concatenation runs from left to right, and if either operand is a String, the operands are concatenated. If both operands are numbers they are added together. Unboxing works in conjunction with concatenation. </li>
<li><b>A, B, C, D, F</b> are incorrect based on the above.</li>  
</ul>


<h3>Question : 15</h3>
Place the fragments into the code to produce the output 33. Note, you must use each fragment exactly once.

<pre>
class Incr {
public static void main(String[] args) {
Integer x=7;
int y=2;
x - -;
- - -;
- - -;
- - -;	
System.out.println(x);
}
}
</pre>
Fragments :
<table border="1">
<tr><td>y</td><td>y</td><td>y</td><td>y</td></tr>
<tr><td>y</td><td>x</td><td>x</td><td></td></tr>
<tr><td>-=</td><td>*=</td><td>*=</td><td>*=</td></tr>
</table>
<strong> Answer :  </strong>
<pre>
class Incr {
public static void main(String[] args) {
Integer x=7;
int y=2;
x*=x;
y*=y;
y*=y;
x-=y;	
System.out.println(x);
}
}
</pre>
Yeah, we know it's kind of puzzle-y, but you might encounter something like it on the real exam.


<h3>Question : 16</h3>
<pre>
1 class Maybe {
2 public static void main(String[] args) {
3 boolean b1=true;
4 boolean b2=false;
5 System.out.print(!false^false);
6 System.out.print(" "+(!b1&amp;(b2=true)));
7 System.out.println(" "+(b2^b1));
8 }
9 }
</pre>

<strong> Which is true ?</strong>
<ol type="A">
<li>Line 5 produces true. </li>
<li>Line 5 produces false. </li>
<li>Line 6 produces true. </li>
<li>Line 6 produces false. </li>
<li>Line 7 produces true. </li>
<li>Line 7 produces false. </li>
</ol>
<p> Answer :  A, D, F</p>

<ul>
<li><b>A, D, F</b> is correct. The <b>^</b>(xor) returns true if exactly one operand is true. The <b>!</b> inverts the operand's boolean value. On line 6, b2=true is an assignment not a comparison, and it's evaluated because &amp; does not short-circuit it.</li>
<li><b>B, C, E</b> are incorrect based on the above.</li>  
</ul>





<h3>Question : 17</h3>
<pre>
class Sixties {
public static void main(String[] args) {
int x=5;
int y=7;
System.out.print((y*2)%x);
System.out.print(" "+(y%x));
}
}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>1 1 </li>
<li>1 2 </li>
<li>2 1 </li>
<li>2 2 </li>
<li>4 1 </li>
<li>4 2 </li>
<li>Compilation fails </li>
<li>An exception is thrown at runtime </li>
</ol>
<p> Answer : F </p>
<ul>
<li><b>F</b> is correct. The <b>%</b> operator returns the remainder of a division operation.</li>
<li><b>A, B, C, D, E, G, H</b> are incorrect based on the above.</li>  
</ul>

<h3>Question : 18</h3>
<pre>
class Scoop{
static int thrower()throws Exception{ return 42;}
public static void main(String[] args){
try{
int x=thrower();	
}catch(Exception e){
x++;
}finally{
	System.out.println("x="+ ++x);
}
}//main
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>x=42 </li>
<li>x=43 </li>
<li>x=44 </li>
<li>Compilation fails </li>
<li>The code runs with no output</li>
</ol>
<p> Answer :  D</p>
<ul>
<li><b>D</b> is correct. The variable x is only in scope with in the try code block, it's not in scope in the catch or finally blocks.</li>
<li><b>A, B, C, E</b> are incorrect based on the above.</li>  
</ul>


<h3>Question : 19</h3>
<pre>
class Alien{
String invade(short ships){ return "a few"; }
String invade(short... ships){ return "many"; }
}
class Defender{
public static void main(String[] args){
System.out.println(new Alien().invade(7));
}//main
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>many </li>
<li>a few </li>
<li>Compilation fails </li>
<li>The output is not predictable </li>
</ol>
<p> Answer : C </p>
<ul>
<li><b>C </b> is correct, compilation fails. The var-args declaration is fine, but invade takes a short, so the argument 7 needs to be cast to a short. With in the cast, the answer is <b>B, 'a few'</b></li>
</ul>



<h3>Question : 20</h3>
<pre>
1 class Dims{
2 public static void main(String[] args){
3 int[][] a={{1,2},{3,4}};
4 int[] b=(int[])a[1];
5 Object o1=a;
6 int[][] a2=(int[][])o1;
7 int[] b2=(int[])o1;
8 System.out.println(b[1]);
9 }}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>2 </li>
<li>4 </li>
<li>An exception is thrown at runtime </li>
<li>Compilation fails due to an error on line 4 </li>
<li>Compilation fails due to an error on line 5 </li>
<li>Compilation fails due to an error on line 6 </li>
<li>Compilation fails due to an error on line 7 </li>
</ol>
<p> Answer :  C</p>

<ul>
<li><b>C</b> is correct. A ClassCastException is thrown at line 7 because <i>o1</i> refers to an int[][] not an int[]. If line 7 was removed, the output would be 4.</li>
</ul>

<h3>Question : 21</h3>
<pre>
class Eggs{
int doX(Long x,Long y){return 1;}
int doX(long... x){return 2;}
int doX(Integer x,Integer y){return 3;}
int doX(Number n,Number m){return 4;}
public static void main(String[] args){
new Eggs().go();
}//main
void go(){
short s=7;
System.out.print(doX(s,s)+" ");
System.out.println(doX(7,7));
}}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>1 1 </li>
<li>2 1 </li>
<li>3 1 </li>
<li>4 1 </li>
<li>2 3</li>
<li>3 3</li>
<li>4 3</li>
</ol>
<p> Answer : G </p>
<ul>
<li>G is correct. Two rules apply to the first invocation of doX(). You can't widen and then box in one step, and var-args are always chosen last.  Therefore you can't widen shorts to either ints or longs, and then box  them to Integers and Longs. But you can box shorts to Shorts and then widen them to Numbers, and this takes priority over using a var-arg method. The second invocation uses a simple box from int to Integer.</li> 
</ul>


<h3>Question : 22</h3>
<pre>
class Mixer{
Mixer(){}
Mixer(Mixer m){m1=m;}
Mixer m1;
public static void main(String[] args){
Mixer m2=new Mixer();
Mixer m3=new Mixer(m2); m3.go();
Mixer m4=m3.m1; m4.go();
Mixer m5=m2.m1; m5.go();
}
void go(){System.out.print("hi ");}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>hi </li>
<li>hi  hi </li>
<li>hi  hi  hi </li>
<li>Compilation fails </li>
<li>hi, followed by an exception</li>
<li>hi hi, followed by an exception.</li>
</ol>
<p> Answer : F </p>

<ul>
<li>F is correct. The m2 object's m1 instance variable is never initialized, so when m5 tries to use it a NullPointerException is thrown.</li>
</ul>



<h3>Question : 23</h3>
<pre>
1 class Zippy{
2 String[] x;
3 int[] a[]={{1,2},{1}};
4 Object c=new long[4];
5 Object[] d=x;
6 }
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Compilation succeeds. </li>
<li>Compilation fails due only to an error on line 3.</li>
<li>Compilation fails due only to an error on line 4.</li>
<li>Compilation fails due only to an error on line 5.</li>
<li>Compilation fails due to an error on lines 3 and 5.</li>
<li>Compilation fails due to an error on lines 3, 4, and 5.</li>
</ol>
<p> Answer : A </p>

<ul>
<li>A is correct, all of these array declarations are legal. Lines 4 and 5 demonstrate that arrays.</li> 
</ul>


<h3>Question : 24</h3>
<pre>
class Fizz{
int x=5;
public static void main(String[] args){
final Fizz f1=new Fizz();
Fizz f2=new Fizz();
Fizz f3=FizzSwitch(f1,f2);
System.out.println((f1==f3)+" "+(f1.x==f3.x));
}
static Fizz FizzSwitch(Fizz x, Fizz y) {
final Fizz z=x;
z.x=6;
return z;
}}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>true true </li>
<li>false true </li>
<li>true false </li>
<li>false false </li>
<li>Compilation fails.</li>
<li>An exception is thrown at runtime.</li>
</ol>
<p> Answer : A </p>

<ul>
<li>A is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final modifier assures that a reference variable cannot be reffered to a different object, but final doesn't keep the object's state from changing.</li>
</ul>


<h3>Question : 25</h3>
<pre>
class Knowing{
static final long tooth=343L;
static long doIt(long tooth){
System.out.print(++tooth+" ");
return ++tooth;
}
public static void main(String[] args){
System.out.print(tooth+" ");
final long tooth=340L;
new Knowing().doIt(tooth);
System.out.println(tooth);
}}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>343 340 340 </li>
<li>343 340 342 </li>
<li>343 341 342 </li>
<li>343 341 340 </li>
<li>343 341 343 </li>
<li>Compilation fails</li>
<li>An exception is thrown at runtime</li>
</ol>
<p> Answer : D </p>

<ul>
<li>D is correct. There are three different long variables named tooth. Remember that you can apply the final modifier to local variables, but in this case the 2 versions of tooth marked  final are not changed. The only tooth whose value changes is the one not marked final. This problem demonstrates a bad practice known as  shadowing.</li> 
</ul>


<h3>Question : 26</h3>
<pre>
class Bigger{
public static void main(String[] args){
// insert code here
}
}
class Better{
enum Faster{ Higher, Longer };
}
</pre>

<strong>Which, inserted independently at line 3, will compile ?</strong>
<ol type="A">
<li>Faster f=Faster.Higher; </li>
<li>Faster f=Better.Faster.Higher; </li>
<li>Better.Faster f=Better.Faster.Higher; </li>
<li>Bigger.Faster f=Bigger.Faster.Higher; </li>
<li>Better.Faster f2; f2=Better.Faster.Longer;</li>
<li>Better b; b.Faster=f3; f3=Better.Faster.Longer;</li>
</ol>
<p> Answer : C, E </p>

<ul>
<li>C and E are correct syntax for accessing an enum from another class.</li>
</ul>



</td></tr></table>
<a href="index-2.html">BACK</a>

</div>

</body>

<!-- Mirrored from ocpjp.jobs4times.com/operators.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
</html>