<!DOCTYPE html>
<html>

<!-- Mirrored from ocpjp.jobs4times.com/multiThread.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
<head>
<meta charset="ISO-8859-1">

<title>Multi-Threading Java Certification Programs</title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<div align="center">   
<table border="1"> <tr><td width="700px">
    
    
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500" height="200">   </a> </td> 
<td  align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 	  	
</tr>
</table>  			
    
    
	
<h1 align="center"  style="background-color: rgb(64, 0, 64);"> <font color="#ffff00">Multi-Threading Java Certification Programs </font>  </h1>

	
<h3>Q: 01 Click the Exhibit button.</h3>
What is the result ?
<ol style="A">
<li> The code will deadlock.</li>
<li> The code may run with no output.</li>
<li> An exception is thrown at runtime.</li>
<li> The code may run with output "0 6".</li>
<li> The code may run with output "2 0 6 4".</li>
<li> The code may run with output "0 2 4 6".</li>
</ol>
Answer: F

<h3>Q: 02 Given:</h3>
<pre>
1. public class Threads2 implements Runnable { 
2. 
3. public void run() { 
4. System.out.println("run."); 
5. throw new RuntimeException("Problem"); 
6. } 
7. public static void main(String[] args) {
8. Thread t = new Thread(new Threads2()); 
9. t.start(); 
10. System.out.println("End of method."); 
11. } 
12. } 
</pre>
Which two can be results ? (Choose two.)
<ol>
<li>java.lang.RuntimeException: Problem</li>
<li> run. java.lang.RuntimeException: Problem</li>
<li> End of method. java.lang.RuntimeException: Problem</li>
<li> End of method. run. java.lang.RuntimeException: Problem</li>
<li> run. java.lang.RuntimeException: Problem End of method.</li>
</ol>
 Answer: D, E 
 
 <h3> Q: 03 Given:</h3>
 <pre>
 1. public class TestSeven extends Thread { 
 2. private static int x; 
 3. public synchronized void doThings() { 
 4. int current = x; 
 5. current++; 
 6. x = current; 
 7. } 
 8. public void run() { 
 9. doThings(); 
 10. } 
 11.}
 </pre>
  Which statement is true ?
  
<ol style="A">
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li><li> Synchronizing the run() method would make the class thread-safe.</li><li> The data in variable "x" are protected from concurrent access problems.</li><li> Declaring the doThings() method as static would make the class thread-safe.</li><li> Wrapping the statements within doThings() in a synchronized(new Object()) { } block would make the class thread-safe.</li></ol>
 Answer: E

<h3>Q: 04 Given:</h3>
<pre>
1. public class Threads3 implements Runnable { 
2. public void run() { 
3. System.out.print("running"); 
4. } 
5. public static void main(String[] args) { 
6. Thread t = new Thread(new Threads3()); 
7. t.run(); 
8. t.run(); 
9. t.start(); 
10. } 
11. } 
</pre>

What is the result ?
<ol>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li>
<li> The code executes and prints "running".</li>
<li> The code executes and prints "runningrunning".</li>
<li> The code executes and prints "runningrunningrunning".</li></ol>
 Answer: E
 
<h3>  Q: 05 Given:</h3>

<pre>
public class NamedCounter { 
 private final String name; 
 private int count; 
 public NamedCounter(String name) { this.name = name; } 
 public String getName() { return name; } 
 public void increment() { count++; } 
 public int getCount() { return count; } 
 public void reset() { count = 0; } 
}
</pre>
 Which three changes should be made to adapt this class to be used safely by multiple threads? (Choose three.)
 <ol>
 <li> declare reset() using the synchronized keyword</li>
 <li> declare getName() using the synchronized keyword</li>
 <li> declare getCount() using the synchronized keyword</li>
 <li> declare the constructor using the synchronized keyword</li>
 <li> declare increment() using the synchronized keyword</li></ol>
 
  Answer: A, C, E 
 
<h3>  Q: 06 Given:</h3>
<pre>
7. void waitForSignal() { 
8. Object obj = new Object(); 
9. synchronized (Thread.currentThread()) { 
10. obj.wait(); 
11. obj.notify(); 
12. } 
13. } 
</pre>
Which statement is true? 
<ol><li> This code may throw an InterruptedException.</li><li> This code may throw an IllegalStateException.</li>
<li> This code may throw a TimeoutException after ten minutes.</li>
<li> This code will not compile unless "obj.wait()" is replaced with "((Thread) obj).wait()".</li> 
<li> Reversing the order of obj.wait() and obj.notify() may cause this method to complete normally.</li>
<li> A call to notify()or notifyAll() from another thread may cause this method to complete normally.</li>
</ol> 
Answer: B 

<h3>Q: 07</h3>

 Which two code fragments will execute the method doStuff() in a separate thread? (Choose two.)
 <ol>
 <li> new Thread() { public void run() { doStuff(); } };</li>
 <li> new Thread() { public void start() { doStuff(); } };</li>
 <li> new Thread() { public void start() { doStuff(); } }.run();</li>
 <li> new Thread() { public void run() { doStuff(); } }.start();</li>
 <li> new Thread(new Runnable() { public void run() { doStuff(); } }).run();</li>
 <li> new Thread(new Runnable() { public void run() { doStuff(); } }).start();</li>
 </ol>
 
  Answer: D, F 
  
<h3>  Q: 08 Given:</h3>
<pre>
1. public class TestOne implements Runnable { 
2. public static void main (String[] args) throws Exception { 
3. Thread t = new Thread(new TestOne()); 
4. t.start(); 
5. System.out.print("Started"); 
6. t.join(); 
7. System.out.print("Complete"); 
8. } 
9. public void run() { 
10. for (int i = 0; i &lt; 4; i++) { 
11. System.out.print(i); 
12. } 
13. } 
14. } 
</pre>
What can be a result ?

<ol>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li>
<li> The code executes and prints "StartedComplete".</li>
<li> The code executes and prints "StartedComplete0123".</li>
<li> The code executes and prints "Started0123Complete".</li>
</ol>
 Answer: E

<h3>Q: 09Given:</h3>
<pre>
1. public class TestOne { 
2. public static void main (String[] args) throws Exception { 
3. Thread.sleep(3000); 
4. System.out.println("sleep"); 
5. } 
6. }
</pre>
 What is the result ?

<ol>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li>
<li> The code executes normally and prints "sleep".</li>
<li> The code executes normally, but nothing is printed.</li>
</ol>
 Answer: C 
 
<h3> Q: 10 Given:</h3>
<pre>
11. public class Test { 
12. public enum Dogs {collie, harrier, shepherd}; 
13. public static void main(String [] args) { 
14. Dogs myDog = Dogs.shepherd; 
15. switch (myDog) { 
16. case collie: 
17. System.out.print("collie "); 
18. case default: 
19. System.out.print("retriever "); 
20. case harrier: 
21. System.out.print("harrier "); 
22. } 
23. } 
24. }
</pre>

What is the result ?
<ol>
<li> harrier</li><li>shepherd</li><li> retriever</li><li> Compilation fails.</li><li> retriever harrier</li>
<li> An exception is thrown at runtime.</li></ol>

 Answer: D 

<h3>Q: 11 Given:</h3>

<pre>
11. Runnable r = new Runnable() { 
12. public void run() { 
13. System.out.print("Cat"); 
14. } 
15. }; 
16. Thread t = new Thread(r) { 
17. public void run() { 
18. System.out.print("Dog"); 
19. } 
20. }; 
21. t.start();
</pre>

What is the result ?
<ol>
<li> Cat</li><li> Dog </li><li> Compilation fails.</li><li> The code runs with no output.</li><li> An exception is thrown at runtime.</li></ol>
 Answer: B 

<h3>Q: 12 Given:</h3>

<pre>
1. public class Threads4 { 
2. public static void main (String[] args) { 
3. new Threads4().go(); 
4. } 
5. public void go() { 
6. Runnable r = new Runnable() { 
7. public void run() { 
8. System.out.print("foo"); 
9. } 
10. }; 
11. Thread t = new Thread(r); 
12. t.start(); 
13. t.start(); 
14. } 
15. } 
</pre>

What is the result ?
<ol><li> Compilation fails.</li><li> An exception is thrown at runtime.</li><li> The code executes normally and prints "foo".</li>
<li> The code executes normally, but nothing is printed.</li></ol>
 Answer: B
 
 <h3> Q: 13 Given:</h3>
 <pre>
1. public class TestFive { 
2. private int x; 
3. public void foo() { 
4. int current = x; 
5. x = current + 1; 
6. } 
7. public void go() { 
8. for(int i = 0; i &lt; 5; i++) { 
9. new Thread() { 
10. public void run() { 
11. foo(); 
12. System.out.print(x + ", "); 
13. } }.start(); 
14. } }
</pre>

 Which two changes, taken together, would guarantee the output: 1, 2, 3, 4, 5, ? (Choose two.) 
 <ol>
 <li> move the line 12 print statement into the foo() method</li>
 <li> change line 7 to public synchronized void go() {</li>
<li> change the variable declaration on line 2 to private volatile int x;</li>
<li> wrap the code inside the foo() method with a synchronized( this ) block</li>
<li> wrap the for loop code inside the go() method with a synchronized block synchronized(this){ // for loop code here }</li></ol>
Answer: A, D

<h3>Q: 14 Click the Task button.</h3>
Solution:
<pre>
1.started
2.ran
3.interrupting
4.ended
5.(no more out put)
</pre>

<h3>15 Click the Exhibit button.</h3>
What is the output if the main() method is run ?
<ol><li> 4 </li><li> 5</li><li> 8</li><li> 9</li><li> Compilation fails.</li>
<li> An exception is thrown at runtime.</li><li> It is impossible to determine for certain.</li></ol>
Answer: D

<h3>Q: 16 Click the Task button.</h3>

Solution:
java.lang.object ------------------------------- wait( ); notify( ); 
java.lang.Thread--------------------------------run(), sleep( ); start( ); join ( ) 

<h3>Q: 17 Given:</h3> 
<p>
foo and bar are public references available to many other threads. foo refers to a Thread and bar is an Object. The thread foo is currently executing bar.wait(). From another thread, what provides the most reliable way to ensure that foo will stop executing wait()?
</p>

<ol><li> foo.notify();</li><li> bar.notify();</li><li> foo.notifyAll();</li><li> Thread.notify();</li><li> bar.notifyAll();</li>
<li> Object.notify();</li></ol>
 Answer: E
 
 <h3>  Q: 18 Given:</h3>
<pre>
1. public class MyLogger { 
2. private StringBuilder logger = new StringBuuilder(); 
3. public void log(String message, String user) { 
4. logger.append(message); 
5. logger.append(user); 
6. } 
7. } 
</pre>
The programmer must guarantee that a single MyLogger object works properly for a multi-threaded system. How must this code be changed to be thread-safe ?
<ol>
<li> synchronize the log method</li><li> replace StringBuilder with StringBuffer</li>
<li> replace StringBuilder with just a String object and use the string concatenation (+=) within the log method</li>
<li> No change is necessary, the current MyLogger code is already thread-safe.</li></ol>
 Answer: A
 
<h3> Q: 19 Given:</h3>
<pre>
1. public class TestSeven extends Thread { 
2. private static int x; 
3. public synchronized void doThings() { 
4. int current = x; 
5. current++; 
6. x = current; 
7. } 
8. public void run() { 
9. doThings(); 
10. } 
11.}
</pre>
 Which statement is true ? 
<ol><li> Compilation fails.</li><li> An exception is thrown at runtime.</li>
<li> Synchronizing the run() method would make the class thread-safe.</li>
<li>The data in variable "x" are protected from concurrent access problems.</li>
<li> Declaring the doThings() method as static would make the class thread-safe.</li>
<li> Wrapping the statements within doThings() in a synchronized(new Object()) { } block would make the class thread-safe.</li></ol>
Answer: E

<h3>Q:20 Click the Exhibit button.</h3>
Which two statements are true if this class is compiled and run ? (Choose two.)
<ol>
<li> An exception may be thrown at runtime.</li>
<li> The code may run with no output, without exiting.</li>
<li> The code may run with no output, exiting normally.</li>
<li> The code may run with output "A B A B C C ", then exit.</li>
<li> The code may run with output "A B C A B C A B C ", then exit.</li>
<li> The code may run with output "A A A B C A B C C ", then exit.</li>
<li> The code may run with output "A B C A A B C A B C ", then exit.</li>
</ol>
Answer: E, G

<h3>Q: 21 Given:</h3>
<pre>
1. public class Threads5 {
2. public static void main (String[] args) {
3. new Thread(new Runnable() {
4. public void run() {
5. System.out.print("bar");
6. }}).start();
7. }
8. }
</pre>
What is the result ?
<ol>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li>
<li> The code executes normally and prints "bar".</li>
<li> The code executes normally, but nothing prints.</li>
</ol>
Answer: C

<h3>Q: 22 Which three will compile and run without exception ? (Choose three.)</h3>
<ol>
<li> private synchronized Object o;</li>
<li> void go() {
synchronized() { /* code here */ }</li>
<li> public synchronized void go() { /* code here */ }</li>
<li> private synchronized(this) void go() { /* code here */ }</li>
<li> void go() {
synchronized(Object.class) { /* code here */ } </li>
<li> void go() {
Object o = new Object();
synchronized(o) { /* code here */ }</li>
</ol>

Answer: C, E, F

<h3>Q: 23 Click the Task button.</h3>
Solution:
<pre>
1.synchronized
2.notifyAll( )
3.synchronized
4.wait( )
5.false
</pre>

<h3>Q: 24 Click the Task button.</h3>
Solution:
<pre>
t.join( );
t.run( );
t.doIt( );
</pre>

<h3>Q: 25 Click the Exhibit button.</h3>
Which two are possible results ? (Choose two.)
<ol>
<li> 0, 2, 4, 4, 6, 8, 10, 6,</li>
<li> 0, 2, 4, 6, 8, 10, 2, 4,</li>
<li> 0, 2, 4, 6, 8, 10, 12, 14,</li>
<li> 0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 14, 14,</li>
<li> 0, 2, 4, 6, 8, 10, 12, 14, 0, 2, 4, 6, 8, 10, 12, 14,</li></ol>

Answer: A, C


<h3>Q: 26 Click the Exhibit button.</h3>
Given:
<pre>
1. public class TwoThreads {
2
3. private static Object resource = new Object();
4.
5. private static void delay(long n) {
6. try { Thread.sleep(n); }
7. catch (Exception e) { System.out.print("Error "); }
8. }
9
10. public static void main(String[] args) {
11. System.out.print("StartMain ");
12. new Thread1().start();
13. delay(1000); 
14. Thread t2 = new Thread2(); 
15. t2.start(); 
16. delay(1000); 
17. t2.interrupt 
18. delay(1000); 
19. System.out.print("EndMain "); 
20. } 
21. 
22. static class Thread 1 extends Thread { 
23. public void run() { 
24. synchronized (resource) { 
25. System.out.print("Startl "); 
26. delay(6000); 
27. System.out.print("End1 "); 
28. } 
29. } 
30. } 
31. 
32. static class Thread2 extends Thread { 
33. public void run() { 
34. synchronized (resource) { 
35. System.out.print("Start2 "); 
36. delay(2000); 
37. System.out.print("End2 "); 
38. } 
39. } 
40. } 
41. } 
</pre>

Assume that sleep(n) executes in exactly m milliseconds, and all other code executes in an insignificant amount of time. What is the output if the main() method is run ?
<ol>
<li> Compilation fails.</li><li> Deadlock occurs.</li>
<li> StartMain Start1 Error EndMain End1</li>
<li> StartMain Start1 EndMain End1 Start2 End2</li>
<li> StartMain Start1 Error Start2 EndMain End2 End1</li>
<li> StartMain Start1 Start2 Error End2 EndMain End1</li>
<li> StartMain Start1 EndMain End1 Start2 Error End2</li>
</ol>
 Answer: G 

<h3> Q : 27 Click the Exhibit button.</h3> 
<pre>
10. public class Transfers { 
11. public static void main(String[] args) throws Exception { 
12. Record r1 = new Record(); 
13. Record r2 = new Record(); 
14. doTransfer(r1, r2, 5); 
15. doTransfer(r2, r1, 2);
16. doTransfer(r1, r2, 1); 
17. // print the result 
18. System.out.println("rl = " + r1.get() +", r2=" + r2.get()); 
19. } 
20. private static void doTransfer( 
21. final Record a, final Record b, final int amount) { 
22. Thread t = new Thread() { 
23. public void run() { 
24. new Clerk().transfer(a, b, amount); 
25. } 
26. }; 
27. t.start(); 
28. } 
29. } 
30. class Clerk { 
31. public synchronized void transfer(Record a, Record b, int amount){ 
32. synchronized (a) { 
33. synchronized (b) { 
34. a.add(-amount); 
35. b.add(amount); 
36. } 
37. } 
38. } 
39. } 
40. class Record { 
41.int num=10; 
42. public int get() { return num; } 
43. public void add(int n) { num = num + n; }
44. }
</pre>

 If Transfers.main() is run, which three are true ? (Choose three.)

<ol><li> The output may be "r1 = 6, r2 = 14".</li>
<li> The output may be "r1 = 5, r2 = 15". </li>
<li> The output may be "r1 = 8, r2 = 12".</li>
<li> The code may run (and complete) with no output.</li>
<li> The code may deadlock (without completing) with no output.</li>
<li> M IllegalStateException or InterruptedException may be thrown at runtime.</li>
</ol>
 Answer: A B E
 
<h3> Question: 28 Which two statements are true ? (Choose two.)</h3>
<ol>
<li> It is possible for more than two threads to deadlock at once.</li>
<li> The JVM implementation guarantees that multiple threads cannot enter into a deadlocked state.</li>
<li> Deadlocked threads release once their sleep() method's sleep duration has expired.</li>
<li> Deadlocking can occur only when the wait(), notify(), and notifyAll() methods are used incorrectly.</li>
<li> It is possible for a single-threaded application to deadlock if synchronized blocks are used incorrectly.</li>
<li> If a piece of code is capable of deadlocking, you cannot eliminate the possibility of deadlocking by inserting invocations of Thread.yield().</li></ol>
 Answer: A, F

<h3> Q : 29 Given:</h3>
<pre>
11. class PingPong2 { 
12. synchronized void hit(long n) { 
13. for(int i = 1; i &lt; 3; i++) 
14. System.out.print(n + "-" + i + " "); 
15. } 
16. } 
17. public class Tester implements Runnable { 
18. static PingPong2 pp2 = new PingPong2(); 
19. public static void main(String[] args) { 
20. new Thread(new Tester()).start(); 
21. new Thread(new Tester()).start(); 
22. } 
23. public void run() { pp2.hit(Thread.currentThread().getId()); } 
24. }
</pre>

 Which statement is true ?
<ol><li> The output could be 5-1 6-1 6-2 5-2</li><li> The output could be 6-1 6-2 5-1 5-2</li>
<li> The output could be 6-1 5-2 6-2 5-1</li><li> The output could be 6-1 6-2 5-1 7-1</li></ol>
 Answer: B

<h3> Q : 30 Given that t1 is a reference to a live thread, which is true ?</h3>
<ol>
<li> The Thread.sleep() method can take t1 as an argument.</li><li>The Object.notify() method can take t1 as an argument.</li>
<li> The Thread.yield() method can take t1 as an argument.</li><li> The Thread.setPriority() method can take t1 as an argument.</li>
<li> The Object.notify() method arbitrarily chooses which thread to notify.</li></ol>
 Answer: E
 
<h3>  Question: 31 Given that </h3>
<pre>
Triangle implements Runnable,
 and: 
31. void go() throws Exception { 
32. Thread t = new Thread(new Triangle());
33. t.start(); 
34. for(int x = 1; x &lt; 100000; x++) { 
35. //insert code here 
36. if(x%100 == 0) System.out.print("g"); 
37. } } 
38. public void run() { 
39. try { 
40. for(int x = 1; x &lt; 100000; x++) { 
41. // insert the same code here 
42. if(x%100 == 0) System.out.print("t"); 
43. }
44. } catch (Exception e) { } 
45. }
</pre>
 Which two statements, inserted independently at both lines 35 and 41, tend to allow both threads to temporarily pause and allow the other thread to execute ? (Choose two.)

<ol><li> Thread.wait();</li><li> Thread.join();</li><li> Thread.yield();</li><li> Thread.sleep(1);</li>
<li> Thread.notify();</li></ol>
 Answer: C, D 
 
<h3> 28. Given:</h3>

<pre>
public class Messager implements Runnable { 
 public static void main(String[] args) { 
  new Thread(new Messager("Wallace")).start(); 
  new Thread(new Messager("Gromit")).start(); 
 } 
 private String name; 
 public Messager(String name) { this.name = name; } 
 public void run() { message(1); message(2); } 
 private synchronized void message(int n) { System.out.print(name + "-" + n + " "); 
 } 
} 
</pre>
Which of the following is a possible result ? (Choose all that apply.) 
<ol>
<li> Wallace-1 Wallace-2 Gromit-1</li>
<li>  Wallace-1 Gromit-2 Wallace-2 Gromit-1</li>
<li> Wallace-1 Gromit-1 Gromit-2 Wallace-2</li>
<li> Gromit-1 Gromit-2 E. Gromit-2 Wallace-1 Gromit-1 Wallace-2</li>
<li> The code does not compile.</li>
<li> An error occurs at run time.</li></ol>

Answer:
<ol>
<li>C is correct. Both threads will print two messages each. Wallace-1 must be before Wallace-2, and Gromit-1 must be before Gromit-2. Other than that, the Wallace and Gromit messages can be intermingled in any order.</li>
<li>A, B, D, E, F, and G are incorrect based on the above.</li></ol>

<h3>29. Given:</h3> 
<pre>
public class Letters extends Thread {
 private String name; 
 public Letters(String name) { this.name = name; } 
 public void write() { 
 System.out.print(name); 
 System.out.print(name); 
 } 
 public static void main(String[] args) {
 new Letters("X").start();
 new Letters("Y").start(); 
 } 
}
</pre>
We want to guarantee that the output can be either XXYY or YYXX, but never XYXY or any other combination. Which of the following method definitions could be added to the Letters class to make this guarantee ? (Choose all that apply.) 
<ol>
<li> public void run() { write(); }</li>
<li> public synchronized void run() { write(); }</li>
<li> public static synchronized void run() { write(); }</li>
<li> public void run() { synchronized(this) { write(); } }</li>
<li>public void run() { synchronized(Letters.class) { write(); } }</li>
<li> public void run() { synchronized(System.out) { write(); } }</li>
<li> public void run() { synchronized(System.out.class) { write(); } }</li>
</ol>
 Answer:
 <ul><li> E and F are correct. E and F both cause both threads to lock on the same object, which will prevent the threads from running simultaneously, and guarantee XXYY or YYXX. It's a bit unusual to lock on an object like System.out, but it's perfectly legal, and both threads are locking on the same object.</li>
 <li>A can't guarantee anything since it has no synchronization. B and D both synchronize on an instance of the Letters class-but since there are two different instances in the main() method, the two threads do not block each other and may run simultaneously, resulting in output like XYXY. C won't compile because it tries to override run() with a static method, and also calls a non-static method from a static method. G won't compile because System.out.class is nonsense. A class literal must start with a class name. System.out is a field not a class, so System.out.class is not a valid class literal.</li></ul>
 
<h3>30. The following block of code creates a Thread using a Runnable target:</h3>
<pre>
Runnable target = new MyRunnable(); 
Thread myThread = new Thread(target); 
</pre>
Which of the following classes can be used to create the target, so that the preceding code compiles correctly ?
<ol>
<li> public class MyRunnable extends Runnable{public void run(){}}</li>
<li> public class MyRunnable extends Object{public void run(){}}</li>
<li> public class MyRunnable implements Runnable{public void run(){}}</li>
<li> public class MyRunnable implements Runnable{void run(){}}</li>
<li> public class MyRunnable implements Runnable{public void start(){}}</li>
</ol>
 Answer:
 <ul><li> C is correct. The class implements the Runnable interface with a legal run() method.</li>
 <li>A is incorrect because interfaces are implemented, not extended. B is incorrect because even though the class has a valid public void run() method, it does not implement the Runnable interface. D is incorrect because the run() method must be public. E is incorrect because the method to implement is run(), not start().</li></ul>
 
 <h3> 31. Given the following,</h3>
<pre> 
2. class MyThread extends Thread { 
3. public static void main(String [] args) { 
4. MyThread t = new MyThread(); 
5. t.start();
6. System.out.print("one. "); 
7. t.start(); 
8. System.out.print("two. "); 
9. } 
10. public void run() { 
11. System.out.print("Thread "); 
12. } }
</pre>
 What is the result of this code ?
<ol>
<li> Compilation fails.</li>
<li> An exception occurs at runtime.</li> 
<li> Thread one. Thread two.</li>
<li> The output cannot be determined.</li>
</ol> 
 
 Answer:
 <ul><li> B is correct. When the start() method is attempted a second time on a single Thread object, 
 the method will throw an IllegalThreadStateException.
  (Although this behavior is specified in the API, some JVMs don't consistently throw an exception in this case).
   Even if the thread has finished running, it is still illegal to call start() again.</li>
   <li>A is incorrect because compilation will succeed. For the most part, the Java compiler only checks for illegal syntax, rather than class-specific logic. C and D are incorrect because of the logic explained above.</li></ul>
   
   
<h3> 32. Given the following</h3> 
<pre>
3. class MyThread extends Thread { 
4. public static void main(String [] args) { 
5. MyThread t = new MyThread(); 
6. Thread x = new Thread(t); 
7. x.start(); 
8. } 
9. public void run() { 
10. for(int i=0;i&lt;3;++i) { 
11. System.out.print(i + ".."); 
12. } } }
</pre>
 What is the result of this code ?
 <ol><li> Compilation fails.</li><li> 1..2..3.. </li><li> 0..1..2..3.. </li>
 <li> 0..1..2..</li><li> An exception occurs at runtime.</li></ol>
  Answer:
  
<ul><li> D is correct. The thread MyThread will start and loop three times (from 0 to 2).</li>
<li> A is incorrect because the Thread class implements the Runnable interface; therefore, in line 5, 
Thread can take an object of type Thread as an argument in the constructor (this is NOT recommended). 
B and C are incorrect because the variable i in the for loop starts with a value of 0 and ends with a value of 2. 
E is incorrect based on the above.</li></ul>


<h3>33. Given the following</h3>
<pre>
3. class Test { 
4. public static void main(String [] args) { 
5. printAll(args); 
6. } 
7. public static void printAll(String[] lines) { 
8. for(int i=0;i&lt;lines.length;i++){ 
9. System.out.println(lines[i]);
10. Thread.currentThread().sleep(1000); 
11. } } }
</pre>
 The static method Thread.currentThread() returns a reference to the currently executing Thread object. 
<br>
What is the result of this code ?
<ol><li> Each String in the array lines will print, with exactly a 1-second pause between lines.</li>
<li> Each String in the array lines will print, with no pause in between because this method is not executed in a Thread.</li>
<li> Each String in the array lines will print, and there is no guarantee there will be a pause because currentThread() may not retrieve this thread.</li>
<li> This code will not compile.</li>
<li> Each String in the lines array will print, with at least a one-second pause between lines.</li></ol>

Answer:
<ul>
<li> D is correct. The sleep() method must be enclosed in a try/catch block, or the method printAll() must declare it throws the InterruptedException.</li>
<li>E is incorrect, but it would be correct if the InterruptedException was dealt with (A is too precise). B is incorrect (even if the InterruptedException was dealt with) because all Java code, including the main() method, runs in threads. C is incorrect. The sleep() method is static, it always affects the currently executing thread.</li></ul>

<h3> 34.</h3>
A ssume you have a class that holds two private variables: a and b. Which of the following pairs can prevent concurrent access problems in that class? (Choose all that apply.)

<ol><li> public int read(){return a+b;} public void set(int a, int b){this.a=a;this.b=b;}</li>
<li> public synchronized int read(){return a+b;} public synchronized void set(int a, int b){this.a=a;this.b=b;}</li>
<li> public int read(){synchronized(a){return a+b;}} public void set(int a, int b){synchronized(a){this.a=a;this.b=b;}}</li>
<li> public int read(){synchronized(a){return a+b;}} public void set(int a, int b){synchronized(b){this.a=a;this.b=b;}}</li>
<li> public synchronized(this) int read(){return a+b;} public synchronized(this) void set(int a, int b){this.a=a;this.b=b;}</li>
<li> public int read(){synchronized(this){return a+b;}} public void set(int a, int b){synchronized(this){this.a=a;this.b=b;}}</li></ol>

 Answer:
 <ul><li> B and F are correct. By marking the methods as synchronized, the threads will get the lock of the this object before proceeding. Only one thread will be setting or reading at any given moment, thereby assuring that read() always returns the addition of a valid pair.</li>
 <li>A is incorrect because it is not synchronized; therefore, there is no guarantee that the values added by the read() method belong to the same pair. C and D are incorrect; only objects can be used to synchronize on. E fails- it is not possible to select other objects (even this) to synchronize on when declaring a method as synchronized.</li></ul>
 
 
 <h3> 35. Which are methods of the Object class? (Choose all that apply.)</h3>
 <ol><li> notify();</li><li> notifyAll();</li><li> isInterrupted();</li><li> synchronized();</li><li> interrupt();</li><li> wait(long msecs);
</li><li> sleep(long msecs);</li><li> yield();</li></ol>
 

Answer:
<ul><li> A , B, and F are correct. They are all related to the list of threads waiting on the specified object.</li> 
<li>C, E, G, and H are incorrect answers. The methods isInterrupted() and interrupt()are instance methods of Thread. The methods sleep() and yield() are static methods of Thread. D is incorrect because synchronized is a keyword and the synchronized()construct is part of the Java language.</li></ul>

<h3>36.</h3>
 Given the following 
<pre>
1. public class WaitTest { 
2. public static void main(String [] args) { 
3. System.out.print("1 "); 
4. synchronized(args){ 
5. System.out.print("2 "); 
6. try { 
7. args.wait(); 
8. } 
9. catch(InterruptedException e){} 
10. } 
11. System.out.print("3 "); 
12. } } 
</pre>

What is the result of trying to compile and run this program ?
<ol><li> It fails to compile because the IllegalMonitorStateException of wait() is not dealt with inline 7.</li>
<li> 1 2 3</li><li> 1 3 </li><li> 1 2</li><li> At runtime, it throws an IllegalMonitorStateException when trying to wait.</li>
<li> It will fail to compile because it has to be synchronized on the this object.</li></ol>
 Answer:
 <ul><li>D is correct. 1 and 2 will be printed, but there will be no return from the wait call because no other thread will notify the main thread, so 3 will never be printed. It's frozen at line 7.</li>
 <li>A is incorrect; IllegalMonitorStateException is an unchecked exception. B and C are incorrect; 3 will never be printed, since this program will wait forever. E is incorrect because IllegalMonitorStateException will never be thrown because the wait()is done on args within a block of code synchronized on args. F is incorrect because any object can be used to synchronize on and this and static don't mix.</li></ul>
 
 <h3>  37.</h3>
  Assume the following method is properly synchronized and called from a thread A on an object B: wait(2000);<br>
   After calling this method, when will the thread A become a candidate to get another turn at the CPU ?
  <ol><li> After object B is notified, or after two seconds.</li><li> After the lock on B is released, or after two seconds.</li>
  <li> Two seconds after object B is notified.</li><li> Two seconds after lock B is released.</li></ol>
 Answer:
 <ul>
 <li> A is correct. Either of the two events will make the thread a candidate for running again.</li>
<li>B is incorrect because a waiting thread will not return to runnable when the lock is released, unless a notification occurs.</li>
<li>C is incorrect because the thread will become a candidate immediately after notification.</li> 
<li>D is also incorrect because a thread will not come out of a waiting pool just because a lock has been released.</li>
</ul> 

<h3>38. Which are true? (Choose all that apply.)</h3>
<ol>
<li> The notifyAll() method must be called from a synchronized context.</li>
<li> To call wait(), an object must own the lock on the thread.</li>
<li> The notify() method is defined in class java.lang.Thread.</li>
<li> When a thread is waiting as a result of wait(), it release its lock.</li>
<li> The notify() method causes a thread to immediately release its lock.</li>
<li> The difference between notify() and notifyAll() is that notifyAll() notifies all waiting threads, regardless of the object they're waiting on.</li></ol>

 Answer:
 <ul><li>A is correct because notifyAll() (and wait() and notify()) must be called from within a synchronized context. D is a correct statement.</li>
 <li>B is incorrect because to call wait(), the thread must own the lock on the object that wait() is being invoked on, not the other way around. C is wrong because notify() is defined in java.lang.Object. E is wrong because notify() will not cause a thread to release its locks. The thread can only release its locks by exiting the synchronized code. F is wrong because notifyAll() notifies all the threads waiting on a particular locked object, not all threads waiting on any object.</li></ul>
 
<h3>  39. Given the scenario:</h3>
 This class is intended to allow users to write a series of messages, so that each message is identified with a timestamp and the name of the thread that wrote the message: 
 <pre>
 public class Logger { 
  private StringBuilder contents = new StringBuilder(); 
  public void log(String message) { 
   contents.append(System.currentTimeMillis()); 
   contents.append(": "); 
   contents.append(Thread.currentThread().getName()); 
   contents.append(message); 
   contents.append("\n"); 
  } 
  public String getContents() { return contents.toString(); } 
 }
</pre>
  How can we ensure that instances of this class can be safely used by multiple threads ?
<ol><li> This class is already thread-safe.</li><li> Replacing StringBuilder with StringBuffer will make this class thread-safe.</li>
<li> Synchronize the log() method only.</li><li> Synchronize the getContents() method only.</li>
<li> Synchronize both log() and getContents().</li><li> This class cannot be made thread-safe.</li></ol>

 Answer:
 <ul><li> E is correct. Synchronizing the public methods is sufficient to make this safe, so F is false. This class is not thread-safe unless some sort of synchronization protects the changing data.</li>
 <li>B is not correct because although a StringBuffer is synchronized internally, we call append() multiple times, and nothing would prevent two simultaneous log() calls from mixing up their messages. C and D are not correct because if one method remains unsynchronized, it can run while the other is executing, which could result in reading the contents while one of the messages is incomplete, or worse. (You don't want to call getString() on the StringBuffer as it's resizing its internal character array.)</li></ul>
  

<h3>40. Given:</h3>
<pre> 
public static synchronized void main(String[] args) throws InterruptedException { 
 Thread t = new Thread(); 
 t.start(); 
 System.out.print("X"); 
 t.wait(10000); 
 System.out.print("Y"); 
}
</pre>
 What is the result of this code ?
<ol>
<li> It prints X and exits.</li>
<li> It prints X and never exits.</li>
<li> It prints XY and exits almost immediately.</li>
<li> It prints XY with a 10-second delay between X and Y.</li>
<li> It prints XY with a 10000-second delay between X and Y.</li>
<li> The code does not compile.</li>
<li> An exception is thrown at runtime.</li>
</ol> 
  
Answer:
<ul>
<li> G is correct. The code does not acquire a lock on t before calling t.wait(), so it throws an IllegalThreadStateException. <br>
 The method is synchronized, but it's not synchronized on t so the exception will be thrown. <br>
  If the wait were placed inside a synchronized(t) block, then the answer would have been D.</li>
<li>A, B, C, D, E, and F are incorrect based the logic described above.</li></ul>


<h3> 41. Given the following:</h3>
<pre>
class MyThread extends Thread { 
 MyThread() { System.out.print(" MyThread"); } 
 public void run() { System.out.print(" bar"); } 
 public void run(String s) { System.out.print(" baz"); } 
}

public class TestThreads { 
 public static void main (String [] args) { 
 Thread t = new MyThread() { 
  public void run() { System.out.print(" foo"); }
 };
 t.start(); 
 }
}
</pre>
 What is the result ? 
 
<ol>
<li> foo</li><li> MyThread foo</li><li> MyThread bar</li><li> foo bar</li><li> foo bar baz</li><li> bar foo</li>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li></ol>

Answer:
<ul><li> B is correct. The first line of main we're constructing an instance of an anonymous innerclass extending from MyThread.<br>
 So the MyThread constructor runs and prints MyThread.<br>
  Next, main() invokes start() on the new thread instance, which causes the overridden run() method (the run() method in the anonymous inner class) to be invoked.</li>
<li>A, C, D, E, F, G and H are incorrect based on the logic described above.</li></ul>

<h3> 42. Given</h3>
<pre>
public class ThreadDemo { 
 synchronized void a() { actBusy(); } 
 static synchronized void b() { actBusy(); } 
 static void actBusy() { 
  try { Thread.sleep(1000); } 
  catch (InterruptedException e) {} 
 } 
 public static void main(String[] args) { 
  final ThreadDemo x = new ThreadDemo(); 
  final ThreadDemo y = new ThreadDemo(); 
  Runnable runnable = new Runnable() { 
   public void run() { 
   int option = (int) (Math.random() * 4); 
   switch (option) {
    case 0: x.a(); break; 
    case 1: x.b(); break; 
    case 2: y.a(); break; 
    case 3: y.b(); break; 
   } 
  } 
  };
   Thread thread1 = new Thread(runnable); 
   Thread thread2 = new Thread(runnable); 
   thread1.start(); thread2.start(); 
   } 
  } 
  </pre>
  
  Which of the following pairs of method invocations could NEVER be executing at the same time? (Choose all that apply.) 
<ol>
<li> x.a() in thread1, and x.a() in thread2</li><li> x.a() in thread1, and x.b() in thread2</li>
<li> x.a() in thread1, and y.a() in thread2</li>
<li> x.a() in thread1, and y.b() in thread2</li>
<li> x.b() in thread1, and x.a() in thread2</li>
<li> x.b() in thread1, and x.b() in thread2</li>
<li> x.b() in thread1, and y.a() in thread2</li>
<li> x.b() in thread1, and y.b() in thread2</li></ol>

 Answer:
 <ul><li> A , F and H. A is incorrect because synchronized instance methods called on the same instance, block each other. <br>
  F and H could not happen because synchronized static methods in the same class block each other, 
  regardless of which instance was used to call the methods. (An instance is not required to call static methods; only the class.)</li>
<li>C could happen because synchronized instance methods called on different instances do not block each other. B, D, E, and G could all happen because instance methods and static methods lock on different objects, and do not block each other.</li></ul>


<h3> 43. Given the following,</h3>
<pre>
1. public class Test { 
2. public static void main (String [] args) { 
3. final Foo f = new Foo(); 
4. Thread t = new Thread(new Runnable() { 
5. public void run() { 
6. f.doStuff(); 
7. } 
8. }); 
9. Thread g = new Thread() { 
10. public void run() { 
11. f.doStuff(); 
12. } 
13. }; 
14. t.start(); 
15. g.start(); 
16. } 
17. }

1. class Foo { 
2. int x = 5; 
3. public void doStuff() { 
4. if (x &lt; 10) { 
5. // nothing to do 
6. try { 
7. wait(); 
8. } catch(InterruptedException ex) { } 
9. } else { 
10. System.out.println("x is " + x++); 
11. if (x >= 10) { 
12. notify(); 
13. } 
14. } 
15. } 
16. } 
</pre>

What is the result ? 
<ol>
<li> The code will not compile because of an error on line 12 of class Foo.</li>
<li> The code will not compile because of an error on line 7 of class Foo.</li>
<li> The code will not compile because of an error on line 4 of class Test.</li>
<li> The code will not compile because of some other error in class Test.</li>
<li> An exception occurs at runtime.</li>
<li> x is 5 x is 6</li>
</ol>
 Answer:
 <ul><li> E is correct because the thread does not own the lock of the object it invokes wait() on. If the method were synchronized, the code would run without exception.</li>
 <li>A, B, C, and D are incorrect because the code compiles without errors. F is incorrect because the exception is thrown before there is any output.</li></ul>
 
<h3>44. Given:</h3> 
<pre>
public class TwoThreads { 
 static Thread laurel, hardy; 
 public static void main(String[] args) { 
  laurel = new Thread() { 
  public void run() { 
   System.out.println("A"); 
   try { hardy.sleep(1000); } 
   catch (Exception e) { System.out.println("B");
   } 
  System.out.println("C");
  } }; 
  
  hardy = new Thread() { 
   public void run() { System.out.println("D"); 
   try { laurel.wait(); } 
   catch (Exception e) { System.out.println("E"); } 
   System.out.println("F"); 
  } 
  }; 
  laurel.start(); 
  hardy.start(); 
 } 
}
</pre>

 Which letters will eventually appear somewhere in the output ? (Choose all that apply.)
 <ol><li> A</li><li> B</li><li> C</li><li> D </li><li> E</li><li> F</li>
 <li> The answer cannot be reliably determined.</li><li>  The code does not compile.</li></ol>
 
 Answer:
 <ul><li> A , C, D, E and F are correct. <br>
 This may look like laurel and hardy are battling to cause the other to sleep() or wait()-but that's not the case.
  Since sleep() is a static method, it affects the current thread,
   which is laurel (even though the method is invoked using a reference to hardy). 
   That's misleading but perfectly legal, and the Thread laurel is able to sleep with no exception, 
   printing A and C (after a 1-second delay). Meanwhile hardy tries to call laurel.wait()-but hardy has not synchronized on laurel, 
   so calling laurel.wait() immediately causes an IllegalThreadStateException, and so hardy prints D, E, and F. 
   Although the order of the output is somewhat indeterminate (we have no way of knowing whether A is printed before D, for example)
    it is guaranteed that A, C, D, E, and F will all be printed in some order, eventually-so G is incorrect.</li>
 <li>B, G and H are incorrect based on the above</li></ul>












<br><br>
</td></tr></table>
<a href="index-2.html">BACK</a>

</div>

</body>

<!-- Mirrored from ocpjp.jobs4times.com/multiThread.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
</html>