<!DOCTYPE html>
<html>

<!-- Mirrored from ocpjp.jobs4times.com/lang.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
<head>
<meta charset="ISO-8859-1">

<title> Java.lang Package Certification Programs </title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<div align="center">   
<table border="1"> <tr><td width="900px">
    
    
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500" height="200">   </a> </td> 
<td  align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 	  	
</tr>
</table>			
    
    
	
<h1 align="center"  style="background-color: rgb(64, 0, 64);"> <font color="#ffff00">Java.lang Package Certification Programs </font>  </h1>

	
<h3> Q:01 Given:</h3>
<pre>
11. public class Person { 
12. private String name, comment; 
13. private int age; 
14. public Person(String n, int a, String c) { 
15. name = n; age = a; comment = c; 
16. } 
17. public boolean equals(Object o) { 
18. if (! (o instanceof Person)) return false; 
19, Person p = (Person)o; 
20. return age == p.age &amp;&amp; name.equals(p.name); 
21. } 
22. }
</pre>

 What is the appropriate definition of the hashCode method in class Person ?
<ol>
<li> return super.hashCode();</li><li> return name.hashCode() + age * 7;</li>
<li> return name.hashCode() + comment.hashCode() / 2;</li>
<li> return name.hashCode() + comment.hashCode() / 2 - age * 3;</li>
</ol>
 Answer: B 
 
 <h3> Q: 02 Given this method in a class:</h3>
 
<pre> 
21. public String toString() { 
22. StringBuffer buffer = new StringBuffer(); 
23. buffer.append('&lt;'); 
24. buffer.append(this.name); 
25. buffer.append('>'); 
26. return buffer.toString(); 
27. }
</pre>

 Which statement is true ?
<ol>
<li> This code is NOT thread-safe.</li><li> The programmer can replace StringBuffer with StringBuilder with no other changes.</li>
<li> This code will perform poorly. For better performance, the code should be rewritten: return "&lt;" + this.name + ">";</li>
<li> This code will perform well and converting the code to use StringBuilder will not enhance the performance.</li></ol>
 Answer: B

<h3>Q: 03 Given:</h3> 
<pre>
11. public void testIfA() { 
12. if (testIfB("True")) { 
13. System.out.println("True"); 
14. } else { 
15. System.out.println("Not true"); 
16. }
17. } 
18. public Boolean testIfB(String str) { 
19. return Boolean.valueOf(str); 
20. }
</pre>
 What is the result when method testIfA is invoked ?
<ol>
<li> True</li><li> Not true</li><li> An exception is thrown at runtime.</li><li> Compilation fails because of an error at line 12.</li>
<li> Compilation fails because of an error at line 19.</li></ol>
Answer: A 
<h3>Q: 04 Given:</h3>

<pre>
1. public class Boxer1{ 
2. Integer i; 
3. int x; 
4. public Boxer1(int y) { 
5. x = i+y; 
6. System.out.println(x); 
7. } 
8. public static void main(String[] args) { 
9. new Boxer1(new Integer(4)); 
10. } 
11. }
</pre>

 What is the result ?
<ol><li> The value "4" is printed at the command line.</li><li> Compilation fails because of an error in line 5.</li>
<li> Compilation fails because of an error in line 9.</li><li> A NullPointerException occurs at runtime.</li>
<li> A NumberFormatException occurs at runtime.</li>
<li> An IllegalStateException occurs at runtime.</li>
</ol>
 Answer: D
<h3>  Q: 05 Given:</h3>
<pre>
1. public class TestString3 { 
2. public static void main(String[] args) { 
3. // insert code here 

5. System.out.println(s); 
6. } 
7. }
</pre>
 Which two code fragments, inserted independently at line 3, generate the output 4247 ? (Choose two.)
<ol><li> String s = "123456789"; s = (s-"123").replace(1,3,"24") - "89";</li>
<li> StringBuffer s = new StringBuffer("123456789"); s.delete(0,3).replace(1,3,"24").delete(4,6);</li>
<li> StringBuffer s = new StringBuffer("123456789"); s.substring(3,6).delete(1,3).insert(1, "24");</li>
<li>StringBuilder s = new StringBuilder("123456789"); s.substring(3,6).delete(1,2).insert(1, "24");</li>
<li> StringBuilder s = new StringBuilder("123456789"); s.delete(0,3).delete(1,3).delete(2,5).insert(1, "24");</li></ol>
 Answer: B, E
 
<h3> Q: 06 Given:</h3> 
<pre>
11. public static void test(String str) { 
12. int check = 4; 
13. if (check = str.length()) { 
14. System.out.print(str.charAt(check -= 1) +", "); 
15. } else { 
16. System.out.print(str.charAt(0) + ", "); 
17. } 
18. } 
and the invocation: 
21. test("four"); 
22. test("tee"); 
23. test("to");
</pre>
 What is the result ?
<ol><li> r, t, t,</li><li> r, e, o,</li><li> Compilation fails.</li>
<li> An exception is thrown at runtime.</li></ol>
 Answer: C

<h3>  Q: 07 Given:</h3>
<pre>
11. public class Person { 
12. private String name; 
13. public Person(String name) { 
14. this.name = name; 
15. } 
16. public boolean equals(Object o) { 
17. if ( ! o instanceof Person ) return false; 
18. Person p = (Person) o; 
19. return p.name.equals(this.name); 
20. } 
21. }
</pre>
 Which statement is true ?
<ol><li> Compilation fails because the hashCode method is not overridden.</li>
<li> A HashSet could contain multiple Person objects with the same name.</li>
<li> All Person objects will have the same hash code because the hashCode method is not overridden.</li>
<li> If a HashSet contains more than one Person object with name="Fred", then removing another Person, also with name="Fred", will remove them all.</li></ol>

 Answer: B

<h3>Q: 08 Which two statements are true about the hashCode method? (Choose two.)</h3>
<ol><li> The hashCode method for a given class can be used to test for object equality and object inequality for that class.</li>
<li> The hashCode method is used by the java.util.SortedSet collection class to order the elements within that set.</li>
<li> The hashCode method for a given class can be used to test for object inequality, but NOT object equality, for that class.</li>
<li> The only important characteristic of the values returned by a hashCode method is that the distribution of values must follow a Gaussian distribution.</li>
<li> The hashCode method is used by the java.util.HashSet collection class to group the elements within that set into hash buckets for swift retrieval.</li></ol>

Answer: C, E

<h3>Q: 09 Click the Task button.</h3>
<pre>
1.&lt;T extends Pet>
2. T
3.T
4.T
</pre>

<h3>Q: 10 Given:</h3>
<pre>
10. public class MyClass { 
11. 
12. public Integer startingI; 
13. public void methodA() { 
14. Integer i = new Integer(25); 
15. startingI = i; 
16. methodB(i); 
17. } 
18. private void methodB(Integer i2) { 
19. i2 = i2.intValue(); 
20. 
21. } 
22. }
</pre>
 If methodA is invoked, which two are true at line 20 ? (Choose two.)
<ol><li> i2 == startingI returns true.</li>
<li> i2 == startingI returns false.</li><li> i2.equals(startingI) returns true.</li>
<li> i2.equals(startingI) returns false.</li></ol>
 Answer: B, C 
 
<h3> Q : 11 Given:</h3>
<pre>
11. public String makinStrings() { 
12. String s = “Fred”; 
13. s = s + “47”; 
14. s = s.substring(2, 5); 
15. s = s.toUpperCase(); 
16. return s.toString(); 
17. } 
</pre>
How many String objects will be created when this method is invoked ?
<ol><li> 1</li><li> 2</li><li> 3</li><li> 4 </li><li> 5</li><li> 6</li></ol> Answer: E 

<h3>Q: 12 Given:</h3>

<pre>
22. StringBuilder sb1 = new StringBuilder("123"); 
23. String s1 = "123"; 
24. // insert code here 
25. System.out.println(sb1 + " " + s1);
</pre>
 Which code fragment, inserted at line 24, outputs "123abc 123abc" ?
<ol><li> sb1.append("abc"); s1.append("abc");</li>
<li> sb1.append("abc"); s1.concat("abc");</li>
<li> sb1.concat("abc"); s1.append("abc");</li>
<li> sb1.concat("abc"); s1.concat("abc");</li>
<li> sb1.append("abc"); s1 = s1.concat("abc");</li>
<li> sb1.concat("abc"); s1 = s1.concat("abc");</li>
<li> sb1.append("abc"); s1 = s1 + s1.concat("abc");</li>
<li> sb1.concat("abc"); s1 = s1 + s1.concat("abc");</li></ol>
 Answer: E

<h3>Q: 13 Given:</h3>
<pre>
1. public class BuildStuff { 
2. public static void main(String[] args) { 
3. Boolean test = new Boolean(true); 
4. Integer x = 343; 
5. Integer y = new BuildStuff().go(test, x); 
6. System.out.println(y); 
7. } 
8. int go(Boolean b, int i) { 
9. if(b) return (i/7); 
10. return (i/49); 
11. } 
12. }
</pre>
 What is the result ?
<ol><li> 7</li><li> 49</li><li> 343</li><li> Compilation fails.</li><li> An exception is thrown at runtime.</li></ol>
 Answer: B

<h3> Q: 14 Given:</h3>

<pre>
1. public class KungFu { 
2. public static void main(String[] args) { 
3. Integer x = 400; 
4. Integer y = x; 
5. x++; 
6. StringBuilder sb1 = new StringBuilder("123"); 
7. StringBuilder sb2 = sb1; 
8. sb1.append("5"); 
9. System.out.println((x==y) + " " + (sb1==sb2)); 
10. } 
11. } 
</pre>
What is the result ?
<ol><li> true true</li><li> false true</li><li> true false</li><li> false false</li>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li></ol> 
Answer: B

<h3> Q: 15 Given:</h3>
 Which two scenarios are NOT safe to replace a StringBuffer object with a StringBuilder object ? (Choose two.)

<ol>
<li> When using versions of Java technology earlier than 5.0.</li>
<li> When sharing a StringBuffer among multiple threads.</li>
<li> When using the java.io class StringBufferInputStream.</li>
<li> When you plan to reuse the StringBuffer to build more than one string.</li></ol>
 Answer: A, B
 
 <h3>  16.</h3> 
 Which statements are true about comparing two instances of the same class, 
 given that the equals() and hashCode() methods have been properly overridden? (Choose all that apply.)
 
<ol>
<li> If the equals() method returns true, the hashCode() comparison == might return false.</li>
<li> If the equals() method returns false, the hashCode() comparison == might return true.</li>
<li> If the hashCode() comparison == returns true, the equals() method must return true.</li>
<li> If the hashCode() comparison == returns true, the equals() method might return true.</li>
<li>  If the hashCode() comparison != returns true, the equals() method might return true.</li>
</ol> 
  
Answer:
<ul><li> B and D. B is true because often two dissimilar objects can return the same hashcode value. D is true because if the hashCode() comparison returns ==, the two objects might or might not be equal.</li>
<li>A, C, and E are incorrect. C is incorrect because the hashCode() method is very flexible in its return values, and often two dissimilar objects can return the same hash code value. A and E are a negation of the hashCode() and equals() contract.</li></ul>

<h3>17. Given:</h3>
<pre>
1. class Convert { 
2. public static void main(String[] args) { 
3. Long xL = new Long(456L); 
4. long x1 = Long.valueOf("123"); 
5. Long x2 = Long.valueOf("123"); 
6. long x3 = xL.longValue(); 
7. Long x4 = xL.longValue(); 
8. Long x5 = Long.parseLong("456"); 
9. long x6 = Long.parseLong("123"); 
10. } 
11. }
</pre>
Which will compile using Java 5, but will NOT compile using Java 1.4 ? (Choose all that apply.)
<ol><li> Line 4.</li><li> Line 5.</li><li> Line 6.</li><li> Line 7.</li><li> Line 8.</li>
<li> Line 9.</li></ol>
 Answer:
<ul><li>A, D, and E are correct. Because of the methods‘ return types, these method calls required autoboxing to compile.</li>
<li>B, C, and F are incorrect based on the above.</li></ul>

<h3> 18. Given:</h3>
<pre>
class TKO { 
public static void main(String[] args) { 
 String s = "-"; Integer x = 343
 long L343 = 343L; 
 
 if(x.equals(L343)) s += ".e1 "; 
 if(x.equals(343)) s += ".e2 "; 
 Short s1 = (short)((new Short((short)343)) / (new Short((short)49))); 
 if(s1 == 7) s += "=s "; 
 if(s1 &lt; new Integer(7+1)) s += "fly "; 
 System.out.println(s); 
} }
</pre>
Which of the following will be included in the output String s ? (Choose all that apply.)
<ol><li> .e1</li><li> .e2 C. =s</li><li> fly E. None of the above.</li>
<li> Compilation fails.</li><li> An exception is thrown at runtime.</li></ol>
 Answer:
 <ul><li> B , C, and D are correct. Remember, that the equals() method for the integer wrappers will only return true if the two primitive types and the two values are equal. With C, it's okay to unbox and use ==. For D, it's okay to create a wrapper object with an expression, and unbox it for comparison with a primitive.</li>
 <li>A, E, F, and G are incorrect based on the above. (Remember that A is using the equals() method to try to compare two different types.)</li></ul>
 
<h3> 19. Which about the three java.lang classes String, StringBuilder, and StringBuffer are true ? (Choose all that apply.)</h3>
<ol><li> All three classes have a length() method.</li><li> Objects of type StringBuffer are thread-safe.</li>
<li> All three classes have overloaded append() methods.</li>
<li> The "+" is an overloaded operator for all three classes.</li>
<li> According to the API, StringBuffer will be faster than StringBuilder under most implementations.</li>
<li> The value of an instance of any of these three types can be modified through various methods in the API.</li></ol>

 Answer:
 <ul><li>A and B are correct.</li>
 <li>C is incorrect because String does not have an "append" method. D is incorrect because only String objects can be operated on using the overloaded "+" operator. E is backwards, StringBuilder is typically faster because it's not thread-safe. F is incorrect because String objects are immutable. A String reference can be altered to refer to a different String object, but the objects themselves are immutable.</li></ul>
 
<h3>20. Given:</h3>
<pre>
class Polish { 
 public static void main(String[] args) { 
  int x = 4; 
  StringBuffer sb = new StringBuffer("..fedcba"); 
   sb.delete(3,6);
   sb.insert(3, "az"); 
   if(sb.length() > 6) x = sb.indexOf("b"); 
   sb.delete((x-3), (x-2)); 
   System.out.println(sb); 
 }
} 
</pre>

What is the result ?
<ol><li> .faza</li><li> .fzba </li>
<li> ..azba</li><li> .fazba</li><li> ..fezba</li><li> Compilation fails.</li>
<li> An exception is thrown at runtime.</li></ol>

 Answer:
<ul><li> C is correct. Remember that StringBuffer methods use zero-based indexes, and that ending indexes are typically exclusive.</li>
<li>A, B, D, E, F, and G are incorrect based on the above. </li></ul>









<br><br>
</td></tr></table>
<a href="index-2.html">BACK</a>

</div>

</body>

<!-- Mirrored from ocpjp.jobs4times.com/lang.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
</html>