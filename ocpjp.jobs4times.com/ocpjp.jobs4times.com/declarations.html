<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<!-- Mirrored from ocpjp.jobs4times.com/declarations.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
<head>
<meta name="content-type" content="text/html; charset=ISO-8859-1">

<title>Declarations and Access Control OCJP Exam Objectives</title>
<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>

<div align="center">   
<table border="1"> <tr><td width="900px">

<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td width="50%" align="left"><a href="http://www.jobs4times.com/"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/banner%20J4T.jpg" width="500" height="200">   </a> </td> 
<td  align="right"><a href="http://jobs4times.com/J4T/allmaterial.html"><img alt="jobs4timesLogo"  src="../img.logos.jobs4times.com/as2.jpg"  width="180" height="200" >  </a>  </td> 	  	
</tr>
</table>			
    
    
	
<h1 align="center"  style="background-color: rgb(64, 0, 64);"> <font color="#ffff00">Declarations and Access Control </font>  </h1>

	



<h3>Question : 1</h3>
Click the task button,<br>

Place the lines in the correct order to complete the enum.

<pre>
enum Element{
  1 st
  2 nd
  3 rd
  4 th
  5 th
  
 Lines :
 
 public String info(){return "element";}
 
 };
 
 FIRE{ public String info(){ return "Hot"; }
 
 EARTH, WIND,
 
 } 
</pre>

<strong>Solution :</strong>
<pre>
enum Element{
 EARTH, WIND,
  FIRE{ public String info(){ return "Hot"; }
   };
	 
 public String info(){return "element";}
} 
</pre>


<h3>Question : 2</h3>
Given :
<pre>
package com.sun.scjp;

public class Geodetics{
public static final double DIAMETER=12756.32; //kilometers
}
</pre>

<strong>Which two correctly access the DIAMETER member of the Geodetics ? (Choose two)</strong>
<ol type="A">
<li>
<pre>
import com.sun.scjp.Geodetics;

public class TerraCarta{
 public double halfWay(){
  return Geodetics.DIAMETER/2.0;
 }
}
</pre> </li>
<li>
<pre>
import static com.sun.scjp.Geodetics;

public class TerraCarta{
 public double halfWay(){
  return DIAMETER/2.0;
 }
}
</pre> </li>
<li>
<pre>
import static com.sun.scjp.Geodetics.*;

public class TerraCarta{
 public double halfWay(){
  return DIAMETER/2.0;
 }
}
</pre> </li>
<li>
<pre>
import static com.sun.scjp;

public class TerraCarta{
 public double halfWay(){
  return DIAMETER/2.0;
 }
}
</pre> </li>
</ol>
<p> Answer : A, C </p>


<h3>Question : 3</h3>
Place the code elements in order so that the resulting Java source file will compile correctly, resulting in a class called com.sun.cert.AddressBook.

<pre>
Source File :

 1 st 
 2 nd
 3 rd
 ArrayList entries;
}


Code Element :

package com.sun.cert;
package com.sun.cert.*;
import java.util.*;
import java.*;
public class AddressBook {
public static class AddressBook {
</pre>

<strong>Solution :</strong>
<pre>
package com.sun.cert;
import java.util.*;

public class AddressBook {
	ArrayList entries;
}
</pre>



<h3>Question : 4</h3>
<pre>
</pre>

<strong>Which two classes correctly implement both the java.lang.Runnable and the java.lang.Clonable interfaces ? (Choose two)</strong>
<ol type="A">
<li>
<pre>
public class Session implements Runnable,Clonable {	
public void run();
public Object clone();
}
</pre> </li>
<li>
<pre>
public class Session extends Runnable,Clonable {	
public void run() {
 /* do something */
}
public Object clone(){
  /* make a copy */  
}

}
</pre> </li>
<li>
<pre>
public class Session implements Runnable, Clonable {	
public void run() {
 /* do something */
}
public Object clone(){
  /* make a copy */
}

}
</pre> </li>
<li>
<pre>
public abstract class Session implements Runnable, Clonable {	
public void run() {
 /* do something */
}
public Object clone(){
  /* make a copy */
}

}
</pre> </li>
<li>
<pre>
public class Session implements Runnable,implements Clonable {	
public void run() {
 /* do something */
}
public Object clone(){
  /* make a copy */ 
}

}
</pre></li>
</ol>
<p> Answer : C, D </p>



<h3>Question : 5</h3>
Given classes defined in two different filters :
<pre>
package util;

public class BitUtils {	
private static void process(byte[] bytes){
	//..........
}
	
}


package app;

public class SomeApp {	
public static void main(String[] args){
 byte[] bytes=new byte[256];
   
  // insert code here
}
}
</pre>

<strong>What is required at <i>insert code here</i>  in class SomeApp to use the process method of BitUtils ?</strong>
<ol type="A">
<li> process(bytes); </li>
<li> BitUtils.process(bytes); </li>
<li> app.BitUtils.process(bytes); </li>
<li> util.BitUtils.process(bytes); </li>
<li>import util.BitUtils.*; process(bytes); </li>
<li>SomeApp cannot use the process methods in BitUtils. </li> 
</ol>
<p> Answer : F </p>



<h3>Question : 6</h3>
Given :
<pre>
class Cup { }
class PoisionCup extends Cup{ }

..................

public void takeCup(Cup c){
 if(c instanceof PoisionCup){
  System.out.println("Inconceivable !");	 
 }
 else if(c instanceof Cup){
  System.out.println("Dizzying intellect !");
 }
 else {
  System.exit(0);
 }
	
}


And the execution of the statements :

Cup cup=new PoisionCup();
takeCup(cup);
</pre>

<strong>What is the output ?</strong>
<ol type="A">
<li>Inconceivable ! </li>
<li>Dizzying intellect ! </li>
<li>The code runs with no output </li>
<li>An exception is thrown at runtime </li>
<li>Compilation fails </li>
</ol>
<p> Answer : A </p>



<h3>Question : 7 </h3>
Click the Exhibit button
<pre>
public class A{
private int counter=0;
public static int getInstanceCount(){
	return counter;
}
public A(){
	counter++;
}

}

Given this code from Class B :
1 A a1=new A();
2 A a2=new A();
3 A a3=new A();
4 System.out.println(A.getInstanceCount());
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Compilation of class A fails </li>
<li>Line 4 prints the value 3 to System.out </li>
<li>Line 4 prints the value 1 to System.out </li>
<li>A runtime error occurs when line 1 executes </li>
<li>Compilation fails because of an error on Line 4</li>
</ol>
<p> Answer : A </p>


<h3>Question : 8</h3>
Given :
<pre>
String[] elements={"for","tea","too"};
String first=(elements.length &gt; 0)?elements[0]:null;
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Compilation fails </li>
<li>An exception is thrown at runtime </li>
<li>The variable first is set to null </li>
<li>The variable first is set to elements[0] </li>
</ol>
<p> Answer : D </p>



<h3>Question : 9</h3>
Given :
<pre>
interface DeclareStuff{
public static final int EASY=3;
void doStuff(int t);	
}

public class TestDeclare implements DeclareStuff {	
public static void main(String []args){
int x=5;
new TestDeclare().doStuff(++x);	
}

void doStuff(int s) {
s +=EASY + ++s;
System.out.println("s "+s);
}

}
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>s 14 </li>
<li>s 16 </li>
<li>s 10 </li>
<li>Compilation fails </li>
<li>An exception is thrown at runtime</li>
</ol>
<p> Answer :  D</p>




<h3>Question : 10</h3>
Given :
<pre>
public class TestString {	
public static void main(String []args){
String str="420";
str+=42;
System.out.println(str);
}

}
</pre>

<strong> What is the Output ?</strong>
<ol type="A">
<li>42 </li>
<li>420 </li>
<li>462 </li>
<li>42042 </li>
<li>Compilation fails</li>
<li>An exception is thrown at runtime</li>  
</ol>
<p> Answer : D </p>



<h3>Question : 11</h3>
<pre>
10 public class Converter {	
11 public static void main(String[] args){
12 Integer i=args[0];
13 int j=12;
14 System.out.println("It is "+(j==i)+" that j==i");
15 }
16 }
</pre>

<strong>What is the result when the programmer attempts to compile the code and run it with the command <br> java Converter 12 ?</strong>
<ol type="A">
<li>It is true that j==i </li>
<li>It is false that j==i </li>
<li>An exception is thrown at runtime </li>
<li>Compilation fails because  of an error in Line 12</li>
</ol>
<p> Answer :  D</p>


<h3>Question : 12</h3>
Given :
<pre>
10 int x=0;
11 int y=10;
12 do{
13  y--;
14  ++x; 
15 }while(x&lt;5);
16 System.out.println(x+","+y);
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>5,6 </li>
<li>5,5 </li>
<li>6,5 </li>
<li>6,6 </li>
</ol>
<p> Answer : B </p>



<h3>Question : 13</h3>
Given :
<pre>
public interface A{
 String DEFAULT_GREETING="Hello World";
 public void method();
}
</pre>

<strong>A programmer wants to create an interface called B that has A as its parent. Which interface declaration is correct ?</strong>
<ol type="A">
<li>public interface B extends A </li>
<li>public interface B implements A </li>
<li>public interface B instanceOf A </li>
<li>public interface B inheritsFrom A </li>
</ol>
<p> Answer : A </p>


<h3>Question : 14</h3>
Given :
<pre>
11 public enum Title {
12 MR("Mr."),MRS("Mrs."),MS("Ms.");
13 private final String title;
14 private Title(String t){ title=t; }
15 public String format(String last,String first){
16  return title+" "+first+" "+last;
17 }
18 }
19 public static void main(String[] args){
20 System.out.println(Title.MR.format("Doe", "John"));
21 }
</pre>

<strong>What is the result  ?</strong>
<ol type="A">
<li>Mr. John Doe </li>
<li>An exception is thrown at runtime. </li>
<li>Compilation fails because of an error in line 12 </li>
<li>Compilation fails because of an error in line 15 </li>
<li>Compilation fails because of an error in line 20</li>
</ol>
<p> Answer :  A</p>



<h3>Question : 15</h3>
Given :
<pre>
package test;

class Target{
public String name="hello";
}
</pre>

<strong>What can directly access and change the value of the variable name ?</strong>
<ol type="A">
<li>any class </li>
<li>only the Target class </li>
<li>any class in the test package </li>
<li>any class that extends Target </li>
</ol>
<p> Answer :  C</p>


<h3>Question : 16</h3>
<pre>
1 public class Ball {
2 public enum Color{RED,GREEN,BLUE};	
3 public void foo(){
4 //insert code here
5 { System.out.println(c); }
6 }
7 }
</pre>

<strong>Which code inserted at Line 4 causes  the foo method to print RED, GREEN, and BLUE  ?</strong>
<ol type="A">
<li>for(Color c:Color.values()) </li>
<li>for(Color c=RED;c&lt;=BLUE;c++) </li>
<li>for(Color c;c.hasNext();c.next()) </li>
<li>for(Color c=Color[0];c&lt;=Color[2];c++)</li>
<li>for(Color c=Color.RED;c&lt;=Color.BLUE;c++)</li>
</ol>
<p> Answer : A </p>



<h3>Question : 17  click the task button</h3>
Insert six modifiers into the code such that it meets all of these requirements :
<ol>
<li>It must be possible to create instance of Alpha and Beta from outside the packages in which they are defined.</li>
<li>When an object of type Alpha (or any potential subclass of Alpha) has been created, the instance variable alpha may never be changed.</li>
<li>The value of the instance  variable alpha must always be "A" for objects of the Alpha.</li>
</ol>

<pre>
Code :

package alpha;
xxxxxx class Alpha {
xxxxxx String alpha;
xxxxxx Alpha(){ this("A"); }
xxxxxx Alpha(String a){ alpha=a; }
}

package beta;
xxxxxx class Beta extends alpha.Alpha{
xxxxxx Beta(String a){ super(a); }
}


Modifiers :
private
protected
public
</pre>

<strong>Solution :</strong>
<pre>
package alpha;
public class Alpha {
private String alpha;
public Alpha(){ this("A"); }
protected Alpha(String a){ alpha=a; }
}

package beta;
public class Beta extends alpha.Alpha{
private Beta(String a){ super(a); }
}
</pre>


<h3>Question : 18</h3>
Given :
<pre>
1 public class Target{
2 private int i=0;
3 public int addOne(){
4  return ++i;
5 }
6 }

And:

1 public class Client{
2 public static void main(String[] args){
3 System.out.println(new Target().addOne());
4 }
5 }
</pre>

<strong>Which change can you make to Target without affecting Client ?</strong>
<ol type="A">
<li>Line 4 of class Target can be changed to return i++; </li>
<li>Line 2 of class Target can be changed to private int i=1; </li>
<li>Line 3 of class Target can be changed to private int addOne(){ </li>
<li>Line 2 of class Target can be changed to private Integer i=0; </li>
</ol>
<p> Answer : D </p>




<h3>Question : 19  Click the Task button</h3>
Replace two of the Modifiers that appear in the Single class to make the code compile. <br>
Note : Three modifiers will not be used and four modifiers in the code will return unchanged.
 
<pre>
Code :

public class Single{
<b>private static</b> Single instance;
<b>public static</b> Single getInstance(){
 if(instance==null) instance=create();
 return instance;
}
<b>private</b> Single() { }
<b>protected</b> Single create(){ return new Single();}
}

class SingleSub extends Single{
}


Modifiers :
final
protected
private
abstract
static
</pre>

<strong>Solution :</strong>
<pre>
public class Single{
private static Single instance;
public static Single getInstance(){
 if(instance==null) instance=create();
 return instance;
}
<b>protected</b> Single() { }
<b>static</b> Single create(){ return new Single();}
}

class SingleSub extends Single{
}
</pre>


<h3>Question : 20</h3>
Given :
<pre>
public class Test{
public enum Dogs{collie,harrier};
public static void main(String[] args){
 Dogs myDogs=Dogs.collie;
 switch(myDogs){
 case collie:
	System.out.println("collie");
 case harrier:
	System.out.println("harrier");
 }
}
}
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>collie </li>
<li>harrier </li>
<li>Compilation fails. </li>
<li>collie harrier </li>
<li>An exception is thrown at runtime.</li>
</ol>
<p> Answer :  D</p>



<h3>Question : 21   Click the Exhibit button.</h3>
Given :
<pre>
ClassA a=new ClassA();
a.methodA();
</pre>

<strong>What is the result  ?</strong>
<pre>
public class ClassA {
 public void methodA(){
  ClassB classB=new ClassB();
  classB.getValue();
 }
}

And :

class ClassB{
public ClassC classC;
 public String getValue() {
  return classC.getValue();
 }
}

And :

class ClassC{
public String value;
 public String getValue(){
  value="ClassB";
  return value;
 }
}
</pre>
<ol type="A">
<li>Compilation fails. </li>
<li>ClassC is displayed </li>
<li>The code runs  with no output </li>
<li>An exception is thrown at runtime. </li>
</ol>
<p> Answer : D </p>




<h3>Question : 22  Click the button.</h3>
Please code fragments into position so the output is : <p> The quantity is 420 </p>

<pre>
<b>place here</b> update(int quantity,int adjust){
 <b>place here</b>
}
public void callUpdate(){
 int quant=100;
 <b>place here</b>
 System.out.println("The quantity is "+quant);
}

Code Fragments :

1 public int

2 public void

3 quantity=quantity+adjust;

4 quant=update(quant,320);

5 update(quant,320);

6 quantity=quantity+adjust;
  return quantity;
</pre>

<strong>Solution :</strong>
<pre>
public int update(int quantity,int adjust){
 quantity=quantity+adjust;
 return quantity;
}
public void callUpdate(){
 int quant=100;
 quant=update(quant,320);
 System.out.println("The quantity is "+quant);
}
</pre>



<h3>Question : 23</h3>
Given :
<pre>
1 package sun.scjp;
2 public enum Color { RED,GREEN,BLUE }

1 package sun.beta;
2 <b>//insert code here</b>
3 public class Beta{
4 Color g=GREEN;
5 public static void main(String[] args){
6  System.out.println(GREEN);
7 }
8 }
</pre>

<strong>Which two code fragments, inserted individually at Line 2 of the Beta declaration, 
will allow this code to compile ? (Choose two)</strong>
<ol type="A">
<li>import sun.scjp.Color.*; </li>
<li>import static sun.scjp.Color.*; </li>
<li>import sun.scjp.Color;
import static sun.scjp.Color.*; </li>
<li>
import sun.scjp.*;
import static sun.scjp.Color.*; </li>
<li>
import sun.scjp.Color;
import static sun.scjp.Color.GREEN;</li>
</ol>
<p> Answer : C, E </p>


<h3>Question : 24</h3>
Given :
<pre>
11 public class Fabric{
12 public enum Color{
13 RED(0xff0000),GREEN(0x00ff00),BLUE(0x0000ff);
14 private final int rgb;
15 Color(int rgb){this.rgb=rgb;}
16 public int getRGB(){return rgb;}
17 };
18 public static void main(String[] args){
19 <b>//insert code here</b>
20 }
21 }
</pre>

<strong>Which two code fragments,inserted independently at line 19, allow the Fabric class to compile ? (Choose two)</strong>
<ol type="A">
<li>Color skyColor=BLUE; </li>
<li>Color treeColor=Color.GREEN; </li>
<li>Color purple=new Color(0xff00ff))); </li>
<li>if(RED.getRGB()&lt;BLUE.getRGB()){} </li>
<li>Color purple=Color.BLUE+Color.RED;</li>
<li>if(Color.RED.ordinal()&lt;Color.BLUE.ordinal()){}</li>
</ol>
<p> Answer : B, F </p>





<h3>Question : 25</h3>
Given :
<pre>
10 public class RainBow{
11 public enum MyColor{
12 RED(0xff0000),GREEN(0x00ff00),BLUE(0xff0000);
13 private final int rgb;
14 MyColor(int rgb){this.rgb=rgb;}
15 public int getRGB(){return rgb;}
16 };
17 public static void main(String[] args){
18 <b>//insert code here</b>
19 }
20 }
</pre>

<strong>Which code fragment, inserted at line 18, allows the Rainbow class to compile ?</strong>
<ol type="A">
<li>MyColor skyColor=BLUE; </li>
<li>MyColor treeColor=MyColor.GREEN; </li>
<li>if(RED.getRGB()&lt;BLUE.getRGB()){} </li>
<li>Compilation fails due to other error(s) in the code. </li>
<li>MyColor purple=new MyColor(0xff00ff);</li>
<li>MyColor purple=MyColor.BLUE+MyColor.RED;</li>
</ol>
<p> Answer : B </p>


<h3>Question : 26</h3>
Given :
<pre>
10 class Money{
11 private String country="Canada";
12 public String getC(){return country;}
13 }
14 class Yen extends Money{
15 public String getC(){return super.country;}
16 }
17 public class Euro extends Money{
18 public String getC(int x){return super.getC();}
19 public static void main(String[] args){
20 System.out.println(new Yen().getC()+" "+new Euro().getC());
21 }
22 }
</pre>

<strong>What is the result ?</strong>
<ol type="A">
<li>Canada </li>
<li>null Canada </li>
<li>Canada null </li>
<li>Canada Canada </li>
<li>Compilation fails due to an error on line 15.</li>
<li>Compilation fails due to an error on line 18.</li>
</ol>
<p> Answer :  E</p>



<h3>Question : 27</h3>
Given the following.
<pre>
interface Base{
boolean m1();
byte m2(short s);
}
</pre>

<strong>Which code fragments will compile ? (Choose all that apply.)</strong> 
<ol type="A">
<li>
<pre>
interface Base2 implements Base{}
</pre> </li>
<li>
<pre>
abstract class Class2 extends Base{
public boolean m1(){return true;}}
</pre> </li>
<li>
<pre>abstract class Class2 implements Base{}</pre>
 </li>
<li>
<pre>
abstract class Class2 implements Base{
public boolean m1(){return(true);}}
</pre> </li>
<li>
<pre>
class Class2 implements Base{
boolean m1(){return false;}
byte m2(short s){return 42;} }
</pre></li>
</ol>
<p> Answer :  C, D</p>

<ul>
<li>A is incorrect because interfaces don't implement any thing.</li>
<li>B is incorrect because classes don't extend interfaces.</li>
<li>C is correct because an abstract class doesn't have to implement any or all of its interface's methods.</li>
<li>D is correct because the method is correctly implemented.</li>
<li>E is incorrect because  interface methods are implicitly public, so the methods being implemented must be public.</li> 
</ul>



<h3>Question : 28</h3>
<pre>

</pre>

<strong>Which declare a compilable abstract class ? (Choose all that apply)</strong>
<ol type="A">
<li>
<pre>
public abstract class Canine { 
	public Bark speak();
}
</pre> </li>
<li>
<pre>
public abstract class Canine { 
	public Bark speak(){ } 
}
</pre> </li>
<li>
<pre>
public class Canine { 
 public abstract Bark speak(); 
}
</pre> </li>
<li>
<pre>
public class Canine abstract { 
 public abstract Bark speak(); 
}
</pre> </li>
</ol>
<p> Answer :  B</p>

<ul>
<li>A is incorrect because abstract methods must be marked as such.</li>
<li>B is correct. abstract classes don't have to have any abstract methods.</li>
<li>C is incorrect because you can't have an abstract method unlesss the class is abstract.</li>
<li>D is incorrect because the keyword abstract must come before the class name.</li>  
</ul>

<h3>Question : 29</h3>
<pre>

</pre>

<strong>What is true ? (Choose all that apply.)</strong>
<ol type="A">
<li>"X extends Y" is correct if and only if X is a class and Y is an interface. </li>
<li>"X extends Y" is correct if and only if X is an interface and Y is a class. </li>
<li>"X extends Y" is correct if X and Y are either both classes or both interfaces. </li>
<li>"X extends Y" is correct for all combinations of X and Y being classes and/or interfaces. </li>
</ol>
<p> Answer :  C</p>
<ul>
<li>A is incorrect because classes implement interfaces, they don't extend them.</li>
<li>B is incorrect because interfaces only "inherit from" other interfaces.</li>
<li>C is correct.</li>
<li>D is incorrect based on the preceding rules.</li>
</ul>


<h3>Question : 30</h3>
Given :
<pre>
11 enum Animals{
12 DOG("woof"),CAT("meow"),FISH("burble");
13 String sound;
14 Animals(String s){sound=s;}
15 }
16 public class TestEnum{
17 static Animals a;
18 public static void main(String[] args){
19 System.out.println(a.DOG.sound+" "+a.FISH.sound);
20}
21}
</pre>

<strong>what is the result ?</strong>
<ol type="A">
<li>woof burble </li>
<li>multiple compilation  errors  </li>
<li>Compilation fails due to an error on line 12 </li>
<li>Compilation fails due to an error on line 13 </li>
<li>Compilation fails due to an error on line 14 </li>
<li>Compilation fails due to an error on line 19</li>
</ol>
<p> Answer :  A</p>

<ul>
<li>A is correct; enums can have constructors and variables.</li>
<li>B,C,D,E and F are incorrect; these  lines all use correct syntax.</li>
</ul>

<h3>Question : 31</h3>
Given :
<pre>
11 enum A { A }
12 class E2{
13 enum B { B }
14 void C(){
15 enum D { D }
16 }
17 }
</pre>

<strong>Which statements are true  ? (Choose all that apply)</strong>
<ol type="A">
<li>The code compiles </li>
<li>if only line 11 is removed the code compiles.  </li>
<li>if only line 13 is removed the code compiles.  </li>
<li>if only line 15 is removed the code compiles.  </li>
<li>if lines 11 and 13 is removed the code compiles.  </li>
<li>if lines 11,13 and 15 are removed the code compiles.  </li>
</ol>
<p> Answer :  D, F</p>
<ul>
<li>D and F are correct. Line 15 is the only line that will not compile, because enums cannot be local to a method.</li>
<li>A,B,C and E are incorrect based on the above.</li>
</ul>















</td></tr></table>
<a href="scjpHomePage.html">BACK</a>
</div>

</body>

<!-- Mirrored from ocpjp.jobs4times.com/declarations.html by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jun 2024 15:29:37 GMT -->
</html>